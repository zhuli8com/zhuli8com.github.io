<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[zhuli8’blog]]></title>
  <subtitle><![CDATA[Talk is cheap, show me the code.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.zhuli8.com/"/>
  <updated>2015-08-10T06:32:58.000Z</updated>
  <id>http://www.zhuli8.com/</id>
  
  <author>
    <name><![CDATA[朱利]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[大话@property]]></title>
    <link href="http://www.zhuli8.com/2015/08/09/%E5%A4%A7%E8%AF%9D-property/"/>
    <id>http://www.zhuli8.com/2015/08/09/大话-property/</id>
    <published>2015-08-09T06:29:16.000Z</published>
    <updated>2015-08-10T06:32:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="@property">@property</h1><p>在普通的OC对象中，@property就是编译器自动帮我们生成一个私有的成员变量和getter、setter方法的声明及实现。为了研究编译器是如何实现@property的，我们需要使用clang。clang提供一个命令，可以将OC的源码改写成c++的，借此可以研究@property具体的源码实现方式。该命令是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">clang</span> <span class="tag">-rewrite-objc</span> <span class="tag">xxx</span><span class="class">.m</span></span><br></pre></td></tr></table></figure>
<p>除此之外我们还可以通过苹果开源的runtime进行研究，源码地址。<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">源码</a></p>
<h2 id="线程安全">线程安全</h2><h3 id="atomic、nonatomic">atomic、nonatomic</h3><p>atomic为原子性，会对set方法的实现进行加锁，多线程下可以一个线程写多个线程读，主要用在mac开发；nonatomic为非原子性，set方法的实现不加锁（比atomic性能高）。因为mac开发早于iOS开发，所以默认值为atomic。（A joke!）在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备nonatomic特质，则不使用同步锁。</p>
<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。因此，在iOS开发中，你会发现，几乎所有属性都声明为nonatomic；但是在开发Mac OS X程序时，使用 atomic属性通常都不会有性能瓶颈。</p>
<p>问题来了：</p>
<blockquote>
<p>@property (strong) NSMutableArray *array; 有什么问题？</p>
</blockquote>
<p>线程安全特性默认为atomic，该属性使用了同步锁，会在创建属性时生成一些额外的代码用于帮助写多线程程序，这会带来性能问题，通过显示声明nonatomic可以节省这些虽然很小但是不必要的额外开销。</p>
<h2 id="访问权限">访问权限</h2><h3 id="readonly、readwrite">readonly、readwrite</h3><p>readonly只生成get方法的声明和实现； readwrite同时生成get方法和set方法的声明和实现。</p>
<h2 id="内存管理">内存管理</h2><p>每个对象都有一个引用计数器，每个新对象的计数器默认是1，当对象的计数器减为0时就会被销毁；通过retain可以让对象的计数器加1、release可以让对象的计数器减1，还可以通过 <strong>autorelease pool</strong> 管理内存；只要调用了alloc、copy、new、retain方法产生的新对象，都必须在最后调用一次release或者autorelease；如果使用ARC，编译器会自动生成管理内存的代码。</p>
<h3 id="assign">assign</h3><p>set方法的实现是直接赋值，用于基本数据类型的简单赋值操作，用于非OC对象。</p>
<h3 id="weak(ARC)">weak(ARC)</h3><p>weak表明该属性定义了一种“非拥有关系（nonowning relationship）”，set方法的实现既不release旧也不retain新值，同assign类似，然而当对象销毁的时候，指针会被自动设置为nil，weak必须用于OC对象。</p>
<p>使用场合：</p>
<blockquote>
<p>*在ARC中，出现循环引用的时候，必须要有一端使用weak，比如：delegate。</p>
<p>*自身已经对它进行一次强引用，没有必要在强引用一次，此时也会使用weak，比如@IBOutlet。</p>
</blockquote>
<h3 id="copy">copy</h3><p>set方法的实现是release旧值，copy新值，用于NSString、block等类型。<br>栗子来了：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(nonatomic, <span class="keyword">copy</span>) NSString *<span class="property">name</span>;</span><br><span class="line">- (void)setName:(NSString *)<span class="property">name</span>&#123;	<span class="keyword">if</span> (_name != <span class="property">name</span>) &#123;		[_name release];		_name = [<span class="property">name</span> <span class="keyword">copy</span>];	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>字符串使用copy是为了外部把字符串内容改了不影响该属性；block使用copy是在MRC遗留下来的，在MRC中方法内部的block是在栈区的，使用copy可以把它放到堆区。在ARC中对于block使用copy还是strong效果是一样的。</p>
<h3 id="Copy扩展">Copy扩展</h3><h4 id="前提">前提</h4><p>实现NSCopying或NSMutableCoping。</p>
<h4 id="作用">作用</h4><ol>
<li>改变原对象不影响拷贝对象。</li>
<li>改变拷贝对象不影响源对象。</li>
</ol>
<h4 id="浅复制和深复制">浅复制和深复制</h4><p>Copy产生的是不可变副本，MutableCopy产生的是可变副本。</p>
<p>只要源对象是不可变类型且产生的对象也是不可变类型的时的情况是浅复制，其他情况都是深复制。浅复制是源对象和拷贝对象指向同一对象，深复制是产生了不同的对象。</p>
<h4 id="@property和copy">@property和copy</h4><p>在set方法中release旧值copy新值，用于NSString和block，可以保证属性不会被外部变量（例如NSMutableString类型变量）的改变所影响。</p>
<p>问题来了：</p>
<blockquote>
<p>@property (nonatomic，copy) NSMutableArray *array;这个写法会出什么问题？</p>
</blockquote>
<p>copy产生的是不可变副本，在set方法中release旧值copy新值，所以运行时类型为NSArray，编译时类型为NSMutableArray，所以对array执行添加、删除、修改数组内的元素的时候程序会因为找不到对应的方法而崩溃。</p>
<p>栗子来了：</p>
<blockquote>
<p>当一个使用 <strong> initWithArray:</strong> 初始化方法创建的NSMutable对象赋值给array属性，那么之后array执行可变数组的方法，比如：<strong>removeObjectAtIndex:</strong> 时会出现”-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x100206cd0”的崩溃。原因在于array属性在被赋值（setter）的时候默认执行了copy方法后变为了不可变NSArray对象。</p>
</blockquote>
<h4 id="自定义对象">自定义对象</h4><ol>
<li>遵守NSCopying或NSMutableCopying协议。其实也可以在代码中不写协议类的遵守，只实现里面的方法，协议只是用来方便生成快捷方法的。</li>
<li>实现copyWithZone或mutableCopyWithZone。即用self实例化对象（[[[self class] allocWithZone: zone]init];）、属性赋值、返回对象。</li>
</ol>
<h4 id="特别注意">特别注意</h4><p>编译时类型和运行时类型，应以运行时类型为准。</p>
<h3 id="strong(ARC)、retain(MRC)">strong(ARC)、retain(MRC)</h3><p>set方法的实现是release旧值，retain新值，用于OC对象类型。</p>
<p>栗子来了：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(nonatomic, <span class="keyword">copy</span>) NSString *<span class="property">name</span>;</span><br><span class="line">- (void)setName:(NSString *)<span class="property">name</span>&#123;	<span class="keyword">if</span> (_name != <span class="property">name</span>) &#123;		[_name release];		_name = [<span class="property">name</span> retain];	&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指定方法名称">指定方法名称</h2><p>setter=</p>
<p>getter=</p>
<h2 id="@synthesize和@dynamic">@synthesize和@dynamic</h2><p>@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是:</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">@synthesize</span> <span class="reserved">var</span>=_var;</span><br></pre></td></tr></table></figure>
<h3 id="@synthesize">@synthesize</h3><p>@synthesize的语义就是，如果没有指定成员变量的名称会自动生成一个属性同名的成员变量，如果这个成员变量已经存在了就不再生成。</p>
<p>如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</p>
<p>在@property被增强之后其实已经很少使用@synthesize</p>
<h3 id="@dynamic">@dynamic</h3><p>@dynamic告诉编译器，属性的setter方法和getter方法由我自己实现不用自动生成（对于readonly的属性只需提供getter方法即可），如果你木有提供setter方法和getter方法，编译时是没问题，但是当程序运行时调用会由于缺少setter方法或gettr方法导致程序崩溃。</p>
<p>编译时是靠Xcode把关，运行时靠runtiime机制来执行相应的方法，这就是所谓的动态绑定。</p>
<h1 id="参考链接">参考链接</h1><p><a href="http://www.jianshu.com/p/4fea8fa60d75" target="_blank" rel="external">iOS面试题</a></p>
<p><a href="http://www.90159.com/2015/07/26/71/" target="_blank" rel="external">iOS面试题集锦</a></p>
<p><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md" target="_blank" rel="external">《招聘一个靠谱的iOS》面试题参考答案（上）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[iOS中常见@property面试题分析]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发、Mac使用中这些你造吗]]></title>
    <link href="http://www.zhuli8.com/2015/08/01/iOS%E5%BC%80%E5%8F%91%E3%80%81Mac%E4%BD%BF%E7%94%A8%E4%B8%AD%E8%BF%99%E4%BA%9B%E4%BD%A0%E9%80%A0%E5%90%97/"/>
    <id>http://www.zhuli8.com/2015/08/01/iOS开发、Mac使用中这些你造吗/</id>
    <published>2015-08-01T02:02:14.000Z</published>
    <updated>2015-08-29T23:07:40.000Z</updated>
    <content type="html"><![CDATA[<p>子曰：工欲善其事，必先利其器。居是邦也。事其大夫之贤者，友其士之仁者。</p>
<p>有志者事竟成，破釜沉舟，百二秦关终属楚； 苦心人天不负，卧薪尝胆，三千越甲可吞吴。 </p>
<p>由此产生此文！</p>
<h1 id="Mac常用快捷键">Mac常用快捷键</h1><h2 id="窗口操作">窗口操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+Q：退出程序</span><br></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dock右键App+Alt：退出程序<span class="comment">--&gt;强制退出</span></span><br></pre></td></tr></table></figure>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">W</span>：关闭程序的窗口，并没有真正退出程序</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command（长按）+<span class="keyword">Tab</span>：切换程序窗口</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command（长按）+空格：切换输入法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+⬆️：管理多个桌面</span><br></pre></td></tr></table></figure>
<h2 id="文件操作">文件操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击一下文件、文件夹+空格：快速预览内容，无需双击打开。</span><br></pre></td></tr></table></figure>
<h1 id="Xcode常用快捷键">Xcode常用快捷键</h1><h2 id="Xcode导航快捷键">Xcode导航快捷键</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+1：工程导航器</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+0：显示、隐藏导航器面板</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">Option</span>+<span class="number">0</span>：显示、隐藏实用工具面板</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在项目导航器中选中文件，执行<span class="keyword">Option</span>+左键点击操作：在辅助编辑器中打开文件</span><br></pre></td></tr></table></figure>
<h2 id="Xcode搜索快捷键">Xcode搜索快捷键</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">Shift</span>+F：搜索导航器(<span class="built_in">Find</span> Navigator，也就是搜索)</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Control</span>+<span class="number">6</span>（键入方法/变量名+<span class="keyword">Enter</span>跳转）：文件跳转栏</span><br></pre></td></tr></table></figure>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + O：快速打开</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Control</span> + Command + ⬆️：程序中(Objective-<span class="keyword">C</span>或<span class="keyword">C</span>++编写).h and .m文件间的快速切换</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">L</span>：输入行号进行快速查找</span><br></pre></td></tr></table></figure>
<h2 id="应用程序编译和清理">应用程序编译和清理</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + R：运行app</span><br></pre></td></tr></table></figure>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + K：清除工程</span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + B：构建应用程序</span><br></pre></td></tr></table></figure>
<h2 id="调试相关">调试相关</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + . ：方便地暂停运行iOS模拟器</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">K</span>：删除调试面板里的信息，相当于<span class="keyword">Debug</span> Workflow-&gt;<span class="keyword">Clear</span> Console</span><br></pre></td></tr></table></figure>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Command+<span class="keyword">Y</span>：继续执行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F6：跳过方法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F7：跳入方法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F8：跳出方法</span><br></pre></td></tr></table></figure>
<h2 id="文档和帮助">文档和帮助</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + <span class="number">0</span> (Zero)：文档和参考</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在类或者方法名上执行<span class="keyword">Option</span> + 左键点击操作：快速帮助</span><br></pre></td></tr></table></figure>
<h2 id="其他快捷键">其他快捷键</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + J：可展示当前你在工程导航器中打开的文件</span><br></pre></td></tr></table></figure>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + <span class="number">1</span>：可打开<span class="string">"Show Related Items’弹出菜单</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Option</span> + Shift + 左键点击操作：该组合键可展示一个小尺寸的弹出视图，你可以查看你想要打开它的地方，比如辅助编辑器、标签或者窗口等。</span><br></pre></td></tr></table></figure>
<h1 id="VIM编辑器相关">VIM编辑器相关</h1><h2 id="VIM的运行模式">VIM的运行模式</h2><pre><code>编辑模式：等待编辑命令输入

插入模式：编辑模式下，输入 “<span class="built_in">i</span>” 进行插入模式，插入文本信息

命令模式：在编辑模式下按Esc键，输入 “:” 进行命令模式
</code></pre><h2 id="VIM使用的命令">VIM使用的命令</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:q</span>：直接退出</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:wq</span>：保存后退出</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:q</span>!：强制退出</span><br></pre></td></tr></table></figure>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Shift</span>+v：选中光标行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y：复制选中行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p：粘贴选中行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x：删除光标前的一个字符</span><br></pre></td></tr></table></figure>
<h1 id="常见Unix指令">常见Unix指令</h1><p>因为Mac系统是基于UNIX系统的，因此可以在“终端”中输入一些UNIX指令来操作Mac系统。比如：新建文件（夹）、打开文件（夹）等。</p>
<h2 id="文件目录操作指令">文件目录操作指令</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span>：列出当前目录下的所有内容（文件、文件夹）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-l：列出文件的详细信息</p>
<p>-a：列出当前目录所有文件，包括隐藏文件</p>
</blockquote>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>：新建一个目录</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p：父目录不存在的情况下先生成父目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>：改变当前操作的目录</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch：新建一个文件（文件不存在才会新建）</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>（tac）：显示文本文件内容</span><br></pre></td></tr></table></figure>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span>：复制文件或目录</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rm</span>：删除文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-r：同时（递归）删除该目录下的所有文件</p>
<p>-f：强制删除文件或目录</p>
</blockquote>
<pre><code>mv：移动文件或目录
</code></pre><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>：在文件系统中查找指定的文件</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>：显示当前目录的名称</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span>：打开一个文件（夹）</span><br></pre></td></tr></table></figure>
<p><strong>注：按一下Tab键可以自动补齐指令名称、文件名、文件夹名等。</strong></p>
<h2 id="Unix指令中的特殊路径">Unix指令中的特殊路径</h2><p>Mac系统采用的是UNIX文件系统，所有的文件都放在根目录下（即“\”）,因此没有Windows中的C盘、D盘的概念，文件路径就不再有盘符。例如：</p>
<pre><code>Windows中：<span class="string">c:</span><span class="comment">//Users/你的用户名/Desktop</span>

Mac中：<span class="regexp">/Users/</span>你的用户名/Desktop
</code></pre><p>在使用Unix指令过程中，经常会涉及到目录（路径）操作，下面列出几个有特殊含义的路径：</p>
<pre><code>/：根路径
./：当前路径
../：上一级路径
/：根目录，以斜杠表示，其他所有文件和目录在根目录下展开。
/bin：“binary”的缩写，存放提供用户级基础功能的二进制文件，如ls、ps等。
/boot：存放能使系统成功启动的所有文件，这些文件一般在内核用户程序开始执行前得到调用。在iOS中此目录为空。
/dev：“device”的简写，存放BSD设备文件。每个文件代表系统的一个块设备或字符设备，一般来说，“块设备”以块为单位传输数据，如硬盘；而“字符设备”以字符为单位传输数据，如调整解调器。
/sbin：“system binaries”的简写，存放提供系统级基础功能的二进制文件，如netstat、reboot等。
<span class="regexp">/etc：“et cetera”的简写，存放系统脚本及配置文件，如passwd、hosts等。在iOS中，/</span>etc是一个符号链接，实际指向<span class="regexp">/private/</span>etc。
/lib：存放系统库文件、内核模块及设备驱动等。iOS中此目录为空。
/mnt：“mount”的简写，存放临时的文件系统挂载点。iOS中此目录为空。
<span class="regexp">/private：存放两个目录，分别是/</span><span class="keyword">private</span><span class="regexp">/etc和/</span><span class="keyword">private</span>/var。
<span class="regexp">/tmp：临时目录。在iOS中，/</span>tmp是一个符号链接，实际指向<span class="regexp">/private/</span>tmp。
<span class="regexp">/usr：包含了大多数用户工具和程序。/</span>usr<span class="regexp">/bin包含那些/</span>bin和<span class="regexp">/sbin中未出现的基础功能，如nm、killall等；/</span>usr<span class="regexp">/include包含所有的标准C头文件；/</span>usr/lib存放库文件。
<span class="regexp">/var：“variable”的简写，存放一些经常更改的文件，如日志、用户数据、临时文件等。其中/</span>var<span class="regexp">/mobile/</span>Applications下存放了所有App Store App，是要重点关注的目录之一。
</code></pre><h2 id="系统管理命令">系统管理命令</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who（w）：显示在线登陆用户</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami：显示用户自己的身份</span><br></pre></td></tr></table></figure>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hostname</span>：显示主机名称</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname：显示系统信息</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>：显示当前系统中耗费资源最多的进程</span><br></pre></td></tr></table></figure>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ps</span>：显示瞬间的进程状态</span><br></pre></td></tr></table></figure>
<pre><code><span class="title">ifconfig</span> en0：显示网络接口信息
</code></pre><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clear</span>：清屏</span><br></pre></td></tr></table></figure>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">man</span>：命令帮助信息查询</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export</span><br><span class="line"></span><br><span class="line">设置或显示环境变量，但是只在本次登陆中有效。在shell中执行程序时，shell会提供一组环境变量，export可新增、修改或删除环境变量，供后续执行的程序使用，效力仅及于此登陆操作。export设置环境变量是暂时的，只在本次登陆中有效。=前的<span class="constant">PATH变</span>量不加<span class="variable">$符</span>号，再增加的路径用<span class="symbol">:</span>追加。</span><br><span class="line"></span><br><span class="line">export <span class="constant">PATH=</span><span class="variable">$PATH</span><span class="symbol">:/Library/Developer/IceTouch-</span><span class="number">1.3</span>/<span class="constant">SDKs/Objc/</span>bin</span><br></pre></td></tr></table></figure>
<h1 id="iphone的一些操作">iphone的一些操作</h1><p>双击Shift开启大写</p>
<p>摇一摇撤销</p>
<p>计算器输入的时候手指右划可以删除输入的数字</p>
<p>按住键盘上的小地球切换输入法</p>
<p>拍照可以按声音键</p>
<p>点击状态栏回到顶部</p>
<p>导航侧滑</p>
<h1 id="写在最后">写在最后</h1><p>iOS开发和Mac使用中你还有哪些能提高开发效率的小技巧和快捷键以及黑科技，在评论中一起分享吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>子曰：工欲善其事，必先利其器。居是邦也。事其大夫之贤者，友其士之仁者。</p>
<p>有志者事竟成，破釜沉舟，百二秦关终属楚； 苦心人天不负，卧薪尝胆，三千越甲可吞吴。 </p>
<p>由此产生此文！</p>
<h1 id="Mac常用快捷键">Mac常用快捷键</h1><]]>
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="开发利器" scheme="http://www.zhuli8.com/tags/%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/"/>
    
      <category term="开发利器" scheme="http://www.zhuli8.com/categories/%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[信令、stun、turn、ice]]></title>
    <link href="http://www.zhuli8.com/2015/07/26/%E4%BF%A1%E4%BB%A4%E3%80%81stun%E3%80%81turn/"/>
    <id>http://www.zhuli8.com/2015/07/26/信令、stun、turn/</id>
    <published>2015-07-26T09:48:27.000Z</published>
    <updated>2015-07-22T07:04:23.000Z</updated>
    <content type="html"><![CDATA[<p>webRTC支持点对点通讯，但是webRTC仍然需要服务端：</p>
<ul>
<li>协调通讯过程中客户端之间需要交换元数据，如一个客户端找到另一个客户端以及通知另一个客户端开始通讯。</li>
<li>需要处理NAT（网络地址转换）或防火墙，这是公网上通讯首要处理的问题。</li>
</ul>
<p>所以我们需要了解服务端相关的知识：信令、Stun、trun、ice。</p>
<h1 id="什么是信令">什么是信令</h1><p>信令就是协调通讯的过程，为了建立一个webRTC的通讯过程，客户端需要交换如下信息：</p>
<ul>
<li>会话控制信息，用来开始和结束通话，即开始视频、结束视频这些操作指令。</li>
<li>处理错误的消息。</li>
<li>元数据，如各自的音视频解码方式、带宽。</li>
<li>网络数据，对方的公网IP、端口、内网IP及端口。</li>
</ul>
<p>信令处理过程需要客户端能够来回传递消息，这个过程在webRTC里面是没有实现的，需要自己创建。一旦信令服务建立好了,两个客户端之间建立了连接,理论上他们就可以进行点对点通讯了,这样可以减轻信令服务的压力和消息传递的延迟。</p>
<p>因为信令是我们自己定义的,所以安全性问题跟webrtc无关,需要自己处理。一旦黑客掌握了你的信令,那他就是控制会话的开始、结束、重定向等等。最重要的因素在信令安全中还是要靠使用安全协议,如HTTPS,WSS(如TLS),他们能确保未加密的消息不能被截取。为确保信令安全,强烈推荐使用TLS。</p>
<h1 id="TURN和STUN">TURN和STUN</h1><p>元数据是通过信令服务器中转发给另一个客户端,但是对于流媒体数据,一旦会话建立,首先尝试使用点对点连接。简单一点说就是:每个客户端都有一个唯一的地址,他能用来和其他客户端进行通讯和数据交换。现实生活中客户端都位于一个或多个NAT之后,或者一些杀毒软件还阻止了某些端口和协议,或者在公司还有防火墙或代理等等,防火墙和NAT或许是同一个设备,如我们家里用的路由器。</p>
<p>webrtc就是通过 ICE 这套框架来处理复杂的网络环境的,如果想启用这个功能,你必须让你的应用程序传 ICE 服务器的URL：ICE试着找最好的路径来让客户端建立连接,他会尝试所有可能的选项,然后选择最合适的方案,ICE首先尝试P2P连接,如果失败就会通过Turn服务器进行转接。换一个说法就是:</p>
<p><strong> STUN服务器是用来取外网地址的。</strong></p>
<p><strong> TURN服务器是在P2P失败时进行转发的 </strong></p>
<p>stun和turn服务的作用主要处理打洞与转发，配合完成ICE协议。首先尝试使用P2P，如果失败将求助于TCP，使用turn转发两个端点的音视频数据，turn转发的是两个端点之间的音视频数据不是信令数据。因为turn服务器是在公网上，所以他能被各个客户端找到，另外turn服务器转发的是数据流，很占用带宽和资源。</p>
<h1 id="ICE技术">ICE技术</h1><p>基于IP的语音、数据、视频等业务在NGN（Next Generation Network）网络中所面临的一个实际困难就是如何有效地穿透各种NAT（Network Address Translator）/FW(Fire Wall)的问题。对此，SIP（会话初始化协议）以往的解决方法由ALGs（(Application Layer Gateway Service)）、STUN、TURN等方式。现在有一种新的媒体会话信令穿透NAT/FW的解决方案-交互式连通建立方式ICE。它通过综合利用现有协议，以一种更有效的方式来组织会话建立过程，使之在不增加任何延迟同时比STUN等单一协议更具有健壮性、灵活性。</p>
<p>多媒体会话信令协议是在准备建立媒体流传输的代理之间交互信息的协议，例如SIP、RTSP（real time streaming protocol）等。媒体流与信令流截然不同，它们所采用的网络通道也不一致。由于协议自身设计上的原因，使得媒体流无法直接穿透网络地址转换/防火墙(NAT/FW)。因为它们生存期的目标只是为了建立一个在信息中携带IP地址的分组流，这在遇到NAT/FW 时会带来许多问题。而且这些协议的目标是通过建立P2P(Peer to Peer)媒体流以减小时延，而协议本身很多方面却与NAT存在兼容性问题，这也是穿透 NAT/FW的困难所在。</p>
<h2 id="ICE简介">ICE简介</h2><p>交互式连通建立方式ICE(Interactive Connectivity Establishment)并非一种新的协议，它不需要对STUN、TURN或RSIP进行扩展就可适用于各种NAT。ICE是通过综合运用上面某几种协议，使之在最适合的情况下工作，以弥补单独使用其中任何一种所带来的固有缺陷。对于SIP来说，ICE只需要定义一些SDP(Session Description Protocol)附加属性即可，对于别的多媒体信令协议也需要制定一些相应的机制来实现。</p>
<h2 id="多媒体信令">多媒体信令</h2><p>媒体流穿透NAT的过程是独立于某种具体的信令协议的。通信发生在两个客户端－会话发起者和会话响应者。初始化信息(Initiate Message)包含了描述会话发起者媒体流的配置与特征，并经过信令调停者(也叫信令中继)，最后到达会话响应者。假设会话响应者同意通信，接受信息(Accept Message)将产生并反馈至会话初始者，媒体流建立成功。此外，信令协议还对媒体流参数修改以及会话终止消息等提供支持。对于SIP，会话发起者即UAC(User Agent Client)，会话响应者即UAS(User Agent Server)，初始化消息对应SDP请求里面的INVITE，接受消息对应于SDP应答里面的200 OK，终止消息对应于BYE。</p>
<h2 id="流程">流程</h2><h3 id="收集传输地址">收集传输地址</h3><p>会话发起者需要收集的对象包括本地传输地址(Local Transport Address)和来源传输地址(Derived Transport Address)。本地传输地址通常由主机上一个物理(或虚拟)接口绑定一个端口而获得。会话发起者还将访问提供UNSAF(Unilateral self-address fixing)的服务器，例如STUN、TURN或TEREDO。对于每一个本地传输地址，会话者都可以从服务器上获得一组来源传输地址。显然，实现物理或虚拟连通方式越多，ICE将工作得越好。但为了建立对等通信，ICE通常要求至少有一个来源地址由位于公网上的中继服务器(如TURN)所提供的，而且需要知道具体是哪一个来源传输地址。</p>
<h3 id="启动STUN">启动STUN</h3><p>会话发起者获得一组传输地址后，将在本地传输地址启动STUN服务器，这意味着发送到来源地址的STUN服务将是可达的。与传统的STUN不同，客户端不需要在任何其它IP或端口上提供STUN服务，也不必支持TLS， ICE用户名和密码已经通过信令协议进行交换。客户端将在每个本地传输地址上同时接受STUN请求包和媒体包，所以发起者需要消除STUN消息与媒体流协议之间的歧义。在RTP和RTCP中实现这个并不难，因为RTP与RTCP包总是以0b10(v=2)打头，而STUN是0b00。对于每个运行STUN服务器的本地传输地址，客户端都必须选择相应的用户名和密码。用户名要求必须是全局唯一的，用户名和密码将被包含在初始化消息里传至响应者，由响应者对STUN请求进行鉴别。</p>
<h3 id="确定传输地址的优先级">确定传输地址的优先级</h3><p>STUN服务器启动后，下一步就是确定传输地址的优先级。优先级反映了UA在该地址上接收媒体流的优先级别，取值范围在0到1之间，通常优先级按照被传输媒体流量来确定。流量小者优先，而且对于相同流量者的Ipv6地址比Ipv4地址具有更高优先级。因此物理接口产生的本地Ipv6传输地址具有最高的优先级，然后是本地Ipv4传输地址，然后是STUN、RSIP、TEREDO来源地址，最后是通过VPN接口获得的本地传输地址。</p>
<h3 id="构建初始化信息(Initiate_Message)">构建初始化信息(Initiate Message)</h3><p>初始化消息由一系列媒体流组成，每个媒体流都有一个缺省地址和候选地址列表。缺省地址通常被Initiate消息映射到SIP信令消息传递地址上，而候选地址列表用于提供一些额外的地址。对于每个媒体流来说，任意Peer之间实现最大连通可能性的传输地址是由公网上转发服务器(如TURN)提供的地址，通常这也是优先级最低的传输地址。客户端将可用的传输地址编成一个候选地址列表(包括一个缺省地址)，并且为每个候选元素分配一个会话中唯一的标识符。该标识符以及上述的优先级都被编码在候选元素的id属性中。一旦初始化信息生成后即可被发送。</p>
<h3 id="响应处理：连通性检查和地址收集">响应处理：连通性检查和地址收集</h3><p>会话应答方接收到初始化信息Initiate Message后，会同时做几个事情：首先，执行 <em>收集传输地址</em> 中描述的地址收集过程。这些地址可以在呼叫到达前预收集，这样可以避免增加呼叫建立的时间。当获得来源地址以后，应答方会发送STUN Bind请求，该请求要求必须包含Username属性和Password属性，属性值为从 “alt”中得到的用户名和密码。STUN Bind请求还应包括一个Message-Integrity属性，它是由Initiate Message中候选元素的用户名和密码计算得来的。此外，STUN Bind请求不应有Change-Request或Response-Address属性。当一个客户端收到Initiate Message时，它将通过其中缺省地址和端口发送媒体流。如果STUN Bind请求消息引起错误应答，则需要检查错误代码。如果是401，430，432或500，说明客户端应该重新发送请求。如果错误代码是400，431和600，那么客户端不必重试，直接按超时处理即可。</p>
<h3 id="生成接受信息(Accept_Message)">生成接受信息(Accept Message)</h3><p>应答者可以决定是接受或拒绝该通信，若拒绝则ICE过程终止，若接受则发送Accept消息。Accept消息的构造过程与Initiate Message类似。</p>
<h3 id="接受信息处理">接受信息处理</h3><p>接受过程有两种可能。如果Initiate Message的接受者不支持ICE，则Accept Message将只包含缺省的地址信息，这样发起方就知道它不用执行连通性检查了。然而如果本地配置信息要求发起者通过TURN服务器发包来进行连通性检查，这将意味着那些直接发给响应者的包会被对方防火墙丢弃。为解决这个问题，发起者需要重新分配一个TURN来源地址，然后使用Send命令。一旦Send命令被接受，发起者将发送所有的媒体包到TURN服务器，由服务器转发至响应者。如果Accept Message包含候选项，则发起方处理Accept Message的过程就与响应方处理Initiate Message很相似了。</p>
<h3 id="附加ICE过程">附加ICE过程</h3><p>Initiate或Accept消息交换过程结束后，双方可能仍将继续收集传输地址，这通常是由于某些STUN事务过长而未结束引起，另一种可能是由于Initiate/Accept消息交换时提供了新的地址。</p>
<h3 id="ICE到SIP的映射">ICE到SIP的映射</h3><p>使用ICE方式穿透NAT，必须映射ICE定义的参数到SIP消息格式中，同时对其SDP属性进行简单扩展—在SDP的Media块中定义一个新的属性“alt”来支持ICE。它包含一个候选IP地址和端口，SDP的接受端可以用该地址来替换m和c中的地址。Media块中可能会有多个alt属性，这时每个alt应该包括不重复的IP地址和端口。</p>
<h1 id="写在最后">写在最后</h1><p>ICE方式的优势是显而易见的，它消除了现有的UNSAF机制的许多脆弱性。例如传统的STUN有几个脆弱点，其中一个就是发现过程需要客户端自己去判断所在NAT类型，这实际上不是一个可取的做法。而应用ICE之后，这个发现过程已经不需要了。另一点脆弱性在于STUN、TURN等机制都完全依赖于一个附加的服务器，而ICE利用服务器分配单边地址的同时，还允许客户端直接相连，因此即使STUN或TRUN服务器中有任何一个失败了，ICE方式仍可让呼叫过程继续下去。此外，传统的STUN最大的缺陷在于它不能保证在所有网络拓扑结构中都正常工作，最典型的问题就是Symmetric NAT。对于TURN或类似转发方式工作的协议来说，由于服务器的负担过重，很容易出现丢包或者延迟情况。而ICE方式正好提供了一种负载均衡的解决方案，它将转发服务作为优先级最低的服务，从而在最大程度上保证了服务的可靠性和灵活性。此外，ICE的优势还在于对Ipv6的支持，目前Cisco等公司正在设计基于ICE方式的NAT/FW解决方案。由于广泛的适应能力以及对未来网络的支持，ICE作为一种综合的解决方案将有着非常广阔的应用前景。</p>
]]></content>
    <summary type="html">
    <![CDATA[iOS下的webRTC开发实现IM]]>
    
    </summary>
    
      <category term="IM" scheme="http://www.zhuli8.com/tags/IM/"/>
    
      <category term="webRTC" scheme="http://www.zhuli8.com/tags/webRTC/"/>
    
      <category term="IM" scheme="http://www.zhuli8.com/categories/IM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[构建支持armv7和arm64的webRTC静态库]]></title>
    <link href="http://www.zhuli8.com/2015/07/19/%E6%9E%84%E5%BB%BA%E6%94%AF%E6%8C%81armv7%E5%92%8Carm64%E7%9A%84webRTC%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <id>http://www.zhuli8.com/2015/07/19/构建支持armv7和arm64的webRTC静态库/</id>
    <published>2015-07-19T04:13:57.000Z</published>
    <updated>2015-08-19T10:12:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。需要注意的是iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。</p>
<p><strong>目前为止Apple移动设备默认指令集</strong></p>
<hr>
<p>armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch</p>
<p>armv7 设备：iPhone3GS, iPhone4, iPhone4S, iPad, iPad2, iPad3(The New iPad), iPad mini,<br>iPod Touch 3G, iPod Touch4</p>
<p>armv7s设备： iPhone5, iPhone5C, iPad4(iPad with Retina Display)</p>
<p>arm64 设备： iPhone5S, iPad Air, iPad mini2(iPad mini with Retina Display)</p>
<hr>
<p>现在苹果默认要求支持armv7&amp;arm64，知道了这些信息我们进入下一话题！</p>
<h1 id="构建支持armv7和arm64的webRTC静态库">构建支持armv7和arm64的webRTC静态库</h1><p>总体思路就是将webRTC中的armv7静态库合并优化成一个单一的静态库，arm64中的所有静态库合并优化成一个单一的静态库，最后利用lipo指令合并这两个静态库为一个最终的静态库。</p>
<h2 id="armv7">armv7</h2><p>合并所有的*.a构建armv7为libWebRTC-armv7.a并优化静态库</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libtool -<span class="keyword">static</span> -o src<span class="regexp">/armv7/</span>Release-iphoneos<span class="regexp">/libWebRTC-temp.a src/</span>armv7<span class="regexp">/Release-iphoneos/</span>*.a</span><br><span class="line"></span><br><span class="line">strip -S -x -o src<span class="regexp">/armv7/</span>Release-iphoneos<span class="regexp">/libWebRTC-armv7.a -r src/</span>armv7<span class="regexp">/Release-iphoneos/</span>libWebRTC-temp.a</span><br></pre></td></tr></table></figure>
<h2 id="arm64">arm64</h2><p>合并所有的*.a构建arm64为libWebRTC-arm64.a</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libtool -<span class="keyword">static</span> -o src<span class="regexp">/arm64/</span>Release-iphoneos<span class="regexp">/libWebRTC-temp.a src/</span>arm64<span class="regexp">/Release-iphoneos/</span>*.a</span><br><span class="line"></span><br><span class="line">strip -S -x -o src<span class="regexp">/arm64/</span>Release-iphoneos<span class="regexp">/libWebRTC-arm64.a -r src/</span>arm64<span class="regexp">/Release-iphoneos/</span>libWebRTC-temp.a</span><br></pre></td></tr></table></figure>
<p><strong>2015年7月27日更新</strong></p>
<p><strong>之前的指令用在音频没有问题，但是用在视频只有声音没有图像。最后检查发现没有使用strip优化之前的包可以使用，而且不能包括iOS生成的静态库。
</strong></p>
<h2 id="创建支持armv7&amp;arm64的libWebRTC">创建支持armv7&amp;arm64的libWebRTC</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -<span class="built_in">create</span> src/armv7/Release-iphoneos/libWebRTC-armv7.<span class="operator">a</span> src/arm64/Release-iphoneos/libWebRTC-arm64.<span class="operator">a</span> -output libWebRTC.<span class="operator">a</span></span><br></pre></td></tr></table></figure>
<p><strong>lipo -info libWebRTC.a，可以查看支持的架构信息</strong></p>
<p><strong>2015年8月19日更新</strong><br><strong>当测试armv7指令集通过后，在原来的工程中删掉armv7添加arm64对应的库时编译通不过，因为同一个文件下包含了两种架构信息所导致。解决方案：</strong></p>
<ol>
<li>选择工程, 编译的 (targets)</li>
<li>选择 Build Settings 菜单</li>
<li>查找 Library Search Paths 和 Framework Search Paths， 删掉编译报warning的路径即OK</li>
</ol>
<p><strong>关于Category位于静态库时,引用该静态库的工程使用Category,出现”unrecognized selector sent to class”提示。</strong></p>
<blockquote>
<p>标准UNIX静态库与Objective-C之间Linker的差异：在标准的UNIX静态库内,linker symbol是依照每一个类别而产生的,但由于Category并没有真正产生一个类别,所以出错。</p>
</blockquote>
<ol>
<li>在该静态库的Taraget-&gt;Build Settings-&gt;Other Linker Flags-&gt;加上 -ObjC</li>
<li>在使用该静态库的工程Taraget-&gt;Build Settings-&gt;Other Linker Flags-&gt;加上-all_load或-force_load</li>
</ol>
<p><strong>如果你的项目使用的非ARC模式，则为ARC模式的代码文件加入-fobjc-arc标签。如果你的项目使用的ARC模式，则为非ARC模式的代码文件加入 -fno-objc-arc标签。添加标签的方法:</strong></p>
<ol>
<li>打开target - Bulid Phases -Compile Sources</li>
<li>双击对应的*.m文件</li>
<li>在弹出的窗口中输入上面提到的标签 -fobjc-arc / -fno-objc-arc4</li>
<li>按Enter键保存</li>
</ol>
<h1 id="其他">其他</h1><p>libtool和lipo的相关指令选项参数可用通过man帮助进行查看，里面写的还是比较详细的。</p>
<h2 id="XCode中与指令集相关的选项（Build_Settings_面板下_Architectures）：">XCode中与指令集相关的选项（Build Settings 面板下 Architectures）：</h2><p>1.Architectures：      </p>
<p>指明选定Target要求被编译生成的二进制包所支持的指令集是通过编译生成对应的二进制数据包实现的，如果支持的指令集数目有多个，就会编译出包含多个指令集代码的数据包，从而会造成最终编译生成的包很大。</p>
<p>2.Valid Architectures：</p>
<p>指明可能支持的指令集并非Architectures列表中指明的指令集都会被支持，Valid Architectures限制可能被支持的指令集的范围，即Valid Architectures和Architectures列表的交集，才是XCode最终生成二进制包所支持的指令集。比如，将Architectures支持arm指令集设置为：armv7,armv7s，对应的Valid Architectures的支持的指令集设置为：armv7s,arm64，那么此时，XCode生成二进制包所支持的指令集只有armv7s 。</p>
<p>3.Build Active Architecture Only:</p>
<p>指明是否只编译当前连接设备所支持的指令集,该选项起作用的条件有两个，必须同时满足才会起作用：</p>
<ul>
<li>其值设置为YES</li>
<li>XCode成功连接调试设备</li>
</ul>
<p>当Build Active Architecture Only起作用时,连接的手机指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。<br>建议：通常Debug模式设置值为Yes，Release模式设置为No。</p>
<h2 id="WebRTC-framework的依赖"><a href="http://www.it165.net/pro/html/201503/35541.html" target="_blank" rel="external">WebRTC.framework的依赖</a></h2><p>如果项目使用了该框架,那么编译的时候需要在项目的Build Phases中添加如下库和框架:</p>
<blockquote>
<ul>
<li>libstdc++.6.dylib</li>
<li>libsqlite3.dylib</li>
<li>libc++.dylib</li>
<li>libicucore.dylib</li>
<li>Security.framework</li>
<li>CFNetwork.framework</li>
<li>GLKit.framework</li>
<li>AudioToolbox.framework</li>
<li>AVFoundation.framework</li>
<li>CoreAudio.framework</li>
<li>CoreMedia.framework</li>
<li>CoreVideo.framework</li>
<li>CoreGraphics.framework</li>
<li>OpenGLES.framework</li>
<li>QuartzCore.framework</li>
</ul>
</blockquote>
<p><strong>由于公司c++人员打包webRTC时模拟器的包有点问题，还有之前和linphone的libvpx.a的冲突最后删掉了linphone的而公用webRTC的，以至于模拟器缺少i386的libvpx.a库，解决办法：</strong></p>
<ol>
<li>将lib库拆分出armv7、armv7s、i386类型的.a，较麻烦<br>lipo -extract_family armv7 -output libDomobOfferWallSDK_arm.a libDomobOfferWallSDK.a<br>lipo -info libDomobOfferWallSDK_arm.a</li>
<li>对于i386则不用上述那么麻烦，直接用第一句-extract_family指令就能分离出只含i386版本的库<br>lipo -extract_family i386 -output libDomobOfferWallSDK_i386.a libDomobOfferWallSDK.a</li>
<li><a href="http://www.cnblogs.com/wengzilin/p/3800856.html" target="_blank" rel="external">http://www.cnblogs.com/wengzilin/p/3800856.html</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述">概述</h1><p>arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，]]>
    </summary>
    
      <category term="IM" scheme="http://www.zhuli8.com/tags/IM/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="IM" scheme="http://www.zhuli8.com/categories/IM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The Internet Communications (ice)]]></title>
    <link href="http://www.zhuli8.com/2015/07/12/The-Internet-Communications-Ice-%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.zhuli8.com/2015/07/12/The-Internet-Communications-Ice-简介/</id>
    <published>2015-07-12T09:26:50.000Z</published>
    <updated>2015-07-22T07:03:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><p>The Internet Communications Engine (ice) is a modern object-oriented toolkit that enables you to build distributed applications with minimal effort. Ice allows you to focus your efforts on your application logic, and it takes care of all interactions with low-level network programming interfaces. With Ice, there is no need to worry about details such as opening network connections, serializing and deserializing data for network transmission, or retrying failed connection attempts (to name but a few of dozens of such low-level details).</p>
<h1 id="开发环境搭建">开发环境搭建</h1><p>ICE安装文件：<a href="https://zeroc.com/icetouch/download.html" target="_blank" rel="external">https://zeroc.com/icetouch/download.html</a><br>ICE编译插件：<a href="https://github.com/zeroc-ice/ice-builder-xcode" target="_blank" rel="external">https://github.com/zeroc-ice/ice-builder-xcode</a></p>
<h1 id="相关文档">相关文档</h1><p>ICE官网：<a href="http://www.zeroc.com/ice.html" target="_blank" rel="external">http://www.zeroc.com/ice.html</a><br>官网文档：<a href="http://doc.zeroc.com/display/Doc/Home" target="_blank" rel="external">http://doc.zeroc.com/display/Doc/Home</a><br>性能评测：<a href="http://zeroc.com/articles/IcePerformanceWhitePaper.pdf" target="_blank" rel="external">http://zeroc.com/articles/IcePerformanceWhitePaper.pdf</a></p>
<h1 id="ICE通讯框架基本原理">ICE通讯框架基本原理</h1><p>ICE的思路是，用一个中间语言，建立数据结构规范和接口规范，然后再用一个IDE编译插件，将中间语言数据结构规范和接口规范编译为当前的语言，譬如OC的.h/.m文件，接下来，你在客户端和服务端实现中间语言定义号的接口，再做一些其它处理，就可以实现一个分布式程序了。这个思路确实很Nice，值得我们借鉴。</p>
<h1 id="通讯方式选择">通讯方式选择</h1><p>P2P（设备直连）</p>
<p>通过服务器中转</p>
<h1 id="网络连接方式">网络连接方式</h1><p>基于TCP的长连接</p>
<p>基于HTTP短连接PULL的方式</p>
<h1 id="协议选择">协议选择</h1><p>XMPP</p>
<p>SIP</p>
<p>MQTT</p>
<p>私有协议（二进制协议）</p>
<h1 id="其他">其他</h1><p>p2p视频聊天的过程：音视频数据采集—&gt;编码—&gt;发送—&gt;接收—&gt;解码—&gt;播放</p>
<p><a href="http://www.cnblogs.com/HouZhiHouJueBlogs/p/3864677.html" target="_blank" rel="external">The Internet Communications Engine (Ice) 跨平台异构通讯方案 第一弹-ICE简介</a></p>
<p><a href="http://www.cnblogs.com/HouZhiHouJueBlogs/p/3864737.html" target="_blank" rel="external">The Internet Communications Engine (Ice) 跨平台异构通讯方案 第二弹-Hello world！</a></p>
<p><a href="http://www.cnblogs.com/lingyunhu/category/626157.html" target="_blank" rel="external">webrtc</a></p>
]]></content>
    <summary type="html">
    <![CDATA[IM相关学习]]>
    
    </summary>
    
      <category term="IM" scheme="http://www.zhuli8.com/tags/IM/"/>
    
      <category term="ice" scheme="http://www.zhuli8.com/tags/ice/"/>
    
      <category term="IM" scheme="http://www.zhuli8.com/categories/IM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Grand Central Dispatch (gcd)]]></title>
    <link href="http://www.zhuli8.com/2015/07/05/Grand-Central-Dispatch-gcd/"/>
    <id>http://www.zhuli8.com/2015/07/05/Grand-Central-Dispatch-gcd/</id>
    <published>2015-07-05T06:50:07.000Z</published>
    <updated>2015-08-13T01:59:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="简介">简介</h1><h2 id="什么是GCD">什么是GCD</h2><ul>
<li>全程是Grand Central Dispatch，可译为“大中央调度”</li>
<li>纯C语言，提供了非常多强大的函数库</li>
</ul>
<h2 id="GCD的优势">GCD的优势</h2><ul>
<li>GCD是苹果公司为<strong>多核</strong>的<strong>并行</strong>运算提出的解决方案</li>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码<h1 id="任务和队列">任务和队列</h1></li>
<li>GCD中有两个核心概念</li>
</ul>
<ol>
<li><strong>任务</strong>：执行什么操作</li>
<li><strong>队列</strong>：用来存放任务</li>
</ol>
<ul>
<li>GCD的使用步骤</li>
</ul>
<ol>
<li><strong>定制任务</strong>：确定想做的事情</li>
<li><strong>将任务添加到队列中</strong>：GCD会自动将<em>队列</em>中的<em>任务</em>取出，放到对应的<em>线程</em>中执行；<em>任务</em>的取出遵循<em>队列</em>的FIFO原则：先进先出，后进后出<h2 id="执行任务">执行任务</h2>GCD中有2个用来执行任务的函数</li>
</ol>
<ul>
<li>用<strong>同步</strong>的方式执行任务<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>queue：队列<br>  block：任务</p>
</blockquote>
<ul>
<li><p>用<strong>异步</strong>的方式执行任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block); </span><br></pre></td></tr></table></figure>
</li>
<li><p>同步和异步的区别</p>
<blockquote>
<p>同步：只能在<strong>当前</strong>线程中执行任务，<strong>不具备</strong>开启新线程的能力<br>异步：可以在<strong>新的</strong>线程中执行任务，<strong>具备</strong>开启新线程的能力</p>
</blockquote>
</li>
</ul>
<h2 id="队列的类型">队列的类型</h2><p>GCD的队列可以分为2大类型</p>
<ul>
<li><p><strong>并发</strong>队列（Concurrent Dispatch Queue）</p>
<blockquote>
<p>可以让多个任务<strong>并发（同时）</strong>执行（自动开启多个线程同时执行任务）<br><strong>并发</strong>功能只有在<strong>异步（dispatch_async）</strong>函数下才有效</p>
</blockquote>
</li>
<li><p><strong>串行</strong>队列（Serial Dispatch Queue）</p>
<blockquote>
<p>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</p>
</blockquote>
</li>
<li>容易混淆的术语 <blockquote>
<p>有4个术语比较容易混淆：同步、异步、并发、串行<br><strong>同步和异步主要影响：能不能开启新的线程</strong><br>同步：在当前线程中执行任务，不具备开启新线程的能力<br>异步：在新的线程中执行任务，具备开启新线程的能力<br><strong>并发和串行主要影响：任务的执行方式</strong><br>并发：多个任务并发（同时）执行<br>串行：一个任务执行完毕后，再执行下一个任务</p>
</blockquote>
</li>
</ul>
<h3 id="并发队列">并发队列</h3><ul>
<li>GCD默认已经提供了全局的并发队列，供整个应用使用，不需要手动创建<br><strong>使用dispatch_get_global_queue函数获得全局的并发队列</strong><blockquote>
<p>dispatch_queue_t dispatch_get_global_queue(<br>dispatch_queue_priority_t priority, // 队列的优先级<br>unsigned long flags); // 此参数暂时无用，用0即可</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>); <span class="comment">// 获得全局并发队列</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>全局并发队列的优先级<br><code>#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高</code><br><code>#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中</code>）<br><code>#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低</code><br><code>#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台</code></p>
</blockquote>
<h3 id="串行队列 ">串行队列 </h3><ul>
<li>GCD中获得串行有2种途径</li>
</ul>
<p><strong>使用dispatch_queue_create函数创建串行队列</strong></p>
<blockquote>
<p>dispatch_queue_t<br>dispatch_queue_create(const char *label, // 队列名称<br>dispatch_queue_attr_t attr); // 队列属性，一般用NULL即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"cn.itcast.queue"</span>, NULL); <span class="comment">// 创建</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>使用主队列（跟主线程相关联的队列）</strong><br>主队列是GCD自带的一种特殊的串行队列<br>放在主队列中的任务，都会放到主线程中执行<br>使用dispatch_get_main_queue()获得主队列<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure></p>
<pre><code>凡是函数名种带有<span class="operator"><span class="keyword">create</span>\copy\new\retain等字眼, 都应该在不需要使用这个数据的时候进行<span class="keyword">release</span>
GCD的数据类型在ARC环境下不需要再做<span class="keyword">release</span>
CF(Core Foundation)的数据类型在ARC环境下还是需要再做<span class="keyword">release</span></span>
</code></pre><h3 id="各种队列的执行效果">各种队列的执行效果</h3><p><img src="http://www.zhuli8.com/photos/gcd.png" alt=""></p>
<blockquote>
<p><strong>注意</strong><br>使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列</p>
</blockquote>
<h1 id="线程间通信示例 ">线程间通信示例 </h1><h2 id="从子线程回到主线程">从子线程回到主线程</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行耗时的异步操作...</span><br><span class="line">      dispatch_async<span class="list">(<span class="keyword">dispatch_get_main_queue</span><span class="list">()</span>, ^&#123;</span><br><span class="line">        // 回到主线程，执行UI刷新操作</span><br><span class="line">        &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="延时执行">延时执行</h2><p>iOS常见的延时执行有2种方式</p>
<h3 id="调用NSObject的方法">调用NSObject的方法</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> <span class="symbol">performSelector:</span><span class="variable">@selector</span>(run) <span class="symbol">withObject:</span><span class="keyword">nil</span> <span class="symbol">afterDelay:</span><span class="number">2.0</span>];<span class="regexp">//</span> <span class="number">2</span>秒后再调用<span class="keyword">self</span>的run方法</span><br></pre></td></tr></table></figure>
<h3 id="使用GCD函数">使用GCD函数</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after<span class="params">(dispatch_time<span class="params">(DISPATCH_TIME_NOW, <span class="params">(int64_t)</span><span class="params">(<span class="number">2.0</span> * NSEC_PER_SEC)</span>)</span>, dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">    // <span class="number">2</span>秒后异步执行这里的代码...</span><br><span class="line">&#125;)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="一次性代码">一次性代码</h2><p>使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="队列组">队列组</h2><p>有这么1种需求<br>首先：分别异步执行2个耗时的操作<br>其次：等2个异步操作都执行完毕后，再回到主线程执行操作<br>如果想要快速高效地实现上述需求，可以考虑用队列组<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group =  dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行<span class="number">1</span>个耗时的异步操作</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行<span class="number">1</span>个耗时的异步操作</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    // 等前面的异步操作都执行完毕后，回到主线程...</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="单例模式">单例模式</h2><h3 id="单例模式的作用">单例模式的作用</h3><p>可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问，从而方便地控制了实例个数，并节约系统资源</p>
<h3 id="单例模式的使用场合">单例模式的使用场合</h3><ul>
<li>在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次）</li>
<li>单例模式在ARC\MRC环境下的写法有所不同，需要编写2套不同的代码<br>可以用宏判断是否为ARC环境<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __has_feature(objc_arc)</span></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ARC单例模式的实现">ARC单例模式的实现</h4><ul>
<li><p>在.m中保留一个全局的static的实例</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写allocWithZone:方法，在这里创建唯一的实例（注意线程安全）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_instance) &#123;</span><br><span class="line">            _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供1个类方法让外界访问唯一的实例</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedSoundTool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_instance) &#123;</span><br><span class="line">            _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现copyWithZone:方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="MRC">MRC</h4><p>非ARC中（MRC），单例模式的实现（比ARC多了几个步骤）<br><em>实现内存管理方法</em></p>
<pre><code>-<span class="ruby"> (id)retain { <span class="keyword">return</span> <span class="keyword">self</span>; }
</span>-<span class="ruby"> (<span class="constant">NSUInteger</span>)retainCount { <span class="keyword">return</span> <span class="number">1</span>; }
</span>-<span class="ruby"> (oneway void)release {}
</span>-<span class="ruby"> (id)autorelease { <span class="keyword">return</span> <span class="keyword">self</span>; }</span>
</code></pre><h1 id="推荐阅读">推荐阅读</h1><p><a href="http://www.jianshu.com/p/50c060bab0ff" target="_blank" rel="external">Ethan Joe：Grand Central Dispatch 基础教程：Part 1/2</a><br><a href="[Ethan Joe：Grand Central Dispatch 基础教程：Part 1/2](http://www.jianshu.com/p/50c060bab0ff">cocoachina：Grand Central Dispatch 基础教程：Part 2/2</a>)<br><a href="http://www.devtang.com/blog/2012/02/22/use-gcd/" target="_blank" rel="external">唐巧：使用GCD</a><br><a href="http://www.cocoachina.com/ios/20140428/8248.html" target="_blank" rel="external">GCD 深入理解（一）</a><br><a href="http://www.cocoachina.com/ios/20140515/8433.html" target="_blank" rel="external">GCD 深入理解（二）</a></p>
<h1 id="NSOperation&amp;NSOperationQueue">NSOperation&amp;NSOperationQueue</h1><p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<p><a href="http://blog.xcodev.com/archives/operation-queue-intro/" target="_blank" rel="external">并发编程之Operation Queue</a></p>
<p><a href="http://www.jianshu.com/p/0b0d9b1f1f19#" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></p>
<p><a href="http://limboy.me/ios/2015/08/08/advanced-nsoperations.html" target="_blank" rel="external">Advanced NSOperations</a></p>
<p><a href="http://oncenote.com/2015/03/22/Threading-Run-Loop/" target="_blank" rel="external">iOS并发编程（Concurrency Programming）系列</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="简介">简介</h1><h2 id="什么是GCD">什么是GCD</h2><ul>
<li>全程是Grand Central Dispatch，可译为“大中央调度”</li>
<li>纯C语言，提供了非常多强大的函数库</li>
</ul>
<h2 id="GC]]>
    </summary>
    
      <category term="GCD" scheme="http://www.zhuli8.com/tags/GCD/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift学习参考]]></title>
    <link href="http://www.zhuli8.com/2015/06/28/swift%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83/"/>
    <id>http://www.zhuli8.com/2015/06/28/swift学习参考/</id>
    <published>2015-06-28T04:41:20.000Z</published>
    <updated>2015-08-28T03:11:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="官方文档">官方文档</h1><p><a href="https://developer.apple.com/swift/" target="_blank" rel="external">苹果出品，必属精品！</a></p>
<p><a href="https://github.com/zhuli8com/Welcome-to-Swift" target="_blank" rel="external">Welcome-to-Swift</a>（中文版）</p>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/" target="_blank" rel="external">The Swift Programming Language</a></p>
<p><a href="http://www.cocoachina.com/ios/20150701/12328.html" target="_blank" rel="external">没机会参加 WWDC 2015，那你可以看看这10个视频</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="external">swift 2.0</a>(中文版)</p>
<h1 id="精彩博文">精彩博文</h1><p><a href="http://southpeak.github.io/blog/2015/06/30/ioszhi-shi-xiao-ji-di-san-qi-2015-dot-06-dot-30/" target="_blank" rel="external">Tint Color\Build Configurations in Swift\键盘事件</a></p>
<p><a href="http://www.cocoachina.com/swift/20150630/12305.html" target="_blank" rel="external">怎样在Swift中使用CocoaPods</a></p>
<p><a href="http://www.cocoachina.com/swift/20150806/12831.html" target="_blank" rel="external">怎样在swift中创建一个CocoaPods</a></p>
<p><a href="http://www.cocoachina.com/ios/20150629/12298.html" target="_blank" rel="external">使用Xcode HeaderDoc和Doxygen文档化你的Objective-C和Swift代码</a></p>
<p><a href="http://00red.com" target="_blank" rel="external">Swift项目兼容Objective-c问题汇总</a></p>
<p><a href="http://benbeng.leanote.com/post/On-Demand-Resources-Guide" target="_blank" rel="external">按需加载资源开发指南</a></p>
<p><a href="http://www.cocoachina.com/ios/20150617/12165.html" target="_blank" rel="external">10步成为专业iOS开发者——从零起步</a></p>
<p><a href="http://www.cocoachina.com/swift/" target="_blank" rel="external">cocoachina-swift集锦</a></p>
<p><a href="http://www.cocoachina.com/special/xcode/" target="_blank" rel="external">cocoachina-xcode集锦</a></p>
<h1 id="swift函数">swift函数</h1><p><a href="http://swift.gg/2015/08/06/swift-2-flatmap/" target="_blank" rel="external">Swift 2.0: 理解 flatMap</a></p>
<p><a href="http://swift.gg/2015/08/28/swift_when_the_functional_approach_is_not_right/" target="_blank" rel="external">Swift:什么时候不适合使用函数式方法</a></p>
<p><a href="http://www.cocoachina.com/industry/20140619/8885.html" target="_blank" rel="external">Swift中的标准函数</a></p>
<p><a href="http://www.cocoachina.com/swift/20150619/12173.html" target="_blank" rel="external">Swift高阶函数：Map，Filter，Reduce等-Part 1</a></p>
<h1 id="其他">其他</h1><p><a href="http://www.niaogebiji.com/article-6325-1.html" target="_blank" rel="external">App store最新审核标准公布</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="官方文档">官方文档</h1><p><a href="https://developer.apple.com/swift/" target="_blank" rel="external">苹果出品，必属精品！</a></p>
<p><a href="https:/]]>
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="swift" scheme="http://www.zhuli8.com/tags/swift/"/>
    
      <category term="swift" scheme="http://www.zhuli8.com/categories/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift版设计模式之代理模式-Proxy程序替你聊天]]></title>
    <link href="http://www.zhuli8.com/2015/06/21/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy%E7%A8%8B%E5%BA%8F%E6%9B%BF%E4%BD%A0%E8%81%8A%E5%A4%A9/"/>
    <id>http://www.zhuli8.com/2015/06/21/代理模式-Proxy程序替你聊天/</id>
    <published>2015-06-21T09:05:10.000Z</published>
    <updated>2015-07-20T02:17:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="代理模式比喻">代理模式比喻</h1><p>跟MM在网上聊天，她们一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
<h1 id="代理模式意图">代理模式意图</h1><p>代理模式(Proxy)为其他对象提供一种代理以控制对这个对象的访问。</p>
<h1 id="代理模式类图">代理模式类图</h1><p><img src="http://www.zhuli8.com/photos/designpattern/proxy.gif" alt=""></p>
<h1 id="代理模式实现">代理模式实现</h1><p>定义RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Proxy所代表的真实实体</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span>: <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> mm:<span class="type">Girl</span></span><br><span class="line">    <span class="keyword">init</span>(mm:<span class="type">Girl</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.mm=mm</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">operation</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> mm.word!&#123;<span class="comment">//记得强制解包哦</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"hi,你好"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"hi,你好"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"你从哪里来呀？"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"火星"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"你多大了？"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="number">18</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"身高多少呀？"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"2.5m"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            say()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"我出场了……"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存一个RealSubject引用，使得代理可以访问实体并提供一个与Subject相同的接口来代替实体</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>: <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rs:<span class="type">RealSubject</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(mm:<span class="type">Girl</span>)&#123;</span><br><span class="line">        rs=<span class="type">RealSubject</span>(mm: mm)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">operation</span><span class="params">()</span></span> &#123;</span><br><span class="line">        rs.operation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>聊天的MM</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> word:<span class="built_in">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理模式客户端应用</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> mm=<span class="function"><span class="title">Girl</span><span class="params">()</span></span></span><br><span class="line">mm.word=<span class="string">"hi,你好"</span></span><br><span class="line"></span><br><span class="line"><span class="tag">var</span> proxy=<span class="function"><span class="title">Proxy</span><span class="params">(mm: mm)</span></span></span><br><span class="line">proxy.<span class="function"><span class="title">operation</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h1 id="代理模式总结">代理模式总结</h1><p>吼吼，这是不是就是传说中的机器人聊天原理啊！代理模式给某一个对象提供一个代理对象，由代理对象控制对源对象的引用。代理就是一个人或一个结构代表另一个人或者一个机构采取行动。我们身边到处都是代理模式，如远程代理、虚拟代理、安全代理、智能指引等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="代理模式比喻">代理模式比喻</h1><p>跟MM在网上聊天，她们一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷]]>
    </summary>
    
      <category term="swift" scheme="http://www.zhuli8.com/tags/swift/"/>
    
      <category term="设计模式" scheme="http://www.zhuli8.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://www.zhuli8.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift版设计模式之中介者模式-MM们打麻将我来算账]]></title>
    <link href="http://www.zhuli8.com/2015/06/14/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-MM%E4%BB%AC%E6%89%93%E9%BA%BB%E5%B0%86%E6%88%91%E6%9D%A5%E7%AE%97%E8%B4%A6/"/>
    <id>http://www.zhuli8.com/2015/06/14/中介者模式-MM们打麻将我来算账/</id>
    <published>2015-06-14T04:05:10.000Z</published>
    <updated>2015-07-20T02:18:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="中介者模式比喻">中介者模式比喻</h1><p>四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</p>
<h1 id="中介者模式意图">中介者模式意图</h1><p>中介者模式(Mediator)用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<h1 id="中介者模式类图">中介者模式类图</h1><p><img src="http://www.zhuli8.com/photos/designpattern/mediator.gif" alt=""></p>
<h1 id="中介者模式实现">中介者模式实现</h1><p>抽象中介者，定义了MM需要什么样的中介者</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(money:Double,girl:Girl)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体中介者对象，实现抽象类的方法，他需要知道所有具体的MM，并给MM核算服务</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>: <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl1:<span class="type">FirstGirl</span>?</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl2:<span class="type">SecondGirl</span>?</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl3:<span class="type">ThirdGirl</span>?</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl4:<span class="type">FourthGirl</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(<span class="keyword">var</span> money: Double, girl: Girl)</span></span> &#123;</span><br><span class="line">        money=money*<span class="number">10</span><span class="comment">////中介者的处理，此处业务比较简单假设一个筹码代表10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> girl===girl1&#123;</span><br><span class="line">            girl1?.getResult(money)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> girl===girl2&#123;</span><br><span class="line">            girl2?.getResult(money)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> girl===girl3&#123;</span><br><span class="line">            girl3?.getResult(money)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> girl===girl4&#123;</span><br><span class="line">            girl4?.getResult(money)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象女孩类</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mediator:<span class="type">Mediator</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(mediator:<span class="type">Mediator</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.mediator=mediator<span class="comment">////得到中介者对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    告诉中介者筹码数，让其帮我核算</span><br><span class="line">    */</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        mediator.calculate(money, girl: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩1，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识且依靠中介者对象核算</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The FirstGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩2，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识依靠中介者对象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The SecondGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩3，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识依靠中介者对象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The ThirdGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩4，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识依靠中介者对象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourthGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The FourthGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中介者模式客户端应用</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> boy=<span class="function"><span class="title">Boy</span><span class="params">()</span></span><span class="comment">//核算中介</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//四个打麻将的MM</span></span><br><span class="line"><span class="tag">var</span> girl1=<span class="function"><span class="title">FirstGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"><span class="tag">var</span> girl2=<span class="function"><span class="title">SecondGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"><span class="tag">var</span> girl3=<span class="function"><span class="title">ThirdGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"><span class="tag">var</span> girl4=<span class="function"><span class="title">FourthGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//四个MM让我调节</span></span><br><span class="line">boy.girl1=girl1</span><br><span class="line">boy.girl2=girl2</span><br><span class="line">boy.girl3=girl3</span><br><span class="line">boy.girl4=girl4</span><br><span class="line">girl1.<span class="function"><span class="title">notify</span><span class="params">(<span class="number">10</span>)</span></span></span><br><span class="line">girl2.<span class="function"><span class="title">notify</span><span class="params">(<span class="number">20</span>)</span></span></span><br><span class="line">girl3.<span class="function"><span class="title">notify</span><span class="params">(-<span class="number">20</span>)</span></span></span><br><span class="line">girl4.<span class="function"><span class="title">notify</span><span class="params">(-<span class="number">10</span>)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="中介者模式总结">中介者模式总结</h1><p>中介者的出现减少了MM们的耦合，使得可以独立地改变和复用各个Mediator和Girl，具体女孩类的改变不会影响到其他女孩类，而只是Boy发生变化。Boy把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，关注的对象就从对象各自本身的行为转移到她们之间的交互上来。即中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而是它们可以松散耦合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象，保证这些作用可以彼此独立的变化。中介者模式将多对多的相互作用转化为一对多的相互作用。中介者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="中介者模式比喻">中介者模式比喻</h1><p>四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</p>
<h1 id="中介者模式意图">中介]]>
    </summary>
    
      <category term="swift" scheme="http://www.zhuli8.com/tags/swift/"/>
    
      <category term="设计模式" scheme="http://www.zhuli8.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://www.zhuli8.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[@OBJC和DYNAMIC]]></title>
    <link href="http://www.zhuli8.com/2015/06/07/OBJC%E5%92%8CDYNAMIC/"/>
    <id>http://www.zhuli8.com/2015/06/07/OBJC和DYNAMIC/</id>
    <published>2015-06-07T02:44:45.000Z</published>
    <updated>2015-07-20T02:18:42.000Z</updated>
    <content type="html"><![CDATA[<p><div class="post-content clearfix"><br>        <p>虽然说 Swift 语言的初衷是希望能摆脱 Objective-C 的沉重的历史包袱和约束，但是不可否认的是经过了二十多年的洗礼，Cocoa 框架早就烙上了不可磨灭的 Objective-C 的印记。无数的第三方库是用 Objective-C 写成的，这些积累无论是谁都不能小觑。因此，在最初的版本中，Swift 不得不考虑与 Objective-C 的兼容。</p></div></p>
<p>Apple 采取的做法是允许我们在同一个项目中同时使用 Swift 和 Objective-C 来进行开发。其实一个项目中的 Objective-C 文件和 Swift 文件是处于两个不同世界中的，为了让它们能相互联通，我们需要添加一些桥梁。</p><br><p>首先通过添加 <code>{product-module-name}-Bridging-Header.h</code> 文件，并在其中填写想要使用的头文件名称，我们就可以很容易地在 Swift 中使用 Objective-C 代码了。Xcode 为了简化这个设定，甚至在 Swift 项目中第一次导入 Objective-C 文件时会主动弹框进行询问是否要自动创建这个文件，可以说是非常方便。</p><br><p>但是如果想要在 Objective-C 中使用 Swift 的类型的时候，事情就复杂一些。如果是来自外部的框架，那么这个框架与 Objective-C 项目肯定不是处在同一个 target 中的，我们需要对外部的 Swift module 进行导入。这个其实和使用 Objective-C 的原来的 Framework 是一样的，对于一个项目来说，外界框架是由 Swift 写的还是 Objective-C 写的，两者并没有太大区别。我们通过使用 2013 年新引入的 <code>@import</code> 来引入 module：</p><br><pre><code>@import MySwiftKit;<br></code></pre><br><p>之后就可以正常使用这个 Swift 写的框架了。</p><br><p>如果想要在 Objective-C 里使用的是同一个项目中的 Swift 的源文件的话，可以直接导入自动生成的头文件 <code>{product-module-name}-Swift.h</code> 来完成。比如项目的 target 叫做 <code>MyApp</code> 的话，我们就需要在 Objective-C 文件中写</p><br><pre><code>#import “MyApp-Swift.h”<br></code></pre><br><p>但这只是故事的开始。Objective-C 和 Swift 在底层使用的是两套完全不同的机制，Cocoa 中的 Objective-C 对象是基于运行时的，它从骨子里遵循了 KVC (Key-Value Coding，通过类似字典的方式存储对象信息) 以及动态派发 (Dynamic Dispatch，在运行调用时再决定实际调用的具体实现)。而 Swift 为了追求性能，如果没有特殊需要的话，是不会在运行时再来决定这些的。也就是说，Swift 类型的成员或者方法在编译时就已经决定，而运行时便不再需要经过一次查找，而可以直接使用。</p><br><p>显而易见，这带来的问题是如果我们要使用 Objective-C 的代码或者特性来调用纯 Swift 的类型时候，我们会因为找不到所需要的这些运行时信息，而导致失败。解决起来也很简单，在 Swift 类型文件中，我们可以将需要暴露给 Objective-C 使用的任何地方 (包括类，属性和方法等) 的声明前面加上 <code>@objc</code> 修饰符。注意这个步骤只需要对那些不是继承自 <code>NSObject</code> 的类型进行，如果你用 Swift 写的 class 是继承自 <code>NSObject</code> 的话，Swift 会默认自动为所有的非 private 的类和成员加上 <code>@objc</code>。这就是说，对一个 <code>NSObject</code> 的子类，你只需要导入相应的头文件就可以在 Objective-C 里使用这个类了。</p><br><p><code>@objc</code> 修饰符的另一个作用是为 Objective-C 侧重新声明方法或者变量的名字。虽然绝大部分时候自动转换的方法名已经足够好用 (比如会将 Swift 中类似 <code>init(name: String)</code> 的方法转换成 <code>-initWithName:(NSString *)name</code> 这样)，但是有时候我们还是期望 Objective-C 里使用和 Swift 中不一样的方法名或者类的名字，比如 Swift 里这样的一个类：</p><br><pre><code>class 我的类 {<br>    func 打招呼(名字: String) {<br>        println(“哈喽，(名字)”)<br>    }<br>}<br>我的类().打招呼(“小明”)<br></code></pre><br><p>Objective-C 的话是无法使用中文来进行调用的，因此我们<strong>必须</strong>使用 <code>@objc</code> 将其转为 ASCII 才能在 Objective-C 里访问：</p>

<p><pre><code>@objc(MyClass)<br>class 我的类 {<br>    @objc(greeting:)<br>    func 打招呼(名字: String) {<br>        println(“哈喽，(名字)”)<br>    }<br>}<br></code></pre></p>
<p></p><p>这样，我们在 Objective-C 里就能调用 <code>[[MyClass new] greeting:@”XiaoMing”]</code> 这样的代码了 (虽然比起原来一点都不好玩了)。另外，正如上面所说的以及在 <a href="http://swifter.tips/selector/" target="_blank" rel="external">Selector</a> 一节中所提到的，即使是 <code>NSObject</code> 的子类，Swift 也不会在被标记为 <code>private</code> 的方法或成员上自动加 <code>@objc</code>。如果我们需要使用这些内容的动态特性的话，我们需要手动给它们加上 <code>@objc</code> 修饰。</p><p></p>
<p></p><p>添加 <code>@objc</code> 修饰符并不意味着这个方法或者属性会变成动态派发，Swift 依然可能会将其优化为静态调用。如果你需要和 Objective-C 里动态调用时相同的运行时特性的话，你需要使用的修饰符是 <code>dynamic</code>。一般情况下在做 app 开发时应该用不上，但是在施展一些像动态替换方法或者运行时再决定实现这样的 “黑魔法” 的时候，我们就需要用到 <code>dynamic</code> 修饰符了。在之后的 KVO 一节中，我们还会提到一个关于使用 <code>dynamic</code> 的实例。</p><br>    <br>作者王巍 <a href="http://swifter.tips/" target="_blank" rel="external">(@onevcat)</a> 原文地址 <a href="http://swifter.tips/objc-dynamic/" target="_blank" rel="external">http://swifter.tips/objc-dynamic/</a><p></p>
]]></content>
    <summary type="html">
    <![CDATA[swift的@OBJC和DYNAMIC]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="swift" scheme="http://www.zhuli8.com/tags/swift/"/>
    
      <category term="swift" scheme="http://www.zhuli8.com/categories/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[与调试器共舞 - LLDB 的华尔兹]]></title>
    <link href="http://www.zhuli8.com/2015/05/31/%E4%B8%8E%E8%B0%83%E8%AF%95%E5%99%A8%E5%85%B1%E8%88%9E%20-%20LLDB%20%E7%9A%84%E5%8D%8E%E5%B0%94%E5%85%B9/"/>
    <id>http://www.zhuli8.com/2015/05/31/与调试器共舞 - LLDB 的华尔兹/</id>
    <published>2015-05-31T12:40:39.000Z</published>
    <updated>2015-08-20T09:15:47.000Z</updated>
    <content type="html"><![CDATA[<p>你是否曾经苦恼于理解你的代码，而去尝试打印一个变量的值？</p>

<pre><code>NSLog(@"%@", whatIsInsideThisThing);
</code></pre>

<p>或者跳过一个函数调用来简化程序的行为？</p>

<pre><code>NSNumber *n = @7; // 实际应该调用这个函数：Foo();
</code></pre>

<p>或者短路一个逻辑检查？</p>

<pre><code>if (1 || theBooleanAtStake) { ... }
</code></pre>

<p>或者伪造一个函数实现？</p>

<pre><code>int calculateTheTrickyValue {
  return 9;

  /*
   先这么着
   ...
}
</code></pre>

<p>并且每次必须重新编译，从头开始？</p>

<p>构建软件是复杂的，并且 Bug 总会出现。一个常见的修复周期就是修改代码，编译，重新运行，并且祈祷出现最好的结果。</p>

<p>但是不一定要这么做。你可以使用调试器。而且即使你已经知道如何使用调试器检查变量，它可以做的还有很多。</p>

<p>这篇文章将试图挑战你对调试的认知，并详细地解释一些你可能还不了解的基本原理，然后展示一系列有趣的例子。现在就让我们开始与调试器共舞一曲华尔兹，看看最后能达到怎样的高度。</p>

<h2 id="lldb">LLDB</h2>

<p><a href="http://lldb.llvm.org/" target="_blank" rel="external">LLDB</a> 是一个有着 REPL 的特性和 C++ ,Python 插件的<a href="http://lldb.llvm.org/source.html" target="_blank" rel="external">开源</a>调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。(<a href="http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1.html" target="_blank" rel="external">这里</a>有一个关于调试器如何工作的总体的解释。)</p>

<p>你以前有可能已经使用过调试器，即使只是在 Xcode 的界面上加一些断点。但是通过一些小的技巧，你就可以做一些非常酷的事情。<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="external">GDB to LLDB</a> 参考是一个非常好的调试器可用命令的总览。你也可以安装 <a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a>，它是一个开源的 LLDB 插件合辑，这会使调试变得更加有趣。</p>

<p>与此同时，让我们以在调试器中打印变量来开始我们的旅程吧。</p>

<h2 id="">基础</h2>

<p>这里有一个简单的小程序，它会打印一个字符串。注意断点已经被加在第 8 行。断点可以通过点击 Xcode 的源码窗口的侧边槽进行创建。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-20_at_10.01.46_PM.png" width="400"></p>

<p>程序会在这一行停止运行，并且控制台会被打开，允许我们和调试器交互。那我们应该打些什么呢？</p>

<h3 id="_help_"><em>help</em></h3>

<p>最简单命令是 <code>help</code>，它会列举出所有的命令。如果你忘记了一个命令是做什么的，或者想知道更多的话，你可以通过 <code>help &lt;command&gt;</code> 来了解更多细节，例如 <code>help print</code> 或者 <code>help thread</code>。如果你甚至忘记了 <code>help</code> 命令是做什么的，你可以试试 <code>help help</code>。不过你如果知道这么做，那就说明你大概还没有忘光这个命令。😛</p>

<h3 id="_print_"><em>print</em></h3>

<p>打印值很简单；只要试试 <code>print</code> 命令:</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-20_at_10.09.38_PM.png" width="600"></p>

<p>LLDB 实际上会作前缀匹配。所以你也可以使用 <code>prin</code>，<code>pri</code>，或者 <code>p</code>。但你不能使用 <code>pr</code>，因为 LLDB 不能消除和 <code>process</code> 的歧义 (幸运的是 <code>p</code> 并没有歧义)。</p>

<p>你可能还注意到了，结果中有个 <code>$0</code>。实际上你可以使用它来指向这个结果。试试 <code>print $0 + 7</code>，你会看到 <code>106</code>。任何以美元符开头的东西都是存在于 LLDB 的命名空间的，它们是为了帮助你进行调试而存在的。</p>

<h3 id="_expression_"><em>expression</em></h3>

<p>如果想改变一个值怎么办？你或许会猜 <em>modify</em>。其实这时候我们要用到的是 <code>expression</code> 这个方便的命令。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-20_at_10.15.01_PM.png" width="240"></p>

<p>这不仅会改变调试器中的值，实际上它改变了程序中的值。这时候继续执行程序，将会打印 <code>42 red balloons</code>。神奇吧。</p>

<p>注意，从现在开始，我们将会偷懒分别以 <code>p</code> 和 <code>e</code> 来代替 <code>print</code> 和 <code>expression</code>。</p>

<h3 id="_print_">什么是 <em>print</em> 命令</h3>

<p>考虑一个有意思的表达式：<code>p count = 18</code>。如果我们运行这条命令，然后打印 <code>count</code> 的内容。我们将看到它的结果与 <code>expression count = 18</code> 一样。</p>

<p>和 <code>expression</code> 不同的是，<code>print</code> 命令不需要参数。比如 <code>e -h +17</code> 中，你很难区分到底是以 <code>-h</code> 为标识，仅仅执行 <code>+17</code> 呢，还是要计算 <code>17</code> 和 <code>h</code> 的差值。连字符号确实很让人困惑，你或许得不到自己想要的结果。</p>

<p>幸运的是，解决方案很简单。用 <code>—</code> 来表征标识的结束，以及输入的开始。如果想要 <code>-h</code> 作为标识，就用 <code>e -h — +17</code>，如果想计算它们的差值，就使用 <code>e — -h +17</code>。因为一般来说不使用标识的情况比较多，所以 <code>e —</code> 就有了一个简写的方式，那就是 <code>print</code>。</p>

<p>输入 <code>help print</code>，然后向下滚动，你会发现：</p>

<pre><code>'print' is an abbreviation for 'expression --'.   
(print是 `expression --` 的缩写)
</code></pre>

<h3 id="">打印对象</h3>

<p>尝试输入</p>

<pre><code>p objects
</code></pre>

<p>输出会有点啰嗦</p>

<pre><code>(NSString *) $7 = 0x0000000104da4040 @"red balloons"
</code></pre>

<p>如果我们尝试打印结构更复杂的对象，结果甚至会更糟</p>

<pre><code>(lldb) p @[ @"foo", @"bar" ]

(NSArray *) $8 = 0x00007fdb9b71b3e0 @"2 objects" 
</code></pre>

<p>实际上，我们想看的是对象的 <code>description</code> 方法的结果。我么需要使用 <code>-O</code> (字母 O，而不是数字 0) 标志告诉 <code>expression</code> 命令以 <code>对象</code> (Object) 的方式来打印结果。 </p>

<pre><code>(lldb) e -O -- $8
&lt;__NSArrayI 0x7fdb9b71b3e0&gt;(
foo,
bar
)
</code></pre>

<p>幸运的是，<code>e -o —</code> 有也有个别名，那就是 <code>po</code> (<strong>p</strong>rint <strong>o</strong>bject 的缩写)，我们可以使用它来进行简化：</p>

<pre><code>(lldb) po $8
&lt;__NSArrayI 0x7fdb9b71b3e0&gt;(
foo,
bar
)
(lldb) po @"lunar"
lunar
(lldb) p @"lunar"
(NSString *) $13 = 0x00007fdb9d0003b0 @"lunar"
</code></pre>

<h3 id="">打印变量</h3>

<p>可以给 <code>print</code> 指定不同的打印格式。它们都是以 <code>print/&lt;fmt&gt;</code> 或者简化的 <code>p/&lt;fmt&gt;</code> 格式书写。下面是一些例子：</p>

<p>默认的格式</p>

<pre><code>(lldb) p 16
16
</code></pre>

<p>十六进制:</p>

<pre><code>(lldb) p/x 16
0x10
</code></pre>

<p>二进制 (<code>t</code> 代表 <strong>t</strong>wo)：</p>

<pre><code>(lldb) p/t 16
0b00000000000000000000000000010000
(lldb) p/t (char)16
0b00010000
</code></pre>

<p>你也可以使用 <code>p/c</code> 打印字符，或者 <code>p/s</code> 打印以空终止的字符串 (译者注：以 ‘\0’ 结尾的字符串)。 <br><br><a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="external">这里</a>是格式的完整清单。</p>

<h3 id="">变量</h3>

<p>现在你已经可以打印对象和简单类型，并且知道如何使用 <code>expression</code> 命令在调试器中修改它们了。现在让我们使用一些变量来减少输入量。就像你可以在 C 语言中用 <code>int a = 0</code> 来声明一个变量一样，你也可以在 LLDB 中做同样的事情。不过为了能使用声明的变量，变量<strong>必须</strong>以美元符开头。</p>

<pre><code>(lldb) e int $a = 2
(lldb) p $a * 19
38
(lldb) e NSArray *$array = @[ @"Saturday", @"Sunday", @"Monday" ]
(lldb) p [$array count]
2
(lldb) po [[$array objectAtIndex:0] uppercaseString]
SATURDAY
(lldb) p [[$array objectAtIndex:$a] characterAtIndex:0]
error: no known method '-characterAtIndex:'; cast the message send to the method's return type
error: 1 errors parsing expression
</code></pre>

<p>悲剧了，LLDB 无法确定涉及的类型 (译者注：返回的类型)。这种事情常常发生，给个说明就好了：</p>

<pre><code>(lldb) p (char)[[$array objectAtIndex:$a] characterAtIndex:0]
'M'
(lldb) p/d (char)[[$array objectAtIndex:$a] characterAtIndex:0]
77
</code></pre>

<p>变量使调试器变的容易使用得多，想不到吧？😉</p>

<h3 id="">流程控制</h3>

<p>当你通过 Xcode 的源码编辑器的侧边槽 (或者通过下面的方法) 插入一个断点，程序到达断点时会就会停止运行。</p>

<p>调试条上会出现四个你可以用来控制程序的执行流程的按钮。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_10.37.45_AM.png" width="200"></p>

<p>从左到右，四个按钮分别是：continue，step over，step into，step out。</p>

<p>第一个，continue 按钮，会取消程序的暂停，允许程序正常执行 (要么一直执行下去，要么到达下一个断点)。在 LLDB 中，你可以使用 <code>process continue</code> 命令来达到同样的效果，它的别名为 <code>continue</code>，或者也可以缩写为 <code>c</code>。</p>

<p>第二个，step over 按钮，会以黑盒的方式执行一行代码。如果所在这行代码是一个函数调用，那么就<strong>不会</strong>跳进这个函数，而是会执行这个函数，然后继续。LLDB 则可以使用 <code>thread step-over</code>，<code>next</code>，或者 <code>n</code> 命令。</p>

<p>如果你确实想跳进一个函数调用来调试或者检查程序的执行情况，那就用第三个按钮，step in，或者在LLDB中使用 <code>thread step in</code>，<code>step</code>，或者 <code>s</code> 命令。注意，当前行不是函数调用时，<code>next</code> 和 <code>step</code> 效果是一样的。</p>

<p>大多数人知道 <code>c</code>，<code>n</code> 和 <code>s</code>，但是其实还有第四个按钮，step out。如果你曾经不小心跳进一个函数，但实际上你想跳过它，常见的反应是重复的运行 <code>n</code> 直到函数返回。其实这种情况，step out 按钮是你的救世主。它会继续执行到下一个返回语句 (直到一个堆栈帧结束) 然后再次停止。</p>

<h4 id="">例子</h4>

<p>考虑下面一段程序：</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_10.53.52_AM.png" width="320"></p>

<p>假如我们运行程序，让它停止在断点，然后执行下面一些列命令：</p>

<pre><code>p i
n
s
p i
finish
p i
frame info
</code></pre>

<p>这里，<code>frame info</code> 会告诉你当前的行数和源码文件，以及其他一些信息；查看 <code>help frame</code>，<code>help thread</code> 和 <code>help process</code> 来获得更多信息。这一串命令的结果会是什么？看答案之前请先想一想。</p>

<pre><code>(lldb) p i
(int) $0 = 99
(lldb) n
2014-11-22 10:49:26.445 DebuggerDance[60182:4832768] 101 is odd!
(lldb) s
(lldb) p i
(int) $2 = 110
(lldb) finish
2014-11-22 10:49:35.978 DebuggerDance[60182:4832768] 110 is even!
(lldb) p i
(int) $4 = 99
(lldb) frame info
frame #0: 0x000000010a53bcd4 DebuggerDance`main + 68 at main.m:17
</code></pre>

<p>它始终在 17 行的原因是 <code>finish</code> 命令一直运行到 <code>isEven()</code> 函数的 <code>return</code>，然后立刻停止。注意即使它还在 17 行，其实这行已经被执行过了。</p>

<h4 id="threadreturn">Thread Return</h4>

<p>调试时，还有一个很棒的函数可以用来控制程序流程：<code>thread return</code> 。它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后立刻执行返回命令，跳出当前栈帧。这意味这函数剩余的部分<strong>不会被执行</strong>。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是在函数的开头执行这个命令，是个非常好的隔离这个函数，伪造返回值的方式 。</p>

<p>让我们稍微修改一下上面代码段并运行：</p>

<pre><code>p i
s
thread return NO
n
p even0
frame info
</code></pre>

<p>看答案前思考一下。下面是答案：</p>

<pre><code>(lldb) p i
(int) $0 = 99
(lldb) s
(lldb) thread return NO
(lldb) n
(lldb) p even0
(BOOL) $2 = NO
(lldb) frame info
frame #0: 0x00000001009a5cc4 DebuggerDance`main + 52 at main.m:17
</code></pre>

<h2 id="">断点</h2>

<p>我们都把断点作为一个停止程序运行，检查当前状态，追踪 bug 的方式。但是如果我们改变和断点交互的方式，很多事情都变成可能。</p>

<blockquote><br>  <p>断点允许控制程序什么时候停止，然后允许命令的运行。</p><br></blockquote>

<p>想象把断点放在函数的开头，然后用 <code>thread return</code> 命令重写函数的行为，然后继续。想象一下让这个过程自动化，听起来不错，不是吗？</p>

<h3 id="">管理断点</h3>

<p>Xcode 提供了一系列工具来创建和管理断点。我们会一个个看过来并介绍 LLDB 中等价的命令 (是的，你可以在调试器<strong>内部</strong>添加断点)。</p>

<p>在 Xcode 的左侧面板，有一组按钮。其中一个看起来像断点。点击它打开断点导航，这是一个可以快速管理所有断点的面板。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_11.38.24_AM.png" width="620"></p>

<p>在这里你可以看到所有的断点 - 在 LLDB 中通过 <code>breakpoint list</code> (或者 <code>br li</code>) 命令也做同样的事儿。你也可以点击单个断点来开启或关闭 - 在 LLDB 中使用 <code>breakpoint enable &lt;breakpointID&gt;</code> 和 <code>breakpoint disable &lt;breakpointID&gt;</code>：</p>

<pre><code>(lldb) br li
Current breakpoints:
1: file = '/Users/arig/Desktop/DebuggerDance/DebuggerDance/main.m', line = 16, locations = 1, resolved = 1, hit count = 1

  1.1: where = DebuggerDance`main + 27 at main.m:16, address = 0x000000010a3f6cab, resolved, hit count = 1

(lldb) br dis 1
1 breakpoints disabled.
(lldb) br li
Current breakpoints:
1: file = '/Users/arig/Desktop/DebuggerDance/DebuggerDance/main.m', line = 16, locations = 1 Options: disabled

  1.1: where = DebuggerDance`main + 27 at main.m:16, address = 0x000000010a3f6cab, unresolved, hit count = 1

(lldb) br del 1
1 breakpoints deleted; 0 breakpoint locations disabled.
(lldb) br li
No breakpoints currently set.
</code></pre>

<h3 id="">创建断点</h3>

<p>在上面的例子中，我们通过在源码页面器的滚槽 <code>16</code> 上点击来创建断点。你可以通过把断点拖拽出滚槽，然后释放鼠标来删除断点 (消失时会有一个非常可爱的噗的一下的动画)。你也可以在断点导航页选择断点，然后按下删除键删除。</p>

<p>要在调试器中创建断点，可以使用 <code>breakpoint set</code> 命令。</p>

<pre><code>(lldb) breakpoint set -f main.m -l 16
Breakpoint 1: where = DebuggerDance`main + 27 at main.m:16, address = 0x000000010a3f6cab
</code></pre>

<p>也可以使用缩写形式 <code>br</code>。虽然 <code>b</code> 是一个完全不同的命令 (<code>_regexp-break</code> 的缩写)，但恰好也可以实现和上面同样的效果。</p>

<pre><code>(lldb) b main.m:17
Breakpoint 2: where = DebuggerDance`main + 52 at main.m:17, address = 0x000000010a3f6cc4
</code></pre>

<p>也可以在一个符号 (C 语言函数) 上创建断点，而完全不用指定哪一行 </p>

<pre><code>(lldb) b isEven
Breakpoint 3: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x000000010a3f6d00
(lldb) br s -F isEven
Breakpoint 4: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x000000010a3f6d00
</code></pre>

<p>这些断点会准确的停止在函数的开始。Objective-C 的方法也完全可以：</p>

<pre><code>(lldb) breakpoint set -F "-[NSArray objectAtIndex:]"
Breakpoint 5: where = CoreFoundation`-[NSArray objectAtIndex:], address = 0x000000010ac7a950
(lldb) b -[NSArray objectAtIndex:]
Breakpoint 6: where = CoreFoundation`-[NSArray objectAtIndex:], address = 0x000000010ac7a950
(lldb) breakpoint set -F "+[NSSet setWithObject:]"
Breakpoint 7: where = CoreFoundation`+[NSSet setWithObject:], address = 0x000000010abd3820
(lldb) b +[NSSet setWithObject:]
Breakpoint 8: where = CoreFoundation`+[NSSet setWithObject:], address = 0x000000010abd3820
</code></pre>

<p>如果想在 Xcode 的UI上创建符号断点，你可以点击断点栏左侧的 <code>+</code> 按钮。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_11.52.50_AM.png" width="300"></p>

<p>然后选择第三个选项：</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_11.54.44_AM.png" width="430"></p>

<p>这时会出现一个弹出框，你可以在里面添加例如 <code>-[NSArray objectAtIndex:]</code> 这样的符号断点。这样<strong>每次</strong>调用这个函数的时候，程序都会停止，不管是你调用还是苹果调用。</p>

<p>如果你 Xcode 的 UI 上右击<strong>任意</strong>断点，然后选择 “Edit Breakpoint” 的话，会有一些非常诱人的选择。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_11.58.06_AM.png" width="570"></p>

<p>这里，断点已经被修改为<strong>只有</strong>当 <code>i</code> 是 <code>99</code> 的时候才会停止。你也可以使用 “ignore” 选项来告诉断点最初的 <code>n</code> 次调用 (并且条件为真的时候) 的时候不要停止。</p>

<p>接下来介绍 ‘Add Action’ 按钮…</p>

<h3 id="action">断点行为 (Action)</h3>

<p>上面的例子中，你或许想知道每一次到达断点的时候 <code>i</code> 的值。我们可以使用 <code>p i</code> 作为断点行为。这样每次到达断点的时候，都会自动运行这个命令。</p>

<p><img src="http://img.objccn.io/issue-19/Screen_Shot_2014-11-22_at_12.01.32_PM.png" width="600"></p>

<p>你也可以添加多个行为，可以是调试器命令，shell 命令，也可以是更直接的打印：</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_12.06.34_PM.png" width="400"></p>

<p>可以看到它打印 <code>i</code>，然后大声念出那个句子，接着打印了自定义的表达式。</p>

<p>下面是在 LLDB 而不是 Xcode 的 UI 中做这些的时候，看起来的样子。</p>

<pre><code>(lldb) breakpoint set -F isEven
Breakpoint 1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00
(lldb) breakpoint modify -c 'i == 99' 1
(lldb) breakpoint command add 1
Enter your debugger command(s).  Type 'DONE' to end.
&gt; p i
&gt; DONE
(lldb) br li 1
1: name = 'isEven', locations = 1, resolved = 1, hit count = 0
    Breakpoint commands:
      p i

Condition: i == 99

  1.1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00, resolved, hit count = 0 
</code></pre>

<p>接下来说说自动化。</p>

<h3 id="">赋值后继续运行</h3>

<p>看编辑断点弹出窗口的底部，你还会看到一个选项： <em>“Automatically continue after evaluation actions.”</em> 。它仅仅是一个选择框，但是却很强大。选中它，调试器会运行你所有的命令，然后继续运行。看起来就像没有执行任何断点一样 (除非断点太多，运行需要一段时间，拖慢了你的程序)。</p>

<p>这个选项框的效果和让最后断点的最后一个行为是 <code>continue</code> 一样。选框只是让这个操作变得更简单。调试器的输出是：</p>

<pre><code>(lldb) breakpoint set -F isEven
Breakpoint 1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00
(lldb) breakpoint command add 1
Enter your debugger command(s).  Type 'DONE' to end.
&gt; continue
&gt; DONE
(lldb) br li 1
1: name = 'isEven', locations = 1, resolved = 1, hit count = 0
    Breakpoint commands:
      continue

  1.1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00, resolved, hit count = 0
</code></pre>

<p>执行断点后自动继续运行，允许你完全通过断点来修改程序！你可以在某一行停止，运行一个 <code>expression</code> 命令来改变变量，然后继续运行。</p>

<h4 id="">例子</h4>

<p>想想所谓的”打印调试”技术吧，不要这么做：</p>

<pre><code>NSLog(@"%@", whatIsInsideThisThing);
</code></pre>

<p>而是用个打印变量的断点替换 log 语句，然后继续运行。</p>

<p>也不要：</p>

<pre><code>int calculateTheTrickyValue {
  return 9;

  /*
   Figure this out later.
   ...
}
</code></pre>

<p>而是加一个使用 <code>thread return 9</code> 命令的断点，然后让它继续运行。</p>

<p>符号断点加上 action 真的很强大。你也可以在你朋友的 Xcode 工程上添加一些断点，并且加上大声朗读某些东西的 action。看看他们要花多久才能弄明白发生了什么。😄</p>

<h3 id="">完全在调试器内运行</h3>

<p>在开始舞蹈之前，还有一件事要看一看。实际上你可以在调试器中执行任何 C/Objective-C/C++/Swift 的命令。唯一的缺点就是不能创建新函数… 这意味着不能创建新的类，block，函数，有虚拟函数的 C++ 类等等。除此之外，它都可以做。</p>

<p>我们可以申请分配一些字节：</p>

<pre><code>(lldb) e char *$str = (char *)malloc(8)
(lldb) e (void)strcpy($str, "munkeys")
(lldb) e $str[1] = 'o'
(char) $0 = 'o'
(lldb) p $str
(char *) $str = 0x00007fd04a900040 "monkeys"
</code></pre>

<p>我们可以查看内存 (使用 <code>x</code> 命令)，来看看新数组中的四个字节：</p>

<pre><code>(lldb) x/4c $str
0x7fd04a900040: monk
</code></pre>

<p>我们也可以去掉 3 个字节 (<code>x</code> 命令需要斜引号，因为它只有一个内存地址的参数，而不是表达式；使用 <code>help x</code> 来获得更多信息)：</p>

<pre><code>(lldb) x/1w `$str + 3`
0x7fd04a900043: keys
</code></pre>

<p>做完了之后，一定不要忘了释放内存，这样才不会内存泄露。(哈，虽然这是调试器用到的内存)：</p>

<pre><code>(lldb) e (void)free($str)
</code></pre>

<h2 id="">让我们起舞</h2>

<p>现在我们已经知道基本的步调了，是时候开始跳舞并玩一些疯狂的事情了。我曾经写过一篇 <a href="http://arigrant.com/blog/2014/1/19/adventures-in-the-land-of-nsarray" target="_blank" rel="external"><code>NSArray</code> 深度探究</a>的博客。这篇博客用了很多 <code>NSLog</code> 语句，但实际上我的所有探索都是在调试器中完成的。看看你能不能弄明白怎么做的，这会是一个有意思的练习。</p>

<h3 id="">不用断点调试</h3>

<p>程序运行时，Xcode 的调试条上会出现暂停按钮，而不是继续按钮：</p>

<p><img src="http://img.objccn.io/issue-19/Screen_Shot_2014_11_22_at_1_50_56_PM.png" width="300"></p>

<p>点击按钮会暂停 app (这会运行 <code>process interrupt</code> 命令，因为 LLDB 总是在背后运行)。这会让你可以访问调试器，但看起来可以做的事情不多，因为在当前作用域没有变量，也没有特定的代码让你看。</p>

<p>这就是有意思的地方。如果你正在运行 iOS app，你可以试试这个： (因为全局变量是可访问的)</p>

<pre><code>    (lldb) po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]
&lt;UIWindow: 0x7f82b1fa8140; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x7f82b1fa92d0&gt;; layer = &lt;UIWindowLayer: 0x7f82b1fa8400&gt;&gt;
   | &lt;UIView: 0x7f82b1d01fd0; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x7f82b1e2e0a0&gt;&gt;
</code></pre>

<p>你可以看到整个层次。<a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 中 <code>pviews</code> 就是这么实现的。</p>

<h3 id="ui">更新UI</h3>

<p>有了上面的输出，我们可以获取这个 view：</p>

<pre><code>(lldb) e id $myView = (id)0x7f82b1d01fd0
</code></pre>

<p>然后在调试器中改变它的背景色：</p>

<pre><code>(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]]
</code></pre>

<p>但是只有程序继续运行之后才会看到界面的变化。因为改变的内容必须被发送到渲染服务中，然后显示才会被更新。</p>

<p>渲染服务实际上是一个另外的进程 (被称作 <code>backboardd</code>)。这就是说即使我们正在调试的内容所在的进程被打断了，<code>backboardd</code> 也还是继续运行着的。</p>

<p>这意味着你可以运行下面的命令，而不用继续运行程序：</p>

<pre><code>(lldb) e (void)[CATransaction flush]
</code></pre>

<p>即使你仍然在调试器中，UI 也会在模拟器或者真机上实时更新。<a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 为此提供了一个别名叫做 <code>caflush</code>，这个命令被用来实现其他的快捷命令，例如 <code>hide &lt;view&gt;</code>，<code>show &lt;view&gt;</code> 以及其他很多命令。所有 <a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 的命令都有文档，所以安装后随意运行 <code>help show</code> 来看更多信息。</p>

<h3 id="pushviewcontroller">Push 一个 View Controller</h3>

<p>想象一个以 <code>UINavigationController</code> 为 root ViewController 的应用。你可以通过下面的命令，轻松地获取它：</p>

<pre><code>(lldb) e id $nvc = [[[UIApplication sharedApplication] keyWindow] rootViewController]
</code></pre>

<p>然后 push 一个 child view controller:</p>

<pre><code>(lldb) e id $vc = [UIViewController new]
(lldb) e (void)[[$vc view] setBackgroundColor:[UIColor yellowColor]]
(lldb) e (void)[$vc setTitle:@"Yay!"]
(lldb) e (void)[$nvc pushViewContoller:$vc animated:YES]
</code></pre>

<p>最后运行下面的命令：</p>

<pre><code>(lldb) caflush // e (void)[CATransaction flush]
</code></pre>

<p>navigation Controller 就会立刻就被 push 到你眼前。</p>

<h3 id="target">查找按钮的 target</h3>

<p>想象你在调试器中有一个 <code>$myButton</code> 的变量，可以是创建出来的，也可以是从 UI 上抓取出来的，或者是你停止在断点时的一个局部变量。你想知道，按钮按下的时候谁会接收到按钮发出的 action。非常简单：</p>

<pre><code>(lldb) po [$myButton allTargets]
{(
    &lt;MagicEventListener: 0x7fb58bd2e240&gt;
)}
(lldb) po [$myButton actionsForTarget:(id)0x7fb58bd2e240 forControlEvent:0]
&lt;__NSArrayM 0x7fb58bd2aa40&gt;(
_handleTap:
)
</code></pre>

<p>现在你或许想在它发生的时候加一个断点。在 <code>-[MagicEventListener _handleTap:]</code> 设置一个符号断点就可以了，在 Xcode 和 LLDB 中都可以，然后你就可以点击按钮并停在你所希望的地方了。</p>

<h3 id="">观察实例变量的变化</h3>

<p>假设你有一个 <code>UIView</code>，不知道为什么它的 <code>_layer</code> 实例变量被重写了 (糟糕)。因为有可能并不涉及到方法，我们不能使用符号断点。相反的，我们想<strong>监视</strong>什么时候这个地址被写入。</p>

<p>首先，我们需要找到 <code>_layer</code> 这个变量在对象上的相对位置：</p>

<pre><code>(lldb) p (ptrdiff_t)ivar_getOffset((struct Ivar *)class_getInstanceVariable([MyView class], "_layer"))
(ptrdiff_t) $0 = 8
</code></pre>

<p>现在我们知道 <code>($myView + 8)</code> 是被写入的内存地址：</p>

<pre><code>(lldb) watchpoint set expression -- (int *)$myView + 8
Watchpoint created: Watchpoint 3: addr = 0x7fa554231340 size = 8 state = enabled type = w
    new value: 0x0000000000000000
</code></pre>

<p>这被以 <code>wivar $myView _layer</code> 加入到 <a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 中。</p>

<h3 id="">非重写方法的符号断点</h3>

<p>假设你想知道 <code>-[MyViewController viewDidAppear:]</code> 什么时候被调用。如果这个方法并没有在<code>MyViewController</code> 中实现，而是在其父类中实现的，该怎么办呢？试着设置一个断点，会出现以下结果：</p>

<pre><code>(lldb) b -[MyViewController viewDidAppear:]
Breakpoint 1: no locations (pending).
WARNING:  Unable to resolve breakpoint to any actual locations.
</code></pre>

<p>因为 LLDB 会查找一个<strong>符号</strong>，但是实际在这个类上却找不到，所以断点也永远不会触发。你需要做的是为断点设置一个条件 <code>[self isKindOfClass:[MyViewController class]]</code>，然后把断点放在 <code>UIViewController</code> 上。正常情况下这样设置一个条件可以正常工作。但是这里不会，因为我们没有父类的实现。</p>

<p><code>viewDidAppear:</code> 是苹果实现的方法，因此没有它的符号；在方法内没有 <code>self</code> 。如果想在符号断点上使用 <code>self</code>，你必须知道它在哪里 (它可能在寄存器上，也可能在栈上；在 x86 上，你可以在 <code>$esp+4</code> 找到它)。但是这是很痛苦的，因为现在你必须至少知道四种体系结构 (x86，x86-64，armv7，armv64)。想象你需要花多少时间去学习命令集以及它们每一个的<a href="http://en.m.wikipedia.org/wiki/Calling_convention" target="_blank" rel="external">调用约定</a>，然后正确的写一个在你的超类上设置断点并且条件正确的命令。幸运的是，这个在 <a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 被解决了。这被成为 <code>bmessage</code>：</p>

<pre><code>(lldb) bmessage -[MyViewController viewDidAppear:]
Setting a breakpoint at -[UIViewController viewDidAppear:] with condition (void*)object_getClass((id)$rdi) == 0x000000010e2f4d28
Breakpoint 1: where = UIKit`-[UIViewController viewDidAppear:], address = 0x000000010e11533c
</code></pre>

<h3 id="lldbpython">LLDB 和 Python</h3>

<p>LLDB 有内建的，完整的 <a href="http://lldb.llvm.org/python-reference.html" target="_blank" rel="external">Python</a> 支持。在LLDB中输入 <code>script</code>，会打开一个 Python REPL。你也可以输入一行 python 语句作为 <code>script 命令</code> 的参数，这可以运行 python 语句而不进入REPL：</p>

<pre><code>(lldb) script import os
(lldb) script os.system("open http://www.objc.io/")
</code></pre>

<p>这样就允许你创造各种酷的命令。把下面的语句放到文件 <code>~/myCommands.py</code> 中：</p>

<pre><code>def caflushCommand(debugger, command, result, internal_dict):
  debugger.HandleCommand("e (void)[CATransaction flush]")
</code></pre>

<p>然后再 LLDB 中运行：</p>

<pre><code>command script import ~/myCommands.py
</code></pre>

<p>或者把这行命令放在 <code>/.lldbinit</code> 里，这样每次进入 LLDB 时都会自动运行。<a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 其实就是一个 Python 脚本的集合，这些脚本拼接 (命令) 字符串 ，然后让 LLDB 执行。很简单，不是吗？</p>

<h2 id="">紧握调试器这一武器</h2>

<p>LLDB 可以做的事情很多。大多数人习惯于使用 <code>p</code>，<code>po</code>，<code>n</code>，<code>s</code> 和 <code>c</code>，但实际上除此之外，LLDB 可以做的还有很多。掌握所有的命令 (实际上并不是很多)，会让你在揭示代码运行时的运行状态，寻找 bug，强制执行特定的运行路径时获得更大的能力。你甚至可以构建简单的交互原型 - 比如要是现在以 modal 方式弹出一个 View Controller 会怎么样？使用调试器，一试便知。</p>

<p>这篇文章是为了想你展示 LLDB 的强大之处，并且鼓励你多去探索在控制台输入命令。</p>

<p>打开 LLDB，输入 <code>help</code>，看一看列举的命令。你尝试过多少？用了多少？</p>

<p>但愿 <code>NSLog</code> 看起来不再那么吸引你去用，每次编辑再运行并不有趣而且耗时。</p>

<p>调试愉快！</p>

<h1 id="各种补">各种补</h1><h2 id="编辑断点窗口中Action相关参数说明"><a href="http://supermao.cn/duan-dian-shen-ru-liao-jie/" target="_blank" rel="external">编辑断点窗口中Action相关参数说明</a></h2><h3 id="Log_Message">Log Message</h3><p>%B：打印断点的名字</p>
<p>%H：打印断点的调用次数</p>
<p>@exp@：输出表达式</p>
<h3 id="Debugger_Command">Debugger Command</h3><p>po：打印对象信息</p>
<p>bt：打印函数栈</p>
<p>expression：表达式</p>
<h2 id="异常断点的作用">异常断点的作用</h2><p>数组越界访问时程序运行崩溃，但是崩溃停在了main函数里面，就算看了栈信息也不能马上定位到到底是那个数组越界访问了。为什么崩溃不能停在数组越界哪里？这是因为数组越界访问不一定会导致程序崩溃的，数组越界访问会导致异常抛出，而抛出的异常没有得到处理才会导致程序崩溃。因此最后会导致崩溃停在CoreFoundation框架里面。这个时候就需要设置Exception Breakpoint产生断点来定位错误了。</p>
<h2 id="打印View_Controller_Hierarchy">打印View Controller Hierarchy</h2><p>_printHierarchy是 UIViewController 的一个私有方法，你可以用它将view controller 层次打印到控制台。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">po <span class="comment">[<span class="comment">[<span class="comment">[<span class="comment">[UIApplication sharedApplication]</span> keyWindow]</span> rootViewController]</span> _printHierarchy]</span></span><br></pre></td></tr></table></figure>
<h1 id="来源:objcio-cn">来源:<a href="http://objccn.io/issue-19-2/" target="_blank" rel="external">objcio.cn</a></h1>]]></content>
    <summary type="html">
    <![CDATA[与调试器共舞 - LLDB 的华尔兹]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="调试" scheme="http://www.zhuli8.com/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS应用数据存储的常用方式]]></title>
    <link href="http://www.zhuli8.com/2015/05/24/iOS%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.zhuli8.com/2015/05/24/iOS应用数据存储的常用方式/</id>
    <published>2015-05-24T04:40:39.000Z</published>
    <updated>2015-07-20T02:19:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="应用沙盒">应用沙盒</h1><pre><code>iOS应用数据一般存储于应用沙盒，每个iOS应用都有自己的应用沙盒（应用沙盒就是文件系统目录），与其他文件系统隔离。应用必须待在自己的沙盒里，其他应用不能访问该沙盒。
</code></pre><p>应用沙盒的文件系统目录如下图所示：</p>
<p><img src="http://www.zhuli8.com/photos/沙盒目录结构.png" alt=""></p>
<p>模拟器应用沙盒的根路径在：</p>
<p><code>/Users/用户名/Library/Developer/CoreSimulator/Devices/模拟器UDID/data/Containers/Data/Application/对应应用程序文件夹</code></p>
<h2 id="应用沙盒结构分析">应用沙盒结构分析</h2><h3 id="Documents">Documents</h3><p>保存应用运行时生成的 <strong>需要持久化的数据</strong> ，iTunes同步设备时会 <strong>会备份</strong> 该目录。例如，游戏应用可将游戏存档保存在该目录。</p>
<h3 id="Library/Caches">Library/Caches</h3><p>保存应用运行时生成的 <strong>需要持久化的数据</strong> ，iTunes同步设备时 <strong>不会备份</strong> 该目录。一般存储体积大、不需要备份的非重要数据。</p>
<h3 id="Library/Preference">Library/Preference</h3><p>保存应用的所有 <strong>偏好设置</strong> ，iOS的Settings（设置）应用会在该目录中查找应用的设置信息。iTunes同步设备时 <strong>会备份</strong> 该目录。</p>
<h3 id="temp">temp</h3><p>保存应用运行时所需的 <strong>临时文件</strong> ，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时 <strong>不会备份</strong> 该目录。</p>
<h2 id="应用沙盒目录的常见获取方式">应用沙盒目录的常见获取方式</h2><h3 id="沙盒根目录">沙盒根目录</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *home=<span class="built_in">NSHomeDirectory</span>();</span><br></pre></td></tr></table></figure>
<h3 id="Documnets">Documnets</h3><p><strong>利用NSSearchPathForDirectoriesInDomains函数</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br></pre></td></tr></table></figure>
<p><strong>利用NSFileManager的URLsForDirectory:inDomains:函数</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *path=[[[<span class="built_in">NSFileManager</span> defaultManager] URLsForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomains:<span class="built_in">NSUserDomainMask</span>] lastObject];</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong></p>
<p>在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素。</p>
<blockquote>
<p>NSUserDomainMask 代表从用户文件夹下找</p>
<p>YES 代表展开路径中的波浪线字符“~”</p>
</blockquote>
<h3 id="Library/Caches-1">Library/Caches</h3><p><strong>利用NSSearchPathForDirectoriesInDomains函数</strong></p>
<p><strong>利用NSFileManager的URLsForDirectory:inDomains:函数</strong></p>
<blockquote>
<p>将函数的第1个参数改为：NSCachesDirectory即可</p>
</blockquote>
<h3 id="Library/Preference-1">Library/Preference</h3><p><strong>通过过 NSUserDefaults 类存取该目录下的设置信息</strong></p>
<h3 id="temp-1">temp</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=<span class="built_in">NSTemporaryDirectory</span>();</span><br></pre></td></tr></table></figure>
<h1 id="XML属性列表（plist）归档">XML属性列表（plist）归档</h1><p>属性列表是一种XML格式的文件，拓展名为plist。<br>如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，就可以使用这些对象的writeToFile:atomically:方法直接将对象写到属性列表文件中。</p>
<blockquote>
<p>所谓归档，是一个过程，即用某种格式来保存一个或者多个对象以便以后还原这些对象。</p>
</blockquote>
<h2 id="归档NSDictionary">归档NSDictionary</h2><p>将一个NSDictionary对象归档到一个plist属性列表中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=[[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"info.plist"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将数据封装成字典</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *dict=[<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">[dict setValue:<span class="string">@"朱利"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">[dict setValue:<span class="string">@"http://www.zhuli8.com"</span> forKey:<span class="string">@"site"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将字典持久化到Docums/info.plist文件中</span></span><br><span class="line">[dict writeToFile:path atomically:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<h2 id="恢复NSDictionary">恢复NSDictionary</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=[[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"info.plist"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//读取Documents/info.plist的内容，实例化NSDictionary。</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict=[<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:path];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSString</span> *name=[dict objectForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *site=[dict objectForKey:<span class="string">@"site"</span>];</span><br></pre></td></tr></table></figure>
<h1 id="Preference（偏好设置）">Preference（偏好设置）</h1><p>很多iOS应用都支持偏好设置，比如保存用户名、是否自动登录、字体大小等设置，iOS提供了一套标准的解决方案来为应用程序加入偏好设置功能。每个应用都有个 <strong>NSUserDefaults</strong> 实例，通过它来存取偏好设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *defaults= [NSUserDefaults standardUserDefaults];</span><br><span class="line">[defaults <span class="built_in">set</span>Object:@<span class="string">"朱利"</span> <span class="keyword">for</span>Key:@<span class="string">"name"</span>];</span><br><span class="line">[defaults <span class="built_in">set</span>Float:<span class="number">18</span> <span class="keyword">for</span>Key:@<span class="string">"fontSize"</span>];</span><br><span class="line">[defaults <span class="built_in">set</span>Bool:YES <span class="keyword">for</span>Key:@<span class="string">"autoLogin"</span>];</span><br><span class="line">    </span><br><span class="line">[defaults synchronize];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
</blockquote>
<p><strong>NSUserDefauts设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。出现以上问题，可以通过调用synchronize方法强制写入。</strong></p>
<p>读取上次保存的偏好设置</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *defaults= [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSString</span> *name=[defaults objectForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="keyword">float</span> fontSize=[defaults floatForKey:<span class="string">@"fontSize"</span>];</span><br><span class="line"><span class="built_in">BOOL</span> autoLogin=[defaults boolForKey:<span class="string">@"autoLogin"</span>];</span><br></pre></td></tr></table></figure>
<h1 id="NSKeyedArchiver归档（NSCoding）">NSKeyedArchiver归档（NSCoding）</h1><p>如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用NSKeyedArchiver进行归档和恢复，不是所有的对象都可以直接用这种方法进行归档，只有遵守了NSCoding协议的对象才可以。</p>
<h2 id="NSCoding协议的2个方法">NSCoding协议的2个方法</h2><h3 id="initWithCoder">initWithCoder</h3><p>每次从文件中恢复（解码）对象时都会调用这个方法，一般在这个方法里面指定如何解码文件中的数据为对象的实例变量，可以使用 <strong>decodeObject:forKey:</strong>方法解码实例变量。</p>
<h3 id="encodeWithCoder">encodeWithCoder</h3><p>每次归档对象时，都会调用这个方法，一般这个方法里面指定如何归档对象中的每个实例变量，可以使用 <strong>encoderObject:forKey:</strong>方法归档实例变量。</p>
<h2 id="NSKeyedArchiver归档NSArray">NSKeyedArchiver归档NSArray</h2><h3 id="归档一个NSArray对象到Documents/array-archive">归档一个NSArray对象到Documents/array.archive</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=[[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"array.archive"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:@”a”,@”b”,<span class="literal">nil</span>];</span><br><span class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:array toFile:path];</span><br></pre></td></tr></table></figure>
<h3 id="恢复(解码)NSArray对象">恢复(解码)NSArray对象</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=[[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"array.archive"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSArray</span> *array= [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array);</span><br></pre></td></tr></table></figure>
<h2 id="NSKeyedArchiver-归档Person对象">NSKeyedArchiver-归档Person对象</h2><h3 id="Person-h">Person.h</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Person </span>: NSObject&lt;NSCoding&gt;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *name;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) int age;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) float height;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="Person-m">Person.m</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@implementation</span> Person</span><br><span class="line">-(<span class="typename">void</span>)<span class="string">encodeWithCoder:</span>(NSCoder *)encoder</span><br><span class="line">&#123;</span><br><span class="line">    [encoder <span class="string">encodeObject:</span>self.name <span class="string">forKey:</span>@<span class="string">"name"</span>];</span><br><span class="line">    [encoder <span class="string">encodeInt:</span>self.age <span class="string">forKey:</span>@<span class="string">"age"</span>];</span><br><span class="line">    [encoder <span class="string">encodeFloat:</span>self.height <span class="string">forKey:</span>@<span class="string">"height"</span>];</span><br><span class="line">&#125;</span><br><span class="line">-(id)<span class="string">initWithCoder:</span>(NSCoder *)decoder</span><br><span class="line">&#123;</span><br><span class="line">    self.name=[decoder <span class="string">decodeObjectForKey:</span>@<span class="string">"name"</span>];</span><br><span class="line">    self.age=[decoder <span class="string">decodeIntForKey:</span>@<span class="string">"age"</span>];</span><br><span class="line">    self.height=[decoder <span class="string">decodeFloatForKey:</span>@<span class="string">"height"</span>];</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="归档(编码)">归档(编码)</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *path=<span class="comment">[<span class="comment">[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]</span> stringByAppendingPathComponent:@"person.archive"]</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">Person</span> *<span class="keyword">person</span>=<span class="comment">[<span class="comment">[Person alloc]</span> init]</span>;</span><br><span class="line"><span class="keyword">person</span>.name=@<span class="string">"zhuli8.com"</span>;</span><br><span class="line"><span class="keyword">person</span>.age=1;</span><br><span class="line"><span class="keyword">person</span>.height=2.0f;</span><br><span class="line"><span class="comment">[NSKeyedArchiver archiveRootObject:person toFile:path]</span>;</span><br></pre></td></tr></table></figure>
<h3 id="恢复(解码)">恢复(解码)</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *path=<span class="comment">[<span class="comment">[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]</span> stringByAppendingPathComponent:@"person.archive"]</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">Person</span> *<span class="keyword">person</span>= <span class="comment">[NSKeyedUnarchiver unarchiveObjectWithFile:path]</span>;</span><br><span class="line">NSLog(@<span class="string">"%@"</span>,<span class="keyword">person</span>);</span><br></pre></td></tr></table></figure>
<h3 id="NSKeyedArchiver-归档对象的注意">NSKeyedArchiver-归档对象的注意</h3><p>如果父类也遵守了NSCoding协议，请注意：</p>
<ul>
<li>应该在encodeWithCoder:方法中加上一句<strong>[super encodeWithCode:encode];</strong>确保继承的实例变量也能被编码，即也能被归档；</li>
<li>应该在initWithCoder:方法中加上一句<strong>self = [super initWithCoder:decoder];</strong>确保继承的实例变量也能被解码，即也能被恢复。</li>
</ul>
<h2 id="NSData">NSData</h2><p>使用archiveRootObject:toFile:方法可以将一个对象直接写入到一个文件中，但有时候可能想将多个对象写入到同一个文件中，那么就要使用NSData来进行归档对象。NSData可以为一些数据提供临时存储空间，以便随后写入文件，或者存放从磁盘读取的文件内容。可以使用[NSMutableData data]创建可变数据空间。</p>
<p><img src="http://www.zhuli8.com/photos/NSData.png" alt=""></p>
<h3 id="归档2个Person对象到同一文件中">归档2个Person对象到同一文件中</h3><h4 id="归档（编码）">归档（编码）</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span> *person1=<span class="comment">[<span class="comment">[Person alloc]</span> init]</span>;</span><br><span class="line">person1.name=@<span class="string">"zhuli8.com"</span>;</span><br><span class="line">person1.age=1;</span><br><span class="line">person1.height=1.2f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Person</span> *person2=<span class="comment">[<span class="comment">[Person alloc]</span> init]</span>;</span><br><span class="line">person2.name=@<span class="string">"朱利"</span>;</span><br><span class="line">person2.age=28;</span><br><span class="line">person2.height=1.7f;</span><br><span class="line"></span><br><span class="line">//新建一块可变数据区</span><br><span class="line">NSMutableData *data=<span class="comment">[NSMutableData data]</span>;</span><br><span class="line"></span><br><span class="line">//将数据区连接到一个NSKeyedArchiver对象</span><br><span class="line">NSKeyedArchiver *archiver=<span class="comment">[<span class="comment">[NSKeyedArchiver alloc]</span> initForWritingWithMutableData:data]</span>;</span><br><span class="line"></span><br><span class="line">//开始存档对象，存档的数据都会存储到NSMutableData中</span><br><span class="line"><span class="comment">[archiver encodeObject:person1 forKey:@"person1"]</span>;</span><br><span class="line"><span class="comment">[archiver encodeObject:person2 forKey:@"person2"]</span>;</span><br><span class="line"></span><br><span class="line">//存档完毕（一定要调用这个方法）</span><br><span class="line"><span class="comment">[archiver finishEncoding]</span>;</span><br><span class="line"></span><br><span class="line">//将存档的数据写入文件</span><br><span class="line">NSString *path=<span class="comment">[<span class="comment">[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]</span> stringByAppendingPathComponent:@"persons.archive"]</span>;</span><br><span class="line"><span class="comment">[data writeToFile:path atomically:YES]</span>;</span><br></pre></td></tr></table></figure>
<h4 id="恢复（解码）">恢复（解码）</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//从文件中读取数据</span><br><span class="line">NSString *path=<span class="comment">[<span class="comment">[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]</span> stringByAppendingPathComponent:@"persons.archive"]</span>;</span><br><span class="line">NSData *data=<span class="comment">[NSData dataWithContentsOfFile:path]</span>;</span><br><span class="line">//根据数据，解析成一个NSKeyedUnarchiver对象</span><br><span class="line">NSKeyedUnarchiver *unarchiver=<span class="comment">[<span class="comment">[NSKeyedUnarchiver alloc]</span> initForReadingWithData:data]</span>;</span><br><span class="line"><span class="keyword">Person</span> *person1=<span class="comment">[unarchiver decodeObjectForKey:@"person1"]</span>;</span><br><span class="line"><span class="keyword">Person</span> *person2=<span class="comment">[unarchiver decodeObjectForKey:@"person2"]</span>;</span><br><span class="line"></span><br><span class="line">//恢复完毕</span><br><span class="line"><span class="comment">[unarchiver finishDecoding]</span>;</span><br><span class="line"></span><br><span class="line">NSLog(@<span class="string">"%@,%@"</span>,person1,person2);</span><br></pre></td></tr></table></figure>
<h3 id="利用归档实现深复制">利用归档实现深复制</h3><p>比如对一个Person对象进行深复制</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span> *person1=<span class="comment">[<span class="comment">[Person alloc]</span> init]</span>;</span><br><span class="line">person1.name=@<span class="string">"zhuli8.com"</span>;</span><br><span class="line">person1.age=1;</span><br><span class="line">person1.height=1.2f;</span><br><span class="line"></span><br><span class="line">//临时存储person1的数据</span><br><span class="line">NSData *data=<span class="comment">[NSKeyedArchiver archivedDataWithRootObject:person1]</span>;</span><br><span class="line"></span><br><span class="line">//解析data，生成一个新的<span class="keyword">Person</span>对象</span><br><span class="line"><span class="keyword">Person</span> *person2=<span class="comment">[NSKeyedUnarchiver unarchiveObjectWithData:data]</span>;</span><br><span class="line"></span><br><span class="line">//分别打印内存地址</span><br><span class="line">NSLog(@<span class="string">"person1=%p,person2=%p"</span>,person1,person2);</span><br><span class="line"></span><br><span class="line">//person1=0x7fc478c49390,person2=0x7fc478e1c180</span><br></pre></td></tr></table></figure>
<h1 id="SQLite3">SQLite3</h1><p>SQLite3是一款开源的嵌入式关系型数据库，可移植性好、易使用、内存开销小。<br>SQLite3是无类型的，意味着你可以保存任何类型的数据到任意表的任意字段中。比如下列的创表语句是合法的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> t_person(name, age);</span></span><br></pre></td></tr></table></figure>
<p>为了保证可读性，建议还是把字段类型加上：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> t_person(name <span class="built_in">text</span>, age <span class="built_in">integer</span>);</span></span><br></pre></td></tr></table></figure>
<p>SQLite3常用的5种数据类型：text、integer、float、boolean、blob。</p>
<h2 id="创建、打开、关闭数据库">创建、打开、关闭数据库</h2><h3 id="创建或打开数据库">创建或打开数据库</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSString</span> *path=[[<span class="type">NSSearchPathForDirectoriesInDomains</span>(<span class="type">NSDocumentationDirectory</span>, <span class="type">NSUserDomainMask</span>, <span class="type">YES</span>) lastObject] stringByAppendingPathComponent:@<span class="string">"person.db"</span>];</span><br><span class="line"></span><br><span class="line">sqlite3 *db;//一个打开的数据库实例</span><br><span class="line"></span><br><span class="line">//将根据文件路径打开数据库，如果不存在，则会创建一个新的数据库。如果<span class="literal">result</span>等于常量<span class="type">SQLITE_OK</span>，则表示成功打开数据库。</span><br><span class="line"><span class="type">int</span> <span class="literal">result</span>=sqlite3_open([path <span class="type">UTF8String</span>], &amp;db);//数据库文件的路径必须以C字符串(而非<span class="type">NSString</span>)传入</span><br></pre></td></tr></table></figure>
<h3 id="关闭数据库：">关闭数据库：</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_close<span class="list">(<span class="keyword">db</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="执行不返回数据的SQL语句">执行不返回数据的SQL语句</h2><h3 id="执行创表语句">执行创表语句</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *errorMsg;//用来存储错误信息</span><br><span class="line"><span class="type">char</span> *sql=<span class="string">"create table if not exists t_person(id integer primary key autoincrement,name text,age integer);"</span>;</span><br><span class="line"><span class="type">int</span> <span class="literal">result</span>=sqlite3_exec(db, sql, <span class="type">NULL</span>, <span class="type">NULL</span>, &amp;errorMsg);</span><br></pre></td></tr></table></figure>
<p>sqlite3_exec()可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。<br>sqlite3_exec()还可以执行的语句：</p>
<ul>
<li>开启事务：begin transaction;</li>
<li>回滚事务：rollback;</li>
<li>提交事务：commit;</li>
</ul>
<h3 id="带占位符插入数据">带占位符插入数据</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char <span class="built_in">*</span>sql=<span class="string">"insert into t_person(name,age) values(?,?);"</span>;</span><br><span class="line">sqlite3_stmt <span class="built_in">*</span>stmt;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(sqlite3_prepare_v2<span class="params">(db, sql, -<span class="number">1</span>, &amp;stmt, NULL)</span>==SQLITE_OK)</span> &#123;</span><br><span class="line">    sqlite3_bind_text<span class="params">(stmt, <span class="number">1</span>, <span class="string">"朱利"</span>, -<span class="number">1</span>, NULL)</span>;</span><br><span class="line">    sqlite3_bind_int<span class="params">(stmt, <span class="number">2</span>, <span class="number">1</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="params">(sqlite3_step<span class="params">(stmt)</span>!=SQLITE_DONE)</span> &#123;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">"插入数据错误"</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqlite3_finalize<span class="params">(stmt)</span>;</span><br></pre></td></tr></table></figure>
<p>sqlite3_prepare_v2()：返回值等于SQLITE_OK，说明SQL语句已经准备成功，没有语法问题。<br>sqlite3_bind_text()：大部分绑定函数都只有3个参数</p>
<ul>
<li>第1个参数是sqlite3_stmt *类型</li>
<li>第2个参数指占位符的位置，第一个占位符的位置是1，不是0</li>
<li>第3个参数指占位符要绑定的值</li>
<li>第4个参数指在第3个参数中所传递数据的长度，对于C字符串，可以传递-1代替字符串的长度</li>
<li>第5个参数是一个可选的函数回调，一般用于在语句执行后完成内存清理工作<br>sqlite_step()：执行SQL语句，返回SQLITE_DONE代表成功执行完毕。<br>sqlite_finalize()：销毁sqlite3_stmt *对象。</li>
</ul>
<h2 id="查询数据">查询数据</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *sql = <span class="string">"select id,name,age from t_person;"</span>;</span><br><span class="line">sqlite3_stmt *stmt;</span><br><span class="line"><span class="keyword">if</span> (sqlite3_prepare_v2(db, sql, -<span class="number">1</span>, &amp;stmt, <span class="literal">NULL</span>) == SQLITE_OK) &#123;</span><br><span class="line">    <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;</span><br><span class="line">        <span class="keyword">int</span> _<span class="keyword">id</span> = sqlite3_column_int(stmt, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span> *_name = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:_name];</span><br><span class="line">        <span class="keyword">int</span> _age = sqlite3_column_int(stmt, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"id=%i, name=%@, age=%i"</span>, _<span class="keyword">id</span>, name, _age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_finalize(stmt);</span><br></pre></td></tr></table></figure>
<p>sqlite3<em>step()：返回SQLITE_ROW代表遍历到一条新记录。<br>sqlite3_column</em>*()用于获取每个字段对应的值，第2个参数是字段的索引，从0开始</p>
<h1 id="Core_Data">Core Data</h1><p>Core Data框架提供了对象-关系映射(ORM)的功能，即能够将OC对象转化成数据，保存在SQLite3数据库文件中，也能够将保存在数据库中的数据还原成OC对象。在此数据操作期间，不需要编写任何SQL语句。</p>
<h2 id="推荐文章阅读">推荐文章阅读</h2><p><a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/" target="_blank" rel="external">初识Core Data(1)</a></p>
<p><a href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/" target="_blank" rel="external">初识Core Data(2)</a></p>
<p><a href="http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3/" target="_blank" rel="external">初识Core Data(3)</a></p>
<h2 id="打开Core_Data的SQL日志输出开关">打开Core Data的SQL日志输出开关</h2><ul>
<li>打开Product，点击Edit Scheme…</li>
<li>点击Arguments，在Arguments Passed On Launch中添加2项<ul>
<li>-com.apple.CoreData.SQLDebug</li>
<li>1</li>
</ul>
</li>
</ul>
<h2 id="Core_Data的延迟加载">Core Data的延迟加载</h2><p>Core Data不会根据实体中的关联关系立即获取相应的关联对象，比如通过Core Data取出Person实体时，并不会立即查询相关联的Card实体；当应用真的需要使用Card时，才会查询数据库，加载Card实体的信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[iOS应用数据存储的常用方式]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="数据存储" scheme="http://www.zhuli8.com/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS学习参考]]></title>
    <link href="http://www.zhuli8.com/2015/05/17/iOS%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83/"/>
    <id>http://www.zhuli8.com/2015/05/17/iOS学习参考/</id>
    <published>2015-05-17T01:10:54.000Z</published>
    <updated>2015-08-10T06:42:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="社区博客">社区博客</h1><p><a href="http://www.cocoachina.com/" target="_blank" rel="external">CocoaChina</a></p>
<p>苹果开发中文站 - 最热的iPhone开发社区，最热的苹果开发社区，最热的iPad开发社区。</p>
<p><a href="http://www.code4app.com/" target="_blank" rel="external">Code4App</a></p>
<p>Code4App是一个移动平台的代码库，是iOS开发好帮手。Code4App为移动开发程序员提供大量的开源代码，iOS代码实例搜索，iOS特效示例，iOS代码例子下载。所有的开源代码都经过严格测试，并且配有效果图和演示视频。你可以搜索并下载你需要的任意代码，当然，你也可以浏览这些效果图或者视频，来找找你的UI设计灵感。同时网站内的火花社区供开发者进行求职招聘、技术交流、分享设计创意、展示作品等方面的交流。</p>
<p><a href="http://ios.jobbole.com" target="_blank" rel="external">伯乐在线</a></p>
<p>分享iOS开发资讯和文章</p>
<p><a href="http://www.oschina.net/ios/home" target="_blank" rel="external">开源中国</a></p>
<p>iOS开发社区 - 开源中国社区</p>
<p><a href="http://toutiao.io" target="_blank" rel="external">开发者头条</a></p>
<p>开发者头条 - 开发者的首选阅读分享平台</p>
<p><a href="http://weekly.manong.io" target="_blank" rel="external">码农周刊</a></p>
<p>码农周刊是一份专为程序员打造的IT技术周刊。我们会为你精选一周IT技术干货，每周一发送，完全免费。</p>
<h1 id="个人博客">个人博客</h1><p><a href="http://blog.devtang.com/" target="_blank" rel="external">唐巧</a></p>
<p>InfoQ编辑, 《iOS开发进阶》作者, 在猿题库创业。Java开发工程师，曾开发网易微博后台。 iOS开发工程师，曾开发有道云笔记、猿题库。 </p>
<p><a href="http://www.onevcat.com/" target="_blank" rel="external">王巍</a></p>
<p>一名来自中国的 iOS / Unity 开发者。现居日本，就职于 LINE。正在修行，探求创意之源。</p>
<p><a href="http://beyondvincent.com/" target="_blank" rel="external">破船之家</a></p>
<p>我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的烟火…</p>
<p><a href="http://www.cnblogs.com/chijianqiang/" target="_blank" rel="external">池建强</a></p>
<p>70后程序员。先后从事互联网和企业级应用开发。目前就职瑞友科技（原用友软件工程）IT应用研究院，任职副院长。技术创新控，坚持年轻时的理想，倒霉的乐观者，关注互联网技术、应用平台研发、领域驱动，OSGi，动态语言应用 、云计算、Mac OS相关技术。喜欢的一句话：虽万千人，吾往矣</p>
<p><a href="http://casatwy.com" target="_blank" rel="external">田伟宇</a></p>
<p>Currently working at Alibaba.inc as an iOS engineer for food。</p>
<p><a href="http://blog.leichunfeng.com" target="_blank" rel="external">雷纯锋的技术博客</a></p>
<p> iOS 开发者，GitBucket 的作者，热衷于分享。</p>
<p><a href="http://blog.sunnyxx.com" target="_blank" rel="external">sunnyxx的技术博客</a></p>
<p>孙源（sunnyxx），目前就职于百度，负责百度知道 iOS 客户端的开发工作，对技术喜欢刨根问底和总结最佳实践，热爱分享和开源，维护一个叫 forkingdog 的开源小组。</p>
<p><a href="https://github.com/ChenYilong" target="_blank" rel="external">iOS程序员</a></p>
<p>r p y b b</p>
<h1 id="其他推荐">其他推荐</h1><p><a href="http://objccn.io" target="_blank" rel="external">objc中国</a></p>
<p>为中国 Objective-C 社区带来最佳实践和先进技术</p>
<p><a href="http://tech.glowing.com" target="_blank" rel="external">Glow技术团队博客</a></p>
<p>Thoughts, stories and ideas.</p>
<p><a href="https://github.com/Aufree/trip-to-iOS" target="_blank" rel="external">iOS 学习资料整理</a></p>
<p>这份学习资料是为 iOS 初学者所准备的, 旨在帮助 iOS 初学者们快速找到适合自己的学习资料, 节省他们搜索资料的时间, 使他们更好的规划好自己的 iOS 学习路线, 更快的入门, 更准确的定位的目前所处的位置.</p>
<p><a href="https://github.com/tangqiaoboy/iOSBlogCN" target="_blank" rel="external">推荐博客列表</a></p>
<p>中文 iOS/Mac 开发博客列表</p>
<h1 id="优质博文">优质博文</h1><p><a href="http://www.cocoachina.com/ios/20150608/12052.html" target="_blank" rel="external">那些在学习iOS开发前就应该知道的事（part 1）</a></p>
<p><a href="http://www.cocoachina.com/ios/20150611/12111.html" target="_blank" rel="external">那些在学习iOS开发前就应该知道的事（part 2）</a></p>
<p><a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/" target="_blank" rel="external">初识Core Data(1)</a></p>
<p><a href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/" target="_blank" rel="external">初识Core Data(2)</a></p>
<p><a href="http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3/" target="_blank" rel="external">初识Core Data(3)</a></p>
<p><a href="http://www.liuhaihua.cn/archives/16111.html" target="_blank" rel="external">ReactiveCocoa入门教程：第一部分</a></p>
<p><a href="http://yulingtianxia.com/blog/2015/05/21/ReactiveCocoa-and-MVVM-an-Introduction/" target="_blank" rel="external">ReactiveCocoa 和 MVVM 入门</a></p>
<p><a href="http://www.devtang.com/blog/2014/02/11/reactivecocoa-introduction/" target="_blank" rel="external">ReactiveCocoa - iOS开发的新框架</a></p>
<p><a href="http://www.cocoachina.com/ios/20150702/12302.html" target="_blank" rel="external">ReactiveCocoa自述：工作原理和应用</a></p>
<p><a href="http://zhuanlan.zhihu.com/gupeng/19930501" target="_blank" rel="external">Method Swizzling 和 AOP 实践</a></p>
<p><a href="http://my.oschina.net/lujianing/blog/394367" target="_blank" rel="external">Java转iOS-第一个项目总结(1)</a></p>
<p><a href="http://my.oschina.net/lujianing/blog/404080" target="_blank" rel="external">Java转iOS-第一个项目总结(2)</a></p>
<p><a href="http://www.cocoachina.com/ios/20150423/11658.html" target="_blank" rel="external">详解Xcode 6的视图调试</a></p>
<h1 id="写在最后">写在最后</h1><p>在长的路，一步步也能走完；在短的路，不迈开双脚也无法到达！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="社区博客">社区博客</h1><p><a href="http://www.cocoachina.com/" target="_blank" rel="external">CocoaChina</a></p>
<p>苹果开发中文站 - 最热的iPhone开发社区，]]>
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GPU 加速下的图像处理]]></title>
    <link href="http://www.zhuli8.com/2015/05/10/GPU-%E5%8A%A0%E9%80%9F%E4%B8%8B%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <id>http://www.zhuli8.com/2015/05/10/GPU-加速下的图像处理/</id>
    <published>2015-05-10T02:35:27.000Z</published>
    <updated>2015-07-20T02:55:17.000Z</updated>
    <content type="html"><![CDATA[ <p>Instagram，Snapchat，Photoshop。</p>

<p>所有这些应用都是用来做图像处理的。图像处理可以简单到把一张照片转换为灰度图，也可以复杂到是分析一个视频，并在人群中找到某个特定的人。尽管这些应用非常的不同，但这些例子遵从同样的流程，都是从创造到渲染。</p>

<p>在电脑或者手机上做图像处理有很多方式，但是目前为止最高效的方法是有效地使用图形处理单元，或者叫 GPU。你的手机包含两个不同的处理单元，CPU 和 GPU。CPU 是个多面手，并且不得不处理所有的事情，而 GPU 则可以集中来处理好一件事情，就是并行地做浮点运算。事实上，图像处理和渲染就是在将要渲染到窗口上的像素上做许许多多的浮点运算。</p>

<p>通过有效的利用 GPU，可以成百倍甚至上千倍地提高手机上的图像渲染能力。如果不是基于 GPU 的处理，手机上实时高清视频滤镜是不现实，甚至不可能的。</p>

<p>着色器 (shader) 是我们利用这种能力的工具。着色器是用着色语言写的小的，基于 C 语言的程序。现在有很许多种着色语言，但你如果做 OS X 或者 iOS 开发的话，你应该专注于 OpenGL 着色语言，或者叫 GLSL。你可以将 GLSL 的理念应用到其他的更专用的语言 (比如 Metal) 上去。这里我们即将介绍的概念与和 Core Image 中的自定义核矩阵有着很好的对应，尽管它们在语法上有一些不同。</p>

<p>这个过程可能会很让人恐惧，尤其是对新手。这篇文章的目的是让你接触一些写图像处理着色器的必要的基础信息，并将你带上书写你自己的图像处理着色器的道路。</p>

<h2 id="">什么是着色器</h2>

<p>我们将乘坐时光机回顾一下过去，来了解什么是着色器，以及它是怎样被集成到我们的工作流当中的。</p>

<p>如果你在 iOS 5 或者之前就开始做 iOS 开发，你或许会知道在 iPhone 上 OpenGL 编程有一个转变，从 OpenGL ES 1.1 变成了 OpenGL ES 2.0。</p>

<p>OpenGL ES 1.1 没有使用着色器。作为替代，OpenGL ES 1.1 使用被称为固定功能管线 (fixed-function pipeline) 的方式。有一系列固定的函数用来在屏幕上渲染对象，而不是创建一个单独的程序来指导 GPU 的行为。这样有很大的局限性，你不能做出任何特殊的效果。如果你想知道着色器在工程中可以造成怎样的不同，<a href="http://www.sunsetlakesoftware.com/2011/05/08/enhancing-molecules-using-opengl-es-20" target="_blank" rel="external">看看这篇 Brad Larson 写的他用着色器替代固定函数重构 Molecules 应用的博客</a></p>

<p>OpenGL ES 2.0 引入了可编程管线。可编程管线允许你创建自己的着色器，给了你更强大的能力和灵活性。</p>

<p>在 OpenGL ES 中你必须创建两种着色器：顶点着色器 (vertex shaders) 和片段着色器 (fragment shaders)。这两种着色器是一个完整程序的两半，你不能仅仅创建其中任何一个；想创建一个完整的着色程序，两个都是必须存在。</p>

<p>顶点着色器定义了在 2D 或者 3D 场景中几何图形是如何处理的。一个顶点指的是 2D 或者 3D 空间中的一个点。在图像处理中，有 4 个顶点：每一个顶点代表图像的一个角。顶点着色器设置顶点的位置，并且把位置和纹理坐标这样的参数发送到片段着色器。</p>

<p>然后 GPU 使用片段着色器在对象或者图片的每一个像素上进行计算，最终计算出每个像素的最终颜色。图片，归根结底，实际上仅仅是数据的集合。图片的文档包含每一个像素的各个颜色分量和像素透明度的值。因为对每一个像素，算式是相同的，GPU 可以流水线作业这个过程，从而更加有效的进行处理。使用正确优化过的着色器，在 GPU 上进行处理，将使你获得百倍于在 CPU 上用同样的过程进行图像处理的效率。</p>

<p>把东西渲染到屏幕上从一开始就是一个困扰 OpenGL 开发者的问题。仅仅让屏幕呈现出非黑色就要写很多样板代码和设置。开发者必须跳过很多坑 ，而这些坑所带来的沮丧感以及着色器测试方法的匮乏，让很多人放弃了哪怕是尝试着写着色器。</p>

<p>幸运的是，过去几年，一些工具和框架减少了开发者在尝试着色器方面的焦虑。</p>

<ul><br><li><a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">GPUImage</a></li><br><li><a href="https://www.shadertoy.com/" target="_blank" rel="external">ShaderToy</a></li><br><li><a href="http://www.shaderific.com/" target="_blank" rel="external">Shaderific</a></li><br><li>Quartz Composer</li><br></ul>

<p>下面我将要写的每一个着色器的例子都是从开源框架 GPUImage 中来的。如果你对 OpenGL/OpenGL ES 场景如何配置，从而使其可以使用着色器渲染感到好奇的话，可以 clone 这个仓储。我们不会深入到怎样设置 OpenGL/OpenGL ES 来使用着色器渲染，这超出了这篇文章的范围。</p>

<h2 id="">我们的第一个着色器的例子</h2>

<h3 id="">顶点着色器</h3>

<p>好吧，关于着色器我们说的足够多了。我们来看一个实践中真实的着色器程序。这里是一个 GPUImage 中一个基础的顶点着色器：</p>

<pre><code class="glsl">attribute vec4 position;  
attribute vec4 inputTextureCoordinate；

varying vec2 textureCoordinate;

void main()  
{
    gl_position = position;
    textureCoordinate = inputTextureCoordinate.xy;
}
</code></pre>

<p>我们一句一句的来看:</p>

<pre><code class="glsl">attribute vec4 position;  
</code></pre>

<p>像所有的语言一样，着色器语言的设计者也为常用的类型创造了特殊的数据类型，例如 2D 和 3D 坐标。这些类型是向量，稍后我们会深入更多。回到我们的应用程序的代码，我们创建了一系列顶点，我们为每个顶点提供的参数里的其中一个是顶点在画布中的位置。然后我们必须告诉我们的顶点着色器它需要接收这个参数，我们稍后会将它用在某些事情上。因为这是一个 C 程序，我们需要记住要在每一行代码的结束使用一个分号，所以如果你正使用 Swift 的话，你需要把在末尾加分号的习惯捡回来。</p>

<pre><code class="glsl">attribute vec4 inputTextureCoordinate;  
</code></pre>

<p>现在你或许很奇怪，为什么我们需要一个纹理坐标。我们不是刚刚得到了我们的顶点位置了吗？难道它们不是同样的东西吗？</p>

<p>其实它们并非一定是同样的东西。纹理坐标是纹理映射的一部分。这意味着你想要对你的纹理进行某种滤镜操作的时候会用到它。左上角坐标是 (0,0)。右上角的坐标是 (1,0)。如果我们需要在图片内部而不是边缘选择一个纹理坐标，我们需要在我们的应用中设定的纹理坐标就会与此不同，像是 (.25, .25) 是在图片左上角向右向下各图片高宽 1/4 的位置。在我们当前的图像处理应用里，我们希望纹理坐标和顶点位置一致，因为我们想覆盖到图片的整个长度和宽度。有时候你或许会希望这些坐标是不同的，所以需要记住它们未必是相同的坐标。在这个例子中，顶点坐标空间从 -1.0 延展到 1.0，而纹理坐标是从 0.0 到 1.0。</p>

<pre><code class="glsl">varying vec2 textureCoordinate;  
</code></pre>

<p>因为顶点着色器负责和片段着色器交流，所以我们需要创建一个变量和它共享相关的信息。在图像处理中，片段着色器需要的唯一相关信息就是顶点着色器现在正在处理哪个像素。</p>

<pre><code class="glsl">gl_Position = position;  
</code></pre>

<p><code>gl_Position</code> 是一个内建的变量。GLSL 有一些内建的变量，在片段着色器的例子中我们将看到其中的一个。这些特殊的变量是可编程管道的一部分，API 会去寻找它们，并且知道如何和它们关联上。在这个例子中，我们指定了顶点的位置，并且把它从我们的程序中反馈给渲染管线。</p>

<pre><code class="glsl">textureCoordinate = inputTextureCoordinate.xy;  
</code></pre>

<p>最后，我们取出这个顶点中纹理坐标的 X 和 Y 的位置。我们只关心 <code>inputTextureCoordinate</code> 中的前两个参数，X 和 Y。这个坐标最开始是通过 4 个属性存在顶点着色器里的，但我们只需要其中的两个。我们拿出需要的属性，然后赋值给一个将要和片段着色器通信的变量，而不是把更多的属性反馈给片段着色器。</p>

<p>在大多数图像处理程序中，顶点着色器都差不多，所以，这篇文章接下来的部分，我们将集中讨论片段着色器。</p>

<h3 id="">片段着色器</h3>

<p>看过了我们简单的顶点着色器后，我们再来看一个可以实现的最简单的片段着色器：一个直通滤镜：</p>

<pre><code class="glsl">varying highp vec2 textureCoordinate;

uniform sampler2D inputImageTexture;

void main()  
{
    gl_FragColor = texture2D(inputImageTexture, textureCoordinate);
}
</code></pre>

<p>这个着色器实际上不会改变图像中的任何东西。它是一个直通着色器，意味着我们输入每一个像素，然后输出完全相同的像素。我们来一句句的看：</p>

<pre><code class="glsl">varying highp vec2 textureCoordinate;  
</code></pre>

<p>因为片段着色器作用在每一个像素上，我们需要一个方法来确定我们当前在分析哪一个像素/片段。它需要存储像素的 X 和 Y 坐标。我们接收到的是当前在顶点着色器被设置好的纹理坐标。</p>

<pre><code class="glsl">uniform sampler2D inputImageTexture;  
</code></pre>

<p>为了处理图像，我们从应用中接收一个图片的引用，我们把它当做一个 2D 的纹理。这个数据类型被叫做 <code>sampler2D</code> ，这是因为我们要从这个 2D 纹理中采样出一个点来进行处理。</p>

<pre><code class="glsl">gl_FragColor = texture2D(inputImageTexture, textureCoordinate);  
</code></pre>

<p>这是我们碰到的第一个 GLSL 特有的方法：<code>texture2D</code>，顾名思义，创建一个 2D 的纹理。它采用我们之前声明过的属性作为参数来决定被处理的像素的颜色。这个颜色然后被设置给另外一个内建变量，<code>gl_FragColor</code>。因为片段着色器的唯一目的就是确定一个像素的颜色，<code>gl_FragColor</code> 本质上就是我们片段着色器的返回语句。一旦这个片段的颜色被设置，接下来片段着色器就不需要再做其他任何事情了，所以你在这之后写任何的语句，都不会被执行。</p>

<p>就像你看到的那样，写着色器很大一部分就是了解着色语言。即使着色语言是基于 C 语言的，依然有很多怪异和细微的差别让它和普通的 C 语言有不同。</p>

<h2 id="glsl">GLSL 数据类型和运算</h2>

<p>各式着色器都是用 OpenGL 着色语言 (GLSL) 写的。GLSL 是一种从 C 语言导出的简单语言。它缺少 C 语言的高级功能，比如动态内存管理。但是，它也包含一些在着色过程中常用的数学运算函数。</p>

<p>在负责 OpenGL 和 OpenGL ES 实现的 Khronos 小组的网站上有一些有用的参考资料。在你开始之前，一件你可以做的最有价值的事情就是获取 OpenGL 和 OpenGL ES 的快速入门指导：</p>

<ul><br><li><a href="https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf" target="_blank" rel="external">OpenGL ES</a></li><br><li><a href="https://www.khronos.org/files/opengl-quick-reference-card.pdf" target="_blank" rel="external">OpenGL</a></li><br></ul>

<p>通过查看这些参考卡片，你可以快速简单地了解在写 OpenGL 应用时需要的着色语言函数和数据类型。</p>

<p>尽早用，经常用。</p>

<p>即使在这么简单的着色器的例子里，也有一些地方看起来很怪异，不是吗？看过了基础的着色器之后，是时候开始解释其中一些内容，以及它们为什么存在于 GLSL 中。</p>

<h2 id="precisionqualifiers">输入，输出，以及精度修饰 (Precision Qualifiers)</h2>

<p>看一看我们的直通着色器，你会注意到有一个属性被标记为 “varying”，另一个属性被标记为 “uniform”。</p>

<p>这些变量是 GLSL 中的输入和输出。它允许从我们应用的输入，以及在顶点着色器和片段着色器之间进行交流。</p>

<p>在 GLSL 中，实际有三种标签可以赋值给我们的变量：</p>

<ul><br><li>Uniforms</li><br><li>Attributes</li><br><li>Varyings</li><br></ul>

<p>Uniforms 是一种外界和你的着色器交流的方式。Uniforms 是为在一个渲染循环里不变的输入值设计的。如果你正在应用茶色滤镜，并且你已经指定了滤镜的强度，那么这些就是在渲染过程中不需要改变的事情，你可以把它作为 Uniform 输入。 Uniform 在顶点着色器和片段着色器里都可以被访问到。</p>

<p>Attributes 仅仅可以在顶点着色器中被访问。Attribute 是在随着每一个顶点不同而会发生变动的输入值，例如顶点的位置和纹理坐标等。顶点着色器利用这些变量来计算位置，以它们为基础计算一些值，然后把这些值以 varyings 的方式传到片段着色器。</p>

<p>最后，但同样重要的，是 varyings 标签。Varying 在顶点着色器和片段着色器都会出现。Varying 是用来在顶点着色器和片段着色器传递信息的，并且在顶点着色器和片段着色器中必须有匹配的名字。数值在顶点着色器被写入到 varying ，然后在片段着色器被读出。被写入 varying 中的值，在片段着色器中会被以插值的形式插入到两个顶点直接的各个像素中去。</p>

<p>回看我们之前写的简单的着色器的例子，在顶点着色器和片段着色器中都用 varying 声明了 <code>textureCoordinate</code>。我们在顶点着色器中写入 varying 的值。然后我们把它传入片段着色器，并在片段着色器中读取和处理。</p>

<p>在我们继续之前，最后一件要注意的事。看看创建的这些变量。你会注意到纹理坐标有一个叫做 highp 的属性。这个属性负责设置你需要的变量精度。因为 OpenGL ES 被设计为在处理能力有限的系统中使用，精度限制被加入进来可以提高效率。</p>

<p>如果不需要非常高的精度，你可以进行设定，这或许会允许在一个时钟循环内处理更多的值。相反的，在纹理坐标中，我们需要尽可能的确保精确，所以我们具体说明确实需要额外的精度。</p>

<p>精度修饰存在于 OpenGL ES 中，因为它是被设计用在移动设备中的。但是，在老版本的桌面版的 OpenGL 中则没有。因为 OpenGL ES 实际上是 OpenGL 的子集，你几乎总是可以直接把 OpenGL ES 的项目移植到 OpenGL。如果你这样做，记住一定要在你的桌面版着色器中去掉精度修饰。这是很重要的一件事，尤其是当你计划在 iOS 和 OS X 之间移植项目时。</p>

<h2 id="">向量</h2>

<p>在 GLSL 中，你会用到很多向量和向量类型。向量是一个很棘手的话题，它们表面上看起来很直观，但是因为它们有很多用途，这使我们在使用它们时常常会感到迷惑。</p>

<p>在 GLSL 环境中，向量是一个类似数组的特殊的数据类型。每一种类型都有固定的可以保存的元素。深入研究一下，你甚至可以获得数组可以存储的数值的精确的类型。但是在大多数情况下，只要使用通用的向量类型就足够了。</p>

<p>有三种向量类型你会经常看到：</p>

<ul><br><li><code>vec2</code></li><br><li><code>vec3</code></li><br><li><code>vec4</code></li><br></ul>

<p>这些向量类型包含特定数量的浮点数：<code>vec2</code> 包含两个浮点数，<code>vec3</code> 包含三个浮点数，<code>vec4</code> 包含四个浮点数。 </p>

<p>这些类型可以被用在着色器中可能被改变或者持有的多种数据类型中。在片段着色器中，很明显 X 和 Y 坐标是的你想保存的信息。 (X,Y) 存储在 <code>vec2</code> 中就很合适。</p>

<p>在图像处理过程中，另一个你可能想持续追踪的事情就是每个像素的 R，G，B，A 值。这些可以被存储在 <code>vec4</code> 中。</p>

<h2 id="">矩阵</h2>

<p>现在我们已经了解了向量，接下来继续了解矩阵。矩阵和向量很相似，但是它们添加了额外一层的复杂度。矩阵是一个浮点数数组的数组，而不是单个的简单浮点数数组。</p>

<p>类似于向量，你将会经常处理的矩阵对象是：</p>

<ul><br><li><code>mat2</code></li><br><li><code>mat3</code></li><br><li><code>mat4</code></li><br></ul>

<p><code>vec2</code> 保存两个浮点数，<code>mat</code> 保存相当于两个 <code>vec2</code> 对象的值。将向量对象传递到矩阵对象并不是必须的，只需要有足够填充矩阵的浮点数即可。在 <code>mat2</code> 中，你需要传入两个 <code>vec2</code> 或者四个浮点数。因为你可以给向量命名，而且相比于直接传浮点数，你只需要负责两个对象，而不是四个，所以非常推荐使用封装好的值来存储你的数字，这样更利于追踪。对于 <code>mat4</code> 会更复杂一些，因为你要负责 16 个数字，而不是 4 个。</p>

<p>在我们 <code>mat2</code> 的例子中，我们有两个 <code>vec2</code> 对象。每个 <code>vec2</code> 对象代表一行。每个 <code>vec2</code> 对象的第一个元素代表一列。构建你的矩阵对象的时候，确保每个值都放在了正确的行和列上是很重要的，否则使用它们进行运算肯定得不到正确的结果。</p>

<p>既然我们有了矩阵也有了填充矩阵的向量，问题来了：“我们要用它们做什么呢？“ 我们可以存储点和颜色或者其他的一些的信息，但是要如果通过修改它们来做一些很酷的事情呢？</p>

<h2 id="">向量和矩阵运算，也就是初等线性代数</h2>

<p>我找到的最好的关于线性代数和矩阵是如何工作的资源是这个网站的<a href="http://betterexplained.com/articles/linear-algebra-guide/" target="_blank" rel="external">更好的解释</a>。我从这个网站<del>偷来</del>借鉴的一句引述就是：</p>

<blockquote><br>  <p>线性代数课程的幸存者都成为了物理学家，图形程序员或者其他的受虐狂。</p><br></blockquote>

<p>矩阵操作总体来说并不“难”；只不过它们没有被任何上下文解释，所以很难概念化地理解究竟为什么会有人想要和它们打交道。我希望能在给出一些它们在图形编程中的应用背景后，我们可以了解它们怎样帮助我们实现不可思议的东西。</p>

<p>线性代数允许你一次在很多值上进行操作。假想你有一组数，你想要每一个数乘以 2。你一般会一个个地顺次计算数值。但是因为对每一个数都进行的是同样的操作，所以你完全可以并行地实现这个操作。</p>

<p>我们举一个看起来可怕的例子，<code>CGAffineTransforms</code>。仿射转化是很简单的操作，它可以改变具有平行边的形状 (比如正方形或者矩形) 的大小，位置，或者旋转角度。</p>

<p>在这种时候你当然可以坐下来拿出笔和纸，自己去计算这些转化，但这么做其实没什么意义。GLSL 有很多内建的函数来进行这些庞杂的用来计算转换的函数。了解这些函数背后的思想才是最重要的。</p>

<h2 id="glsl">GLSL 特有函数</h2>

<p>这篇文章中，我们不会把所有的 GLSL 内建的函数都过一遍，不过你可以在 <a href="http://www.shaderific.com/glsl-functions" target="_blank" rel="external">Shaderific</a> 上找到很好的相关资源。很多 GLSL 函数都是从 C 语言数学库中的基本的数学运算导出的，所以解释 sin 函数是做什么的真的是浪费时间。我们将集中阐释一些更深奥的函数，从而达到这篇文章的目的，解释怎样才能充分利用 GPU 的性能的一些细节。</p>

<p><strong><code>step()</code>:</strong> GPU 有一个局限性，它并不能很好的处理条件逻辑。GPU 喜欢做的事情是接受一系列的操作，并将它们作用在所有的东西上。分支会在片段着色器上导致明显的性能下降，在移动设备上尤其明显。<code>step()</code> 通过允许在不产生分支的前提下实现条件逻辑，从而在某种程度上可以缓解这种局限性。如果传进 <code>step()</code> 函数的值小于阈值，<code>step()</code> 会返回 0.0。如果大于或等于阈值，则会返回 1.0。通过把这个结果和你的着色器的值相乘，着色器的值就可以被使用或者忽略，而不用使用 <code>if()</code> 语句。</p>

<p><strong><code>mix()</code>:</strong>  mix 函数将两个值 (例如颜色值) 混合为一个变量。如果我们有红和绿两个颜色，我们可以用 <code>mix()</code> 函数线性插值。这在图像处理中很常用，比如在应用程序中通过一组独特的设定来控制效果的强度等。</p>

<p><em>*<code>clamp()</code>:</em> GLSL 中一个比较一致的方面就是它喜欢使用归一化的坐标。它希望收到的颜色分量或者纹理坐标的值在 0.0 和 1.0 之间。为了保证我们的值不会超出这个非常窄的区域，我们可以使用 <code>clamp()</code> 函数。 <code>clamp()</code> 会检查并确保你的值在 0.0 和 1.0 之间。如果你的值小于 0.0，它会把值设为 0.0。这样做是为了防止一些常见的错误，例如当你进行计算时意外的传入了一个负数，或者其他的完全超出了算式范围的值。 </p>

<h2 id="">更复杂的着色器的例子</h2>

<p>我知道数学的洪水一定让你快被淹没了。如果你还能跟上我，我想举几个优美的着色器的例子，这会更有意义，这样你又有机会淹没在 GLSL 的潮水中。</p>

<h3 id="">饱和度调整</h3>

<p><img src="http://img.objccn.io/issue-21/Saturation.png" alt="实践中的饱和度滤镜"></p>

<p>这是一个做饱和度调节的片段着色器。这个着色器出自 《<a href="http://www.amazon.com/Graphics-Shaders-Theory-Practice-Second/dp/1568814348/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1422557718&amp;sr=1-1&amp;keywords=graphics+shaders+theory+and+practice" target="_blank" rel="external">图形着色器：理论和实践</a>》一书，我强烈推荐整本书给所有对着色器感兴趣的人。</p>

<p>饱和度是用来表示颜色的亮度和强度的术语。一件亮红色的毛衣的饱和度要远比北京雾霾时灰色的天空的饱和度高得多。</p>

<p>在这个着色器上，参照人类对颜色和亮度的感知过程，我们有一些优化可以使用。一般而言，人类对亮度要比对颜色敏感的多。这么多年来，压缩软件体积的一个优化方式就是减少存储颜色所用的内存。</p>

<p>人类不仅对亮度比颜色要敏感，同样亮度下，我们对某些特定的颜色反应也更加灵敏，尤其是绿色。这意味着，当你寻找压缩图片的方式，或者以某种方式改变它们的亮度和颜色的时候，多放一些注意力在绿色光谱上是很重要的，因为我们对它最为敏感。</p>

<pre><code class="glsl">varying highp vec2 textureCoordinate;

uniform sampler2D inputImageTexture;  
uniform lowp float saturation;

const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);

void main()  
{
   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);
   lowp float luminance = dot(textureColor.rgb, luminanceWeighting);
   lowp vec3 greyScaleColor = vec3(luminance);

    gl_FragColor = vec4(mix(greyScaleColor, textureColor.rgb, saturation), textureColor.w);

}
</code></pre>

<p>我们一行行的看这个片段着色器的代码：</p>

<pre><code class="glsl">varying highp vec2 textureCoordinate;

uniform sampler2D inputImageTexture;  
uniform lowp float saturation;  
</code></pre>

<p>再一次，因为这是一个要和基础的顶点着色器通信的片段着色器，我们需要为输入纹理坐标和输入图片纹理声明一个 varyings 变量，这样才能接收到我们需要的信息，并进行过滤处理。这个例子中我们有一个新的 uniform 的变量需要处理，那就是饱和度。饱和度的数值是一个我们从用户界面设置的参数。我们需要知道用户需要多少饱和度，从而展示正确的颜色数量。</p>

<pre><code class="glsl">const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);  
</code></pre>

<p>这就是我们设置三个元素的向量，为我们的亮度来保存颜色比重的地方。这三个值加起来要为 1，这样我们才能把亮度计算为 0.0 - 1.0 之间的值。注意中间的值，就是表示绿色的值，用了 70% 的颜色比重，而蓝色只用了它的 10%。蓝色对我们的展示不是很好，把更多权重放在绿色上是很有意义的。</p>

<pre><code class="glsl">lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);  
</code></pre>

<p>我们需要取样特定像素在我们图片/纹理中的具体坐标来获取颜色信息。我们将会改变它一点点，而不是想直通滤镜那样直接返回。</p>

<pre><code class="glsl">lowp float luminance = dot(textureColor.rgb, luminanceWeighting);  
</code></pre>

<p>这行代码会让那些没有学过线性代数或者很早以前在学校学过但是很少用过的人看起来不那么熟悉。我们是在使用 GLSL 中的点乘运算。如果你记得在学校里曾用过点运算符来相乘两个数字的话，那么你就能明白是什么回事儿了。点乘计算以包含纹理颜色信息的 <code>vec4</code> 为参数，舍弃 <code>vec4</code> 的最后一个不需要的元素，将它和相对应的亮度权重相乘。然后取出所有的三个值把它们加在一起，计算出这个像素综合的亮度值。</p>

<pre><code class="glsl">lowp vec3 greyScaleColor = vec3(luminance);  
</code></pre>

<p>我们创建一个三个值都是亮度信息的 <code>vec3</code>。如果你只指定一个值，编译器会帮你把该将向量中的每个分量都设成这个值。</p>

<pre><code class="glsl">gl_FragColor = vec4(mix(greyScaleColor, textureColor.rgb, saturation), textureColor.w);  
</code></pre>

<p>最后，我们把所有的片段组合起来。为了确定每个新的颜色是什么，我们使用刚刚学过的很好用的 mix 函数。mix 函数会把我们刚刚计算的灰度值和初始的纹理颜色以及我们得到的饱和度的信息相结合。</p>

<p>这就是一个很棒的，好用的着色器，它让你用主函数里的四行代码就可以把图片从彩色变到灰色，或者从灰色变到彩色。还不错，不是吗？</p>

<h3 id="">球形折射</h3>

<p>最后，我们来看一个很漂亮的滤镜，你可以用来向你的朋友炫耀，或者吓唬你的敌人。这个滤镜看起来像是有一个玻璃球在你的图片上。这会比之前的看起来更复杂。但我相信我们可以完成它。</p>

<p><img src="http://img.objccn.io/issue-21/sphereRefraction.png" alt="实践中的球形折射滤镜！"></p>

<pre><code class="glsl">varying highp vec2 textureCoordinate;

uniform sampler2D inputImageTexture;

uniform highp vec2 center;  
uniform highp float radius;  
uniform highp float aspectRatio;  
uniform highp float refractiveIndex;

void main()  
{
    highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));
    highp float distanceFromCenter = distance(center, textureCoordinateToUse);
    lowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius);

    distanceFromCenter = distanceFromCenter / radius;

    highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);
    highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));

    highp vec3 refractedVector = refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);

    gl_FragColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere;
}
</code></pre>

<p>再一次，看起来很熟悉…</p>

<pre><code class="glsl">uniform highp vec2 center;  
uniform highp float radius;  
uniform highp float aspectRatio;  
uniform highp float refractiveIndex;  
</code></pre>

<p>我们引入了一些参数，用来计算出图片中多大的区域要通过滤镜。因为这是一个球形，我们需要一个中心点和半径来计算球形的边界。宽高比是由你使用的设备的屏幕尺寸决定的，所以不能被硬编码，因为 iPhone 和 iPad 的比例是不相同的。我们的用户或者程序员会决定折射率，从而确定折射看起来是什么样子的。GPUImage 中折射率被设置为 0.71.</p>

<pre><code class="glsl">highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));  
</code></pre>

<p>图像的纹理坐标是在归一化的 0.0-1.0 的坐标空间内。归一化的坐标空间意味着考虑屏幕是一个单位宽和一个单位长，而不是 320 像素宽，480 像素高。因为手机的高度比宽度要长，我们需要为球形计算一个偏移率，这样球就是圆的而不是椭圆的。</p>

<p><img src="http://img.objccn.io/issue-21/aspectRatio.png" alt="我们希望正确的宽高比"></p>

<pre><code class="glsl">highp float distanceFromCenter = distance(center, textureCoordinateToUse);  
</code></pre>

<p>我们需要计算特定的像素点距离球形的中心有多远。我们使用 GLSL 内建的 <code>distance()</code> 函数，它会使用勾股定律计算出中心坐标和长宽比矫正过的纹理坐标的距离。</p>

<pre><code class="glsl">lowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius);  
</code></pre>

<p>这里我们计算了片段是否在球体内。我们计算当前点距离球形中心有多远以及球的半径是多少。如果当前距离小于半径，这个片段就在球体内，这个变量被设置为 1.0。否则，如果距离大于半径，这个片段就不在球内，这个变量被设置为 0.0 。</p>

<p><img src="http://img.objccn.io/issue-21/distanceFromCenter2.png" alt="像素在球内或者球外"></p>

<pre><code class="glsl">distanceFromCenter = distanceFromCenter / radius;  
</code></pre>

<p>By dividing it by the radius, we are making our math calculations easier in the next few lines of code.</p>

<p>既然我们已经计算出哪些像素是在球内的，我们接着要对这些球内的像素进行计算并做些事情。再一次，我们需要标准化到球心的距离。我们直接重新设置 <code>distanceFromCenter</code> 的值，而不是新建一个变量，因为那会增加我们的开销。 通过将它与半径相除，我们可以让之后几行计算代码变得简单一些。</p>

<pre><code class="glsl">highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);  
</code></pre>

<p>因为我们试图模拟一个玻璃球，我们需要计算球的“深度”是多少。这个虚拟的球，不论怎样，在 Z 轴上，将会延伸图片表面到观察者的距离。这将帮助计算机确定如何表示球内的像素。还有，因为球是圆的，距离球心不同的距离，会有不同的深度。由于球表面方向的不同，球心处和边缘处对光的折射会不相同：</p>

<p><img src="http://img.objccn.io/issue-21/normalizedDepth.png" alt="球有多深?"></p>

<pre><code class="glsl">highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));  
</code></pre>

<p>这里我们又进行了一次归一化。为了计算球面某个点的方向，我们用 X ，Y 坐标的方式，表示当前像素到球心的距离，然后把这些和计算出的球的深度结合。然后把结果向量进行归一化。</p>

<p>想想当你正在使用 Adobe Illustrator 这样的软件时，你在 Illustrator 中创建一个三角形，但是它太小了。你按住 option 键，放大三角形，但是它现在太大了。你然后把它缩小到你想要的尺寸：</p>

<p><img src="http://img.objccn.io/issue-21/sphereNormal.png" alt="什么是角?"></p>

<pre><code class="glsl">highp vec3 refractedVector = refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);  
</code></pre>

<p><code>refract()</code> 是一个很有趣的 GLSL 函数。<code>refract()</code> 以我们刚才创建的球法线和折射率来计算当光线通过这样的球时，从任意一个点看起来是怎样的。</p>

<pre><code class="glsl">gl_FragColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere;  
</code></pre>

<p>最后，通过所有这些障碍后，我们终于凑齐了计算片段使用的颜色所需要的所有信息。折射光向量用来查找读取的输入位于图片哪个位置的，但是因为在那个向量中，坐标是从 -1.0 到 1.0 的，我们需要把它调整到 0.0-1.0 的纹理坐标空间内。</p>

<p>我们然后把我们的结果和球边界检查的值相乘。如果我们的片段没有在球内，一个透明的像素 (0.0, 0.0, 0.0, 0.0) 将被写入。如果片段在球形内，这个结果被使用，然后返回计算好的颜色值。这样我们在着色器中可以就避免昂贵的条件逻辑。</p>

<h2 id="">调试着色器</h2>

<p>着色器调试不是一件直观的工作。普通的程序中，如果程序崩溃了，你可以设置一个断点。这在每秒会被并行调用几百万次的运算中是不可能的。在着色器中使用 <code>printf()</code> 语句来调试哪里出错了也是不可能的，因为输出到哪里呢？考虑你的着色器运行在黑盒中，你怎么才能打开它然后看看为什么它们不工作呢？</p>

<p>你有一个可以使用的输出：我们的老朋友 <code>gl_FragColor</code>。<code>gl_FragColor</code> 会给你一个输出，换一种思路想一想，你可以用它来调试你的代码。</p>

<p>所有你在屏幕上看到的颜色都是由一系列的数字表示的，这些数字是每一个像素的红绿蓝和透明度的百分比。你可以用这些知识来测试着色器的每一部分是不是像你构建的那样工作，从而确定它是不是按照你想的那样在运行。和一般调试不同，你不会得到一个可以打印的值，而是拿到一个颜色以及和它相关的某个指定值，依靠这些你可以进行逆向反推。</p>

<p>如果想知道你的一个在 0 和 1 之间的值，你可以把它设置给一个将要传入 <code>gl_FragColor</code> 的 <code>vec4</code> 中。假设你把它设置进第一部分，就是红色值。这个值会被转换然后渲染到屏幕上，这时候你就可以检查它来确定原始的传进去的值是什么。</p>

<p>你会有几种方法来捕捉到这些值。从着色器输出的图片可以被捕获到然后作为图片写进磁盘里 (最好用户没有压缩过的格式)。这张图片之后就可以放进像 Photoshop 这样的应用，然后检查像素的颜色。</p>

<p>为了更快一些，你可以将图片用 OS X 的程序或者 iOS 的模拟器显示到屏幕上。在你的应用程序文件夹下的实用工具里有一个“数码测色计”的工具可以用来分析这些渲染过的视图。把鼠标放在桌面的任何一个像素点上，它都会精确的展示这个像素点 RGB 的值。因为 RGB 值在数码测色计和 Photoshop 中是从 0 到 255 而不是 从 0 到 1，你需要把你想要的值除以 255 来获得一个近似的输入值。</p>

<p>回顾下我们的球形折射着色器。简直无法想象没有任何测试就可以写下整个程序。我们有很大一块代码来确定当前处理的像素是不是在这个圆形当中。那段代码的结尾用 <code>step()</code> 函数来设置像素的这个值为 0.0 或者 1.0 。</p>

<p>把一个 <code>vec4</code> 的红色分量设为 <code>step()</code> 的输出，其他两个颜色值设为 0，然后传入<code>gl_FragColor</code> 中去。如果你的程序正确的运行，你将看到在黑色的屏幕上一个红色的圈。如果整个屏幕都是黑色，或者都是红色，那么肯定是有什么东西出错了。</p>

<h2 id="">性能调优</h2>

<p>性能测试和调优是非常重要的事情。尤其是你想让你的应用在旧的 iOS 设备上也能流畅运行时。</p>

<p>测试着色器性能很重要，因为你总是不能确定一个东西的性能会怎样。着色器性能变化的很不直观。你会发现 Stack Overflow 上一个非常好的优化方案并不会加速你的着色器，因为你没有优化代码的真正瓶颈。即使仅只是调换你工程里的几行代码都有可能非常大的减少或增加渲染的时间。</p>

<p>分析的时候，我建议测算帧渲染的时间，而不是每秒钟渲染多少帧。帧渲染时间随着着色器的性能线性的增加或减少，这会让你观察你的影响更简单。FPS 是帧时间的倒数，在调优的时候可能会难于理解。最后，如果你使用 iPhone 的相机捕捉图像，它会根据场景的光亮来调整 FPS ，如果你依赖于此，会导致不准确的测量。</p>

<p>帧渲染时间是帧从开始处理到完全结束并且渲染到屏幕或者一张图片所花费的时间。许多移动 GPU 用一种叫做 “延迟渲染” 的技术，它会把渲染指令批量处理，并且只会在需要的时候才会处理。所以，需要计算整个渲染过程，而不是中间的操作过程，因为它们或许会以一种与你想象不同的顺序运行。</p>

<p>不同的设备上，桌面设备和移动设备上，优化也会很不相同。你或许需要在不同类型的设备上进行分析。例如，GPU 的性能在移动 iOS 设备上有了很大的提升。iPhone 5S 的 CPU 比 iPhone 4 快了接近十倍，而 GPU 则快上了好几百倍。</p>

<p>如果你在有着 A7 芯片或者更高的设备上测试你的应用，相比于 iPhone 5 或者更低版本的设备，你会获得非常不同的结果。<a href="http://www.sunsetlakesoftware.com/2013/10/21/optimizing-gaussian-blurs-mobile-gpu" target="_blank" rel="external">Brad Larson 测试了高斯模糊在不同的设备上花费的时间，并且非常清晰的展示了在新设备上性能有着令人惊奇的提升:</a></p>

<table><thead><br><tr><br><th>iPhone 版本</th><br><th> 帧渲染时间 (毫秒)</th><br></tr><br></thead><tbody><br><tr><br><td>iPhone 4</td><br><td>873</td><br></tr><br><tr><br><td>iPhone 4S</td><br><td>145</td><br></tr><br><tr><br><td>iPhone 5</td><br><td>55</td><br></tr><br><tr><br><td>iPhone 5S</td><br><td>3</td><br></tr><br></tbody></table>

<p>你可以下载一个工具，<a href="http://community.imgtec.com/developers/powervr/" target="_blank" rel="external">Imagination Technologies PowerVR SDK</a>，它会帮助你分析你的着色器，并且让你知道着色器渲染性能的最好的和最坏的情况 。为了保持高帧速率，使渲染着色器所需的周期数尽可能的低是很重要的。如果你想达成 60 帧每秒，你只有 16.67 毫秒来完成所有的处理。</p>

<p>这里有一些简单的方式来帮助你达成目标：</p>

<ul><br><li><p><strong>消除条件逻辑:</strong> 有时候条件逻辑是必须得，但尽量最小化它。在着色器中使用像 <code>step()</code>  函数这样的变通方法可以帮助你避免一些昂贵的条件逻辑。</p></li><br><li><p><strong>减少依赖纹理的读取:</strong> 在片段着色器中取样时，如果纹理坐标不是直接以 varying 的方式传递进来，而是在片段着色器中进行计算时，就会发生依赖纹理的读取。依赖纹理的读取不能使用普通的纹理读取的缓存优化，会导致读取更慢。例如，如果你想从附近的像素取样，而不是计算和片段着色器中相邻像素的偏差，最好在顶点着色器中进行计算，然后把结果以 varying 的方式传入片段着色器。在 <a href="http://objccn.io/issue-21-8" target="_blank" rel="external">Brad Larson的文章</a>中关于索贝尔边缘检测的部分有一个这方面的例子。</p></li><br><li><p><strong>让你的计算尽量简单:</strong> 如果你在避免一个昂贵的操作情况下可以获得一个近似的足够精度的值，你应该这样做。昂贵的计算包括调用三角函数 (像<code>sin()</code>, <code>cos()</code>, 和 <code>tan()</code>)。</p></li><br><li><p><strong>如果可以的话，把工作转移到顶点着色器:</strong>  之前讲的关于依赖纹理的读取就是把纹理坐标计算转移到顶点着色器的很有意义的一种情况。如果一个计算在图片上会有相同的结果，或者线性的变化，看看能不能把计算移到顶点着色器进行。顶点着色器对每个顶点运行一次，片段着色器在每个像素上运行一次，所以在前者上的计算会比后者少很多。</p></li><br><li><p><strong>在移动设备上使用合适的精度</strong> 在特定的移动设备上，在向量上使用低精度的值会变得更快。在这些设备上，两个 <code>lowp vec4</code> 相加的操作可以在一个时钟周期内完成，而两个 <code>highp vec4</code> 相加则需要四个时钟周期。但是在桌面 GPU 和最近的移动 GPU 上，这变得不再那么重要，因为它们对低精度值的优化不同。</p></li><br></ul>

<h2 id="">结论和资源</h2>

<p>着色器刚开始看起来很吓人，但它们也仅仅是改装的 C 程序而已。创建着色器相关的所有事情，我们大多数都在某些情况下处理过，只不过在不同的上下文中罢了。</p>

<p>对于想深入了解着色器的人，我非常推荐的一件事就是回顾下三角学和线性代数。做相关工作的时候，我遇到的最大的阻力就是忘了很多大学学过的数学，因为我已经很长时间没有实际使用过它们了。</p>

<p>如果你的数学有些生疏了，我有一些书可以推荐给你：</p>

<ul><br><li><a href="http://www.amazon.com/Math-Primer-Graphics-Game-Development/dp/1568817231/ref=sr_1_1?ie=UTF8&amp;qid=1422837187&amp;sr=8-1&amp;keywords=3d+math+primer+for+graphics+and+game+development" target="_blank" rel="external">3D Math Primer for Graphics and Game Development</a></li><br><li><a href="http://natureofcode.com" target="_blank" rel="external">The Nature of Code</a></li><br><li><a href="http://www.amazon.com/Computational-Beauty-Nature-Explorations-Adaptation/dp/0262561271/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1422837256&amp;sr=1-1&amp;keywords=computational+beauty+of+nature" target="_blank" rel="external">The Computational Beauty of Nature</a></li><br></ul>

<p>也有数不清的关于GLSL书和特殊着色器被我们行业突出的人士创造出来：</p>

<ul><br><li><a href="http://www.amazon.com/Graphics-Shaders-Theory-Practice-Second/dp/1568814348/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1422837351&amp;sr=1-1&amp;keywords=graphics+shaders+theory+and+practice" target="_blank" rel="external">Graphics Shaders: Theory and Practice</a></li><br><li><a href="http://www.amazon.com/OpenGL-Shading-Language-Randi-Rost/dp/0321637631/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1422896457&amp;sr=1-1&amp;keywords=opengl+shading+language" target="_blank" rel="external">The OpenGL Shading Language</a></li><br><li><a href="http://www.amazon.com/OpenGL-Shading-Language-Cookbook-Second/dp/1782167021/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1422896457&amp;sr=1-2&amp;keywords=opengl+shading+language" target="_blank" rel="external">OpenGL 4 Shading Language Cookbook</a></li><br><li><a href="http://http.developer.nvidia.com/GPUGems/gpugems_part01.html" target="_blank" rel="external">GPU Gems</a></li><br><li><a href="http://www.amazon.com/GPU-Pro-Advanced-Rendering-Techniques/dp/1568814720/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1422837427&amp;sr=1-4&amp;keywords=gpu+pro" target="_blank" rel="external">GPU Pro: Advanced Rendering Techniques</a></li><br></ul>

<p>还有，再一次强调，<a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="external">GPUImage</a>是一个开源的资源，里面有一些非常酷的着色器。一个非常好的学习着色器的方式，就是拿一个你觉得很有意思的着色器，然后一行一行看下去，搜寻任何你不理解的部分。GPUImage 还有一个<a href="https://github.com/BradLarson/GPUImage/tree/master/examples/Mac/ShaderDesigner" target="_blank" rel="external">着色器设计</a>的 Mac 端应用，可以让你测试着色器而不用准备 OpenGL 的代码。</p>

<p>学习有效的在代码中实现着色器可以给你带来很大的性能提升。不仅如此，着色器也使你可以做以前不可能做出来的东西。</p>

<p>学习着色器需要一些坚持和好奇心，但是并不是不可能的。如果一个 33 岁的还在康复中的新闻专业的人都能够克服她对数学的恐惧来处理着色器的话，那么你肯定也可以。</p>

<p>原文 <a href="http://www.objc.io/issue-21/gpu-accelerated-image-processing.html" target="_blank" rel="external">GPU-Accelerated Image Processing</a> <a href="http://objccn.io/issue-21-7/" target="_blank" rel="external">译文</a></p>
<p>扩展阅读 <a href="https://github.com/100mango/zen/blob/master/WWDC心得：Advanced%20Graphics%20and%20Animations%20for%20iOS%20Apps/Advanced%20Graphics%20and%20Animations%20for%20iOS%20Apps.md" target="_blank" rel="external">Advanced Graphics and Animations for iOS Apps</a></p>
]]></content>
    <summary type="html">
    <![CDATA[ <p>Instagram，Snapchat，Photoshop。</p>

<p>所有这些应用都是用来做图像处理的。图像处理可以简单到把一张照片转换为灰度图，也可以复杂到是分析一个视频，并在人群中找到某个特定的人。尽管这些应用非常的不同，但这些例子遵从同样的流程，都是从创造到渲]]>
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="图像处理" scheme="http://www.zhuli8.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sip&xmpp]]></title>
    <link href="http://www.zhuli8.com/2015/05/03/sip-xmpp/"/>
    <id>http://www.zhuli8.com/2015/05/03/sip-xmpp/</id>
    <published>2015-05-03T07:22:21.000Z</published>
    <updated>2015-07-22T07:29:58.000Z</updated>
    <content type="html"><![CDATA[<p>XMPP和SIP都是应用层协议,主要用于互联网上发送语音和即时通讯。 SIP在RFC 3621中定义,XMPP在RFC 3920中定义。XMPP是从即时通讯中演变而来,SIP是从VOIP中演变而来,XMPP为了会话协商添加了一个扩展叫做Jingle,SIP为了即时通讯业务添加了一个扩展叫做SIMPLE。</p>
<h1 id="SIP_(Session_Initiation_Protocol)">SIP (Session Initiation Protocol)</h1><p>SIP是一个应用层协议,是用在类似VOIP这样的场合,用来建立、修改、中止会话,同时在多人会议中他也能在已有会话中加入新的会话。基本上SIP是VOIP中的信令协议,它处理呼叫建立,呼叫转移和产生CDR(Call Detail Record,供通话计费用)。</p>
<h1 id="XMPP_(Extensible_Messaging_Presence_Protocol)">XMPP (Extensible Messaging Presence Protocol)</h1><p>XMPP是一个为即时通讯和请求响应业务服务的XML协议，最早由Jabber开源社区在1999年开发,2002年XMPP工作组为了更适合即时通讯对Jabber进行了扩展。</p>
<h1 id="SIP和XMPP的异同">SIP和XMPP的异同</h1><p>其实我们不能简单地拿SIP和XMPP做比对,就像我们不能直接比较苹果和橘子,前者主要是为了会话协商,后者主要是为了结构化数据交换,只不过随着各自对Simple和Jingle的引入,他们有了一些相似。</p>
<p>1、SIP提供连接的建立、修改和终止，而XMPP在客户端内部提供流管道、交换结构化数据。</p>
<p>也就是说：SIP的重点是终端之间连接的建立和维护，连接以后的数据和信息传送他不关注；而XMPP重点是考虑终端内部的数据交换，连接建立是基本的功能，而不是重点。所以，XMPP对应用的支持和扩展性的考虑很充分,比SIP天生要好。</p>
<p>2、SIP的信令和消息传送是基于文本的，不太好解析,或者说解析起来缺少规律性,在新增数据消息体的时候缺少继承性,需要开发新的代码来封装和解析,原有代码的继承性比较差。而XMPP采用XML，是一种结构化的消息结构，能够方便地表达层次化的内容，以及内容之间的内在逻辑。这种XML结构对应用的扩展和内容的解析带来极大的方便，大量软件代码可以复用。</p>
<p>3、SIP信令由header和body两部分组成，也就是说，SIP报文格式的header已经包含了部分内容,类似于HTTP,与具体的上层应用直接关联，而不是通用的报文格式；而XMPP所有信息都是采用XML在流管道之间透明传送。</p>
<p>SIP的连接建立通道与数据传送通道是各自独立的，连接建立在SIP client与Server之间，而数据传送通道是在Client—Client之间直接进行的。这个对视频、语音和文件传送业务很合适，但是不适合其他形式的应用。</p>
<p>XMPP的控制和数据通道是一体的，Clent只与Server建立连接，而Client与Client之间是没有之间连接的。Client之间传送的通道是：Client1—-〉Server1—-〉Server2—-〉Client2。这种方式看起来扩展性差，server压力很大，但是能够实现很好的业务功能，比如留言、广播、群聊、状态更新、Blog、微博、数据共享等等。</p>
<p>这种C-S模型，很多业务的控制在Server上完成，新功能的增加在server上实现，在server上定义新的XML对象和逻辑，客户端只要负责XML数据流的解析和呈现就可以了, 所以，终端实现简单。</p>
<p>4、SIP可以使用UDP,TCP,TLS进行传送,而XMPP仅仅使用TCP和TLS进行发送.</p>
<p>5、SIP是双向对称，客户端和服务器都可以主动发起连接请求并响应，这种对称连接的方式在穿越NAT和Firewall的时候很麻烦，无法保证穿越NAT。而XMPP是单向的连接，只有Client可以向Server发起连接请求，Server不会向Client发起连接。这样便于NAT和Firewall的穿越。</p>
]]></content>
    <summary type="html">
    <![CDATA[介绍XMPP与SIP]]>
    
    </summary>
    
      <category term="IM" scheme="http://www.zhuli8.com/tags/IM/"/>
    
      <category term="IM" scheme="http://www.zhuli8.com/categories/IM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS自定义转场]]></title>
    <link href="http://www.zhuli8.com/2015/04/26/iOS%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA/"/>
    <id>http://www.zhuli8.com/2015/04/26/iOS自定义转场/</id>
    <published>2015-04-26T01:27:07.000Z</published>
    <updated>2015-08-11T09:59:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="UIViewControllerTransitioning">UIViewControllerTransitioning</h1><h2 id="UIViewControllerAnimatedTransitioning">UIViewControllerAnimatedTransitioning</h2><p>采用UIViewControllerAnimatedTransitioning协议实现自定义转场动画，它提供了两个方法：</p>
<p>1、transitionDuration:指定转场的过渡时间。</p>
<p>2、animateTransition:创建转场动画。</p>
<p>在转场中涉及到的信息通过一个实现了UIViewControllerContextTransitioning的transitionContext上下文对象进行传递，使用这个transitionContext参数能移动或关闭目标控制器以及控制这个过程中持续的时间。</p>
<p>首先，我们需要自定义一个实现了UIViewControllerAnimatedTransitioning协议的对象。创建一个类CustomPresentAnimation继承自NSObject并遵守UIViewControllerAnimatedTransitioning协议。</p>
<p><strong>CustomPresentAnimation.h</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">CustomPresentAnimation </span>: NSObject &lt;UIViewControllerAnimatedTransitioning&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>CustomPresentAnimation.m</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CustomPresentAnimation</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用transitionContext可以得到参与切换的两个ViewController的信息</span></span><br><span class="line">    <span class="built_in">UIViewController</span> *toVC= [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将控制器视图初始位置设置到屏幕下边缘，从而从屏幕下方出现</span></span><br><span class="line">    <span class="built_in">CGRect</span> finalRect=[transitionContext finalFrameForViewController:toVC];</span><br><span class="line">    toVC<span class="variable">.view</span><span class="variable">.frame</span>=<span class="built_in">CGRectOffset</span>(finalRect, <span class="number">0</span>, [[<span class="built_in">UIScreen</span> mainScreen] bounds]<span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//所有的动画视图都必须放在transitionContext的containerView里</span></span><br><span class="line">    [[transitionContext containerView] addSubview:toVC<span class="variable">.view</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:[<span class="keyword">self</span> transitionDuration:transitionContext] delay:<span class="number">0.0</span> usingSpringWithDamping:<span class="number">0.5</span> initialSpringVelocity:<span class="number">0.5</span> options:<span class="built_in">UIViewAnimationOptionCurveEaseInOut</span> animations:^&#123;</span><br><span class="line">        toVC<span class="variable">.view</span><span class="variable">.frame</span>=finalRect;</span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="comment">//动画完成或者取消之后必须得调用的方法，系统接收到这个消息后将对控制器的状态进行维护</span></span><br><span class="line">        [transitionContext completeTransition:<span class="literal">YES</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UIViewControllerTransitioningDelegate">UIViewControllerTransitioningDelegate</h2><p>实现UIViewControllerTransitioningDelegate协议的对象在控制器 <em>presented</em> 或者 <em>dismissed</em> 时返回上面继承自NSObject并遵守UIViewControllerAnimatedTransitioning协议的CustomPresentAnimation对象。这个接口的作用比较单一，在需要控制器切换的时候会向实现了这个接口的对象询问是否需要使用自定义的切换效果。我们可以让需要实现切换的控制器实现这个协议。</p>
<p><strong>PresentedViewController.m</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PresentedViewController</span> () &lt;<span class="title">UIViewControllerTransitioningDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) CustomPresentAnimation *presentAnimation;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PresentedViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span><span class="variable">.transitioningDelegate</span>=<span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.presentAnimation</span>=[[CustomPresentAnimation alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)clickDismmissButton:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"clickDismmissButton"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.presentAnimation</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>UIViewController中自定义转场动画到这就结束了，<a href="https://github.com/zhuli8com/transition.git" target="_blank" rel="external">点击</a>查看的完整代码。</p>
<h1 id="让你的app绚起来">让你的app绚起来</h1><p><a href="http://www.cnblogs.com/kenshincui/p/3972100.html" target="_blank" rel="external">iOS开发系列—让你的应用“动”起来</a></p>
<p><a href="http://kittenyang.com/uiviewcontrollertransitioning/" target="_blank" rel="external">iOS自定义转场详解</a></p>
<p><a href="http://www.jianshu.com/p/38cd35968864" target="_blank" rel="external">关于自定义转场动画，我都告诉你。</a></p>
]]></content>
    <summary type="html">
    <![CDATA[iOS自定义转场动画]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git总结]]></title>
    <link href="http://www.zhuli8.com/2015/04/19/git%E6%80%BB%E7%BB%93/"/>
    <id>http://www.zhuli8.com/2015/04/19/git总结/</id>
    <published>2015-04-19T07:55:39.000Z</published>
    <updated>2015-08-29T00:49:48.000Z</updated>
    <content type="html"><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linux Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 在分布式版本控制上，使用 Git 会比其他解决方案更可靠。</p>
<h1 id="前提">前提</h1><p>默认进入到了工程目录，即 cd xxx。</p>
<p>在安装好git后第一件是是设置你的名字和电子邮箱，因为每次提交都要用到这些信息：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --user<span class="class">.name</span> <span class="string">"Your name"</span></span><br><span class="line">git config --user<span class="class">.email</span> <span class="string">"Your email"</span></span><br></pre></td></tr></table></figure>
<h1 id="查看其他指令的用途及配置指令">查看其他指令的用途及配置指令</h1><p>1、git help</p>
<p>2、git config user.name ‘zhuli8’</p>
<p>3、git config user.email ‘zhuli1228@163.com’</p>
<p>4、git config —list：查看配置</p>
<p>5、git log：查看日志</p>
<h1 id="操作github上的已有项目">操作github上的已有项目</h1><p>注意：</p>
<pre><code>使用Xcode工具连接github仓库时使用的用户名必须是自己GitHub上的账号名而不是邮箱。
</code></pre><p>1、clone远程仓库</p>
<p>git clone <a href="https://github.com/zhuli8com/transition.git" target="_blank" rel="external">https://github.com/zhuli8com/transition.git</a></p>
<p>2、添加文件</p>
<p>git add . 或者git add test.txt</p>
<p>3、提交到本地</p>
<p>git commit -m ‘注释’</p>
<p>4、提交到github主分支</p>
<p>git push origin master</p>
<p>5、删除文件test.txt文件</p>
<p>git delete test.txt，重复3、4步骤</p>
<p>6、从远程更新本地代码</p>
<p>git pull origin master</p>
<h1 id="创建本地仓库并上传github">创建本地仓库并上传github</h1><p>1、初始化一个版本仓库</p>
<p>git init</p>
<p>2、添加远程版本库</p>
<p>git remote add [shortname] [url]</p>
<p>git remote add origin <a href="https://github.com/zhuli8com/transition.git" target="_blank" rel="external">https://github.com/zhuli8com/transition.git</a></p>
<p>3、查看远程仓库</p>
<p>git remote -v</p>
<p>4、下拉远程仓库文件到本地，抓取远程仓库master分支更新合并到本地</p>
<p>git pull origin master （最最关键的步骤）</p>
<p>5、添加到本地暂存区</p>
<p>git add .</p>
<p>6、提交到本地版本库</p>
<p>git commit -m ‘注释’</p>
<p>7、提交到github，将本地分支推到远程主分支</p>
<p>git push origin master</p>
<h1 id="参考">参考</h1><p><a href="http://justcoding.iteye.com/blog/1830388" target="_blank" rel="external">git常用命令</a></p>
]]></content>
    <summary type="html">
    <![CDATA[工作中使用git的心得体会]]>
    
    </summary>
    
      <category term="git" scheme="http://www.zhuli8.com/tags/git/"/>
    
      <category term="代码管理" scheme="http://www.zhuli8.com/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
      <category term="开发利器" scheme="http://www.zhuli8.com/tags/%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/"/>
    
      <category term="开发利器" scheme="http://www.zhuli8.com/categories/%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言预处理指令]]></title>
    <link href="http://www.zhuli8.com/2015/04/12/C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/"/>
    <id>http://www.zhuli8.com/2015/04/12/C语言预处理指令/</id>
    <published>2015-04-12T08:39:02.000Z</published>
    <updated>2015-09-01T01:09:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="宏定义">宏定义</h1><h2 id="不带参数的宏定义">不带参数的宏定义</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine 宏名 字符串</span><br></pre></td></tr></table></figure>
<p>它的作用是在编译预处理时，将源程序中所有”宏名”替换成右边的”字符串”，常用来定义常量。</p>
<blockquote>
<p>1.宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误</p>
<p>2.在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查</p>
<p>3.宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令</p>
</blockquote>
<h2 id="带参数的宏定义">带参数的宏定义</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hexcolor">#def</span>ine 宏名(参数列表) 字符串</span><br></pre></td></tr></table></figure>
<p>在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数 用 宏名右边参数列表 中的参数替换</p>
<blockquote>
<p>1.宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串</p>
<p>2.带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。</p>
<p>3.计算结果最好也用括号括起来</p>
</blockquote>
<h1 id="条件编译">条件编译</h1><p>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译(只有参与编译的代码最终才能被执行)，这就是条件编译。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#if</span> 条件<span class="number">1</span></span><br><span class="line"> ..<span class="class">.code1</span>...</span><br><span class="line"><span class="id">#elif</span> 条件<span class="number">2</span></span><br><span class="line"> ..<span class="class">.code2</span>...</span><br><span class="line"><span class="id">#else</span></span><br><span class="line"> ..<span class="class">.code3</span>...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<blockquote>
<p>#if 和 #elif后面的条件一般是判断宏定义而不是判断变量，因为条件编译是在编译之前做的判断，宏定义也是编译之前定义的，而变量是在运行时才产生的、才有使用的意义</p>
</blockquote>
<h2 id="其他">其他</h2><ol>
<li>#if defined()和#if !defined()</li>
<li>#ifdef和#ifndef</li>
</ol>
<h1 id="文件包含">文件包含</h1><blockquote>
<p>#include的作用纯粹就是内容拷贝</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>　&lt;文件名&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接到C语言库函数头文件所在的目录中寻找文件</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span>　"文件名"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>系统会先在源程序当前目录下寻找，若找不到，再到操作系统的path路径中查找，最后才到C语言库函数头文件所在目录中查找</p>
</blockquote>
<h2 id="其他-1">其他</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">one.h</span><br><span class="line"><span class="preprocessor">#ifndef _ONE_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _ONE_H_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">tow.h</span><br><span class="line"><span class="preprocessor">#ifndef _TWO_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _TWO_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "one.h"</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">two</span><span class="params">()</span></span>;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">main.h</span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "one.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "two.h"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后的main.h的文件相当于下面的代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include "one.h"</span></span><br><span class="line"><span class="preprocessor">#ifndef _ONE_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _ONE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include "two.h"</span></span><br><span class="line"><span class="preprocessor">#ifndef _TWO_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _TWO_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include "one.h"</span></span><br><span class="line"><span class="preprocessor">#ifndef _ONE_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> _ONE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">two</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[C语言提供的预处理指令主要有：宏定义、文件包含、条件编译]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
</feed>