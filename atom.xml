<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[zhuli8’blog]]></title>
  <subtitle><![CDATA[Talk is cheap, show me the code.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.zhuli8.com/"/>
  <updated>2017-11-30T03:54:12.000Z</updated>
  <id>http://www.zhuli8.com/</id>
  
  <author>
    <name><![CDATA[朱利]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[iOS中提取app的图片]]></title>
    <link href="http://www.zhuli8.com/2017/10/01/iOS%E4%B8%AD%E6%8F%90%E5%8F%96app%E7%9A%84%E5%9B%BE%E7%89%87/"/>
    <id>http://www.zhuli8.com/2017/10/01/iOS中提取app的图片/</id>
    <published>2017-10-01T02:05:41.000Z</published>
    <updated>2017-11-30T03:54:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="iTunes"><a href="#iTunes" class="headerlink" title="iTunes"></a>iTunes</h2><p>下载 <a href="https://link.jianshu.com/?t=https://secure-appldnld.apple.com/itunes12/091-33628-20170922-EF8F0FE4-9FEF-11E7-B113-91CF9A97A551/iTunes12.6.3.dmg" target="_blank" rel="external">iTunes 12.6.3</a> 支持 iPhone 8，iPhone X和iOS 11,获取AppStore应用的IPA包。</p>
<p>强制删除其他版本的iTunes：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">rm</span> -rf /Applications/iTunes.<span class="keyword">app</span></span><br></pre></td></tr></table></figure>
<h2 id="iOS-Images-Extractor"><a href="#iOS-Images-Extractor" class="headerlink" title="iOS-Images-Extractor"></a>iOS-Images-Extractor</h2><p><a href="https://github.com/devcxm/iOS-Images-Extractor" target="_blank" rel="external">iOS-Images-Extractor</a></p>
<p>打开软件后，拖拽ipa、car文件、png、jpg或者整个文件夹到软件窗口，点击Start按钮即可开始提取图片资源文件。</p>
<p>图片默认输出到/User/用户名/Downloads/iOSImagesExtractor文件夹，可直接点击Output Dir按钮快速跳转到输出文件夹。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.jianshu.com/p/43acc44f1d2b" target="_blank" rel="external">解决 iTunes 12.7 无法下载 AppStore应用的IPA包问题</a></p>
<p><a href="http://www.jianshu.com/p/8152e1828aec" target="_blank" rel="external">iOS中如何找到一款app的所有图片</a></p>
]]></content>
    <summary type="html">
    <![CDATA[iOS中提取app的图片]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[xcode9]]></title>
    <link href="http://www.zhuli8.com/2017/09/29/xcode9/"/>
    <id>http://www.zhuli8.com/2017/09/29/xcode9/</id>
    <published>2017-09-29T02:05:41.000Z</published>
    <updated>2017-10-31T04:20:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在全屏模式下使用xcode模拟器"><a href="#在全屏模式下使用xcode模拟器" class="headerlink" title="在全屏模式下使用xcode模拟器"></a>在全屏模式下使用xcode模拟器</h1><ul>
<li>开启模拟器Internal菜单</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /AppleInternal</span><br><span class="line"></span><br><span class="line">OSX10.<span class="number">11</span>的一个新特性 Rootless,也叫System Integrity Protection（SIP）和SELinux差不多，都是限制root用户的权限。其实可以在RecoveryMode关闭这个特性，这样就直接可以读写/usr/bin了，不过不建议。（关闭方法：开机的时候按住option出现选择磁盘的界面按<span class="built_in">command</span> + R进入RecoveryMode，选择实用工具终端，输入csrutil <span class="built_in">disable</span>回车搞定）</span><br></pre></td></tr></table></figure>
<ul>
<li>设置模拟器允许全屏模式</li>
</ul>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">Xcode9模拟器</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">Internal</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">Allow</span> <span class="comment">Fullscreen</span> <span class="comment">Mode</span></span><br></pre></td></tr></table></figure>
<ul>
<li>mac添加桌面（快捷键：四指向上调出）–&gt;添加Xcode9 –&gt;添加模拟器</li>
</ul>
<p><img src="../photos/xcode9.png" alt="xcode9"></p>
<ul>
<li>参考链接</li>
</ul>
<p> <a href="https://www.appcoda.com.tw/ios-simulator-tips-tricks/" target="_blank" rel="external">提升 iOS 開發效率！ Xcode 9 內置模擬器的新功能與技巧</a></p>
]]></content>
    <summary type="html">
    <![CDATA[xcode9新特性]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[3D Touch 实践]]></title>
    <link href="http://www.zhuli8.com/2016/01/02/3D-Touch-%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.zhuli8.com/2016/01/02/3D-Touch-实践/</id>
    <published>2016-01-02T10:05:45.000Z</published>
    <updated>2016-02-02T10:11:25.000Z</updated>
    <content type="html"><![CDATA[<p>iphone6s的一个显著卖点应该是3D Touch，其原理是增加了一个压力感触，通过区分轻按和重按来进行不同的用户交互。</p>
<p>我们可以通过3D手势，在主屏幕上的应用Icon处，直接进入应用的响应功能模块。用户可以通过3D Touch手势在view上来预览一些预加载信息，这样的设计可以使app更加简洁大方，交互性也更强，也是对app的一个优化。</p>
<h1 id="Home-Screen-Quick-Actions"><a href="#Home-Screen-Quick-Actions" class="headerlink" title="Home Screen Quick Actions"></a>Home Screen Quick Actions</h1><p>通过主屏幕的应用Icon，我们可以用3D Touch呼出一个菜单，进行快速定位应用功能模块相关功能的开发。</p>
<h2 id="静态标签"><a href="#静态标签" class="headerlink" title="静态标签"></a>静态标签</h2><p>静态标签是我们在项目的配置plist文件中配置的标签，在用户安装程序后就可以使用，并且排序会在动态标签的前面。</p>
<p>在Info.plist文件中添加UIApplicationShortcutItems数组，在改数组下建立一个包括UIApplicationShortcutItemTitle、UIApplicationShortcutSubtitle、UIApplicationShortcutItemIconFile、UIApplicationShortcutType键值对的字典即可,系统并没有提示，只能手打上去。</p>
<h2 id="动态标签"><a href="#动态标签" class="headerlink" title="动态标签"></a>动态标签</h2><p>动态标签是我们在程序中，通过代码添加的，与之相关的类，主要有三个：UIApplicationShortcutItem、UIMutableApplicationShortcutItem、UIApplicationShortcutIcon。</p>
<p>在appDelegate的-application:didFinishLaunchingWithOptions:方法中添加如下代码：</p>
<p>1.图标<br>UIApplicationShortcutIcon *icon1=[UIApplicationShortcutIcon iconWithTemplateImageName:@”iCon1”];</p>
<p>系统自带图标:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeSearch]</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIApplicationShortcutIconType</span>) &#123;</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeCompose</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypePlay</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypePause</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeAdd</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeLocation</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeSearch</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeShare</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeProhibit</span>       <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeContact</span>        <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeHome</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeMarkLocation</span>   <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeFavorite</span>       <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeLove</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeCloud</span>          <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeInvitation</span>     <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeConfirmation</span>   <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeMail</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeMessage</span>        <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeDate</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeTime</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeCapturePhoto</span>   <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeCaptureVideo</span>   <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeTask</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeTaskCompleted</span>  <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeAlarm</span>          <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeBookmark</span>       <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeShuffle</span>        <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeAudio</span>          <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeUpdate</span>         <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1)</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_0) __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>
<p>2.创建shortcut item<br>UIMutableApplicationShortcutItem *item1=[[UIMutableApplicationShortcutItem alloc] initWithType:@”com.zhuli8.dynamic” localizedTitle:@”Dynamic Shortcut” localizedSubtitle:@”available after first lauch” icon:icon1 userInfo:nil];</p>
<p>3.获取已经存在的shortcut item，例如静态的shortcut item<br>NSArray *existingItems=[UIApplication sharedApplication].shortcutItems;</p>
<p>4.当前所有的shortcut item赋值给当前应用程序<br>NSArray *updateItems=[existingItems arrayByAddingObjectsFromArray:@[item1]];<br>[UIApplication sharedApplication].shortcutItems=updateItems;</p>
<p>到此动态创建3d touch已经基本完成。如果要响应标签的行为，需要实现appDelegate中的一个方法-application:willFinishLaunchingWithOptions: </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))completionHandler&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([shortcutItem<span class="variable">.type</span> isEqualToString:<span class="string">@"com.zhuli8.deep1"</span>]) &#123;</span><br><span class="line">        ZLSecondeViewController *secondVC=[[ZLSecondeViewController alloc] init];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span>=secondVC;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="peep-pop"><a href="#peep-pop" class="headerlink" title="peep/pop"></a>peep/pop</h1><p>这个功能是一套全新的用户交互机制，在使用3D Touch时，ViewController中会有如下三个交互阶段：</p>
<ol>
<li>提示用户这里有3D Touch的交互，会使交互控件周围模糊</li>
<li>继续深按，会出现预览视图</li>
<li>通过视图上的交互控件进行进一步交互</li>
</ol>
<p>在控制器的-viewWillAppear:方法中判断设备是否有3d touch特性，根据返回值决定是否设置代理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.traitCollection</span><span class="variable">.forceTouchCapability</span>==<span class="built_in">UIForceTouchCapabilityAvailable</span>) &#123;</span><br><span class="line">    [<span class="keyword">self</span> registerForPreviewingWithDelegate:<span class="keyword">self</span> sourceView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现UIViewControllerPreviewingDelegate的两个代理方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable <span class="built_in">UIViewController</span> *)previewingContext:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext viewControllerForLocation:(<span class="built_in">CGPoint</span>)location <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)previewingContext:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext commitViewController:(<span class="built_in">UIViewController</span> *)viewControllerToCommit <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</span><br></pre></td></tr></table></figure>
<p>具体实例代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIViewController</span> *)previewingContext:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext viewControllerForLocation:(<span class="built_in">CGPoint</span>)location&#123;</span><br><span class="line">    <span class="comment">//check if we're not already displaying a preview controller</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.presentedViewController</span> isKindOfClass:[ZLPreviewViewController class]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ZLPreviewViewController *previewVC=[[ZLPreviewViewController alloc] init];</span><br><span class="line">    <span class="keyword">return</span> previewVC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)previewingContext:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext commitViewController:(<span class="built_in">UIViewController</span> *)viewControllerToCommit&#123;</span><br><span class="line">    <span class="comment">//deep press:bring up the commit view controller(pop)</span></span><br><span class="line">    ZLCommitViewController *commitVC=[[ZLCommitViewController alloc] init];</span><br><span class="line">    [<span class="keyword">self</span> showViewController:commitVC sender:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写父类的previewActionItems方法配置preview菜单</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;<span class="built_in">UIPreviewActionItem</span>&gt;&gt; *)previewActionItems&#123;</span><br><span class="line">    <span class="built_in">UIPreviewAction</span> *action1=[<span class="built_in">UIPreviewAction</span> actionWithTitle:<span class="string">@"action 1"</span> style:<span class="built_in">UIPreviewActionStyleDefault</span> handler:^(<span class="built_in">UIPreviewAction</span> * _Nonnull action, <span class="built_in">UIViewController</span> * _Nonnull previewViewController) &#123;</span><br><span class="line">        ZLLogDebug(<span class="string">@"UIPreviewActionStyleDefault trggered"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIPreviewAction</span> *action2=[<span class="built_in">UIPreviewAction</span> actionWithTitle:<span class="string">@"destructive action"</span> style:<span class="built_in">UIPreviewActionStyleDestructive</span> handler:^(<span class="built_in">UIPreviewAction</span> * _Nonnull action, <span class="built_in">UIViewController</span> * _Nonnull previewViewController) &#123;</span><br><span class="line">        ZLLogDebug(<span class="string">@"UIPreviewActionStyleDestructive trggered"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIPreviewAction</span> *action3=[<span class="built_in">UIPreviewAction</span> actionWithTitle:<span class="string">@"selected action"</span> style:<span class="built_in">UIPreviewActionStyleSelected</span> handler:^(<span class="built_in">UIPreviewAction</span> * _Nonnull action, <span class="built_in">UIViewController</span> * _Nonnull previewViewController) &#123;</span><br><span class="line">        ZLLogDebug(<span class="string">@"UIPreviewActionStyleSelected trggered"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIPreviewActionGroup</span> *group1=[<span class="built_in">UIPreviewActionGroup</span> actionGroupWithTitle:<span class="string">@"action group"</span> style:<span class="built_in">UIPreviewActionStyleDefault</span> actions:@[action1,action2,action3]];<span class="comment">//可以返回组</span></span><br><span class="line">    <span class="keyword">return</span> @[action1,action2,action3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Force-Properties"><a href="#Force-Properties" class="headerlink" title="Force Properties"></a>Force Properties</h1><p>iOS9为我们提供了一个新的交互参数:力度。我们可以检测某一交互的力度值，来做相应的交互处理。例如，我们可以通过力度来控制快进的快慢，音量增加的快慢等。</p>
]]></content>
    <summary type="html">
    <![CDATA[3D Touch 实践]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[项目中用到的工具和技术]]></title>
    <link href="http://www.zhuli8.com/2015/10/25/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    <id>http://www.zhuli8.com/2015/10/25/项目中用到的工具和技术/</id>
    <published>2015-10-25T07:58:16.000Z</published>
    <updated>2016-02-18T06:29:23.000Z</updated>
    <content type="html"><![CDATA[<p>总结一下项目中用到的工具和技术，以便以后的查看。</p>
<h1 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h1><p><a href="http://devhelpers.com/app/icon/resizer/" target="_blank" rel="external">在线通过1024 * 1024图片生成iPhone 1倍、2倍、3倍图片</a></p>
<h1 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h1><p><a href="http://blog.csdn.net/wzzvictory/article/details/18737437" target="_blank" rel="external">CocoaPods详解之—-使用篇</a></p>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/19178709" target="_blank" rel="external">CocoaPods详解之—-进阶篇</a></p>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/20067595" target="_blank" rel="external">CocoaPods详解之—-制作篇</a></p>
<p><a href="http://www.cocoachina.com/swift/20150630/12305.html" target="_blank" rel="external">怎样在Swift中使用CocoaPods</a></p>
<p><a href="http://www.cocoachina.com/swift/20150806/12831.html" target="_blank" rel="external">怎样在swift中创建一个CocoaPods</a></p>
<p><a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/" target="_blank" rel="external">使用Cocoapods创建私有podspec</a></p>
<h1 id="线程方案"><a href="#线程方案" class="headerlink" title="线程方案"></a>线程方案</h1><p>在iOS开发中其实有4套多线程方案，他们分别是：</p>
<p><strong> pthreads </strong></p>
<blockquote>
<p>POSIX线程（POSIX threads），简称pthreads，是线程的POSIX标准。该标准定义了创建和操作线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中都使用pthreads作为操作系统的线程。</p>
</blockquote>
<p><strong> NSThread </strong></p>
<p><strong> GCD</strong></p>
<p><strong> NSOperation&amp;NSOperationQueue </strong></p>
<p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<p><a href="http://blog.xcodev.com/archives/operation-queue-intro/" target="_blank" rel="external">并发编程之Operation Queue</a></p>
<p><a href="http://www.jianshu.com/p/0b0d9b1f1f19#" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></p>
<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><p><a href="http://www.jianshu.com/p/b35793b3749d" target="_blank" rel="external">RunLoop的简单介绍</a></p>
<h1 id="iOS8适配"><a href="#iOS8适配" class="headerlink" title="iOS8适配"></a>iOS8适配</h1><p><a href="http://www.jianshu.com/p/86f933850df8" target="_blank" rel="external">在iOS 8中使用UIAlertController</a></p>
<p><a href="http://www.cocoachina.com/industry/20140729/9269.html" target="_blank" rel="external">WWDC 2014 Session笔记 - iOS界面开发的大一统</a></p>
<p><a href="http://www.jianshu.com/p/f1208b5e42d9" target="_blank" rel="external">Alamofire网络库基础教程</a></p>
<h1 id="iOS9适配"><a href="#iOS9适配" class="headerlink" title="iOS9适配"></a>iOS9适配</h1><p><a href="http://www.liuchungui.com/blog/2015/10/11/ios9zhi-gua-pei-ats/" target="_blank" rel="external">iOS9之适配ATS</a></p>
<p><a href="http://www.cocoachina.com/ios/20150821/13140.html" target="_blank" rel="external">如何使用ATS提高应用的安全性</a></p>
<p><a href="http://www.cocoachina.com/ios/20150717/12650.html" target="_blank" rel="external">苹果新『应用通信安全』的理解和使用</a></p>
<p><a href="http://www.cocoachina.com/ios/20150820/13118.html" target="_blank" rel="external">UIStackView如何让你的开发更简单</a></p>
<p><a href="http://www.cnblogs.com/dsxniubility/p/4821184.html" target="_blank" rel="external">整理iOS9适配中出现的坑（图文）</a></p>
<h1 id="iOS性能调优"><a href="#iOS性能调优" class="headerlink" title="iOS性能调优"></a>iOS性能调优</h1><h2 id="Analyze静态分析"><a href="#Analyze静态分析" class="headerlink" title="Analyze静态分析"></a>Analyze静态分析</h2><p>逻辑错误、声明错误、api调用错误基本在编译时都会有警告，Analyze的主要的优势在于静态分析内存泄露及代码逻辑错误。</p>
<ol>
<li>逻辑错误：访问空指针或未初始化的变量等。</li>
<li>内存管理错误：如内存泄露等。</li>
<li>声明错误：从未使用过的变量。</li>
<li>api调用错误：未包含使用的库和框架。</li>
</ol>
<h2 id="Leaks内存泄露"><a href="#Leaks内存泄露" class="headerlink" title="Leaks内存泄露"></a>Leaks内存泄露</h2><p>把Snapshot Interval 间隔时间设置为10秒，勾选Automatic Snapshotting，Leaks会自动进行内存捕捉分析。在你怀疑有内存泄露的操作前和操作后点击Snapshot Now进行手动捕捉。</p>
<p>Leaked Object的表格中显示了内存泄露的类型、数量及内存空间。</p>
<p>点击具体的某个内存泄露对象，在右侧Detail窗口中会出现导致泄露可能的位置，其中黑色部分代表了最可能的位置。双击即可进入代码。</p>
<p><strong>开启了ARC并不是就不会存在内存问题，苹果有句名言：ARC is only for NSObject。</strong></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>1、正常编译没问题，在Profile 中就编译通不过。</p>
<p>选择Profile，将Build Configuration设置为Debug,这样在.pch文件中，#ifdef DEBUG 编译条件下定义的宏才生效。</p>
<p>2、Symbol Name 列的友好显示。</p>
<p>BuildOpthions–&gt;DebugInfomationFormat=DWARF with dSYM File</p>
<p>Xcode编译项目后，我们会看到一个同名的 dSYM 文件，dSYM 是保存 16 进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文件中，并且每次编译项目的时候都会生成一个新的 dSYM 文件。</p>
<h2 id="Allocation内存使用"><a href="#Allocation内存使用" class="headerlink" title="Allocation内存使用"></a>Allocation内存使用</h2><ol>
<li>在进入一个视图前或操作前，我们在Allocation面板左侧点击Mark Generation，这时候会产生Generation A节点，显示内存当前的情况。</li>
<li>在进入视图后再点一次Mark Generation。</li>
<li>在视图退出后再点一次Mark</li>
</ol>
<p>这样三次产生的 Generation分别记录了进入前、进入后、关闭后，在最后一个Generation应该内存被合理释放，否则就代表了在这个视图或操作中有泄漏或不合理的地方。</p>
<h2 id="Zombies僵尸对象（EXC-BAD-ACCESS）"><a href="#Zombies僵尸对象（EXC-BAD-ACCESS）" class="headerlink" title="Zombies僵尸对象（EXC_BAD_ACCESS）"></a>Zombies僵尸对象（EXC_BAD_ACCESS）</h2><p>用于查找那些被过度释放的僵尸对象（overreleased objects）。</p>
<ol>
<li>启动Instruments，选择Zombies。</li>
<li>对之前产生EXC_BAD_ACCESS的测试用例重新运行，直到程序崩溃，如果发生EXC_BAD_ACCESS错误，会出现对应界面。</li>
<li>通过滑动箭头来查看错误细节，例如可以看到该对象的内存操作过程，如malloc、autorelease、retain、release等操作。</li>
<li>查看底部的详细历史，选择相应的行可以定位到相应的代码，找出产生错误的代码</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://yyny.me/ios/一次TableView性能优化经历/" target="_blank" rel="external">一次TableView性能优化经历</a></p>
<p><a href="http://www.cnblogs.com/ym123/category/668845.html" target="_blank" rel="external">iOS性能调优系列</a></p>
<h1 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h1><p>deliver用于上传应用的二进制代码、应用截屏和原数据到应用商店</p>
<p>snapshot可以自动化iOS应用在每个设备上的本地化截屏过程</p>
<p>frameit用于在应用截屏外添加设备框架</p>
<p>PEM可以自动化地生成和更新应用推送通知描述文件</p>
<p>sigh可以生成并下载开发者的应用商店配置文件</p>
<p><a href="http://www.infoq.com/cn/news/2015/01/fastlane-ios-continuous-deploy" target="_blank" rel="external">Fastlane为iOS带来持续部署</a></p>
<p><a href="http://www.jianshu.com/users/384f80cdc57b/latest_articles" target="_blank" rel="external">马建成系列</a></p>
<h1 id="stackoverflow"><a href="#stackoverflow" class="headerlink" title="stackoverflow"></a>stackoverflow</h1><p>stackoverflow在中国被墙了，不能登陆进行答题和收藏，所以在此记录工作中有所帮助的问题！根据链家基本上就能看出大概的问题了，以此来纪念那些被解决的问题！</p>
<p><a href="http://stackoverflow.com/questions/26865132/strings-in-switch-statements-string-does-not-conform-to-protocol-intervaltyp#" target="_blank" rel="external">http://stackoverflow.com/questions/26865132/strings-in-switch-statements-string-does-not-conform-to-protocol-intervaltyp#</a></p>
<p><a href="http://stackoverflow.com/questions/25951195/swift-print-vs-println-vs-nslog#" target="_blank" rel="external">http://stackoverflow.com/questions/25951195/swift-print-vs-println-vs-nslog#</a></p>
<p><a href="http://stackoverflow.com/questions/28427458/ios-webrtc-library-supporting-both-armv7-arm64" target="_blank" rel="external">http://stackoverflow.com/questions/28427458/ios-webrtc-library-supporting-both-armv7-arm64</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="http://www.jianshu.com/p/802f52c5f13a" target="_blank" rel="external">如何利用搜索框</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_4caf02490102vr4s.html" target="_blank" rel="external">Xcode各版本官方下载及百度云盘下载, Mac和IOS及Xcode版本历史.</a></p>
]]></content>
    <summary type="html">
    <![CDATA[项目中用到的工具和技术]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS网络相关总结]]></title>
    <link href="http://www.zhuli8.com/2015/09/06/iOS%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/"/>
    <id>http://www.zhuli8.com/2015/09/06/iOS网络相关总结/</id>
    <published>2015-09-06T05:49:17.000Z</published>
    <updated>2015-10-30T05:22:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="HTTP通信过程"><a href="#HTTP通信过程" class="headerlink" title="HTTP通信过程"></a>HTTP通信过程</h1><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>HTTP协议规定，一个完整的由 <strong>客户端</strong> 发给 <strong>服务器</strong> 的HTTP请求中包含以下内容。</p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>包含了 <code>请求方法</code>、<code>请求资源路径</code>、<code>HTTP协议版本</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /ZLServer/resources/images/<span class="number">1.</span>jpg HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>包含了<code>对客户端的环境描述</code>、<code>客户端请求的主机地址</code>等信息，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Host:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>:<span class="number">8080</span> 	<span class="comment">// 客户端想访问的服务器主机地址</span></span><br><span class="line">User-<span class="string">Agent:</span> Mozilla<span class="regexp">/5.0 (Macintosh; Intel Mac OS X 10.9) Firefox/</span><span class="number">30.0</span> </span><br><span class="line">							<span class="comment">// 客户端的类型，客户端的软件环境</span></span><br><span class="line"><span class="string">Accept:</span> text<span class="regexp">/html, */</span>* 		<span class="comment">// 客户端所能接收的数据类型</span></span><br><span class="line">Accept-<span class="string">Language:</span> zh-cn 		<span class="comment">// 客户端的语言环境</span></span><br><span class="line">Accept-<span class="string">Encoding:</span> gzip 		<span class="comment">// 客户端支持的数据压缩格式</span></span><br></pre></td></tr></table></figure>
<h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>客户端发给服务器的具体数据，比如文件数据。</p>
<h3 id="创建GET请求"><a href="#创建GET请求" class="headerlink" title="创建GET请求"></a>创建GET请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *urlStr = [<span class="string">@"http://192.168.1.102:8080/MJServer/login?username=123&amp;pwd=123"</span> stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlStr];</span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br></pre></td></tr></table></figure>
<h3 id="创建POST请求"><a href="#创建POST请求" class="headerlink" title="创建POST请求"></a>创建POST请求</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *urlStr = @<span class="string">"http://192.168.1.102:8080/MJServer/login"</span>;</span><br><span class="line">NSURL *url = <span class="string">[NSURL URLWithString:urlStr]</span>;</span><br><span class="line">NSMutableURLRequest *request = <span class="string">[NSMutableURLRequest requestWithURL:url]</span>;</span><br><span class="line">request.HTTPMethod = @<span class="string">"<span class="keyword">POST</span>"</span>;</span><br><span class="line">// 请求体</span><br><span class="line">NSString *bodyStr = @<span class="string">"username=123&amp;pwd=123"</span>;</span><br><span class="line">request.HTTPBody = <span class="string">[bodyStr dataUsingEncoding:NSUTF8StringEncoding]</span>;</span><br></pre></td></tr></table></figure>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p><strong>客户端</strong> 向 <strong>服务器</strong> 发送请求，<strong>服务器 </strong>应当做出响应，即返回数据给 <strong>客户端</strong>。</p>
<p>HTTP协议规定，一个完整的HTTP响应中包含以下内容：</p>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>包含了<code>HTTP协议版本</code>、<code>状态码</code>、<code>状态英文名称</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>包含了<code>对服务器的描述</code>、<code>对返回数据的描述</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache-Coyote/<span class="number">1.1</span> 		    <span class="comment">// 服务器的类型</span></span><br><span class="line">Content-Type: image/jpeg 		    <span class="comment">// 返回数据的类型</span></span><br><span class="line">Content-Length: <span class="number">56811</span> 		        <span class="comment">// 返回数据的长度</span></span><br><span class="line">Date: Mon, <span class="number">23</span> Jun <span class="number">2014</span> <span class="number">12</span>:<span class="number">54</span>:<span class="number">52</span> GMT	<span class="comment">// 响应的时间</span></span><br></pre></td></tr></table></figure>
<h3 id="实体内容"><a href="#实体内容" class="headerlink" title="实体内容"></a>实体内容</h3><p><strong>服务器</strong> 返回给 <strong>客户端</strong> 的具体数据，比如文件数据。</p>
<h1 id="HTTP请求方案"><a href="#HTTP请求方案" class="headerlink" title="HTTP请求方案"></a>HTTP请求方案</h1><p>在iOS中，常见的发送HTTP请求方案有苹果原生和第三方框架。</p>
<h2 id="苹果原生（自带）"><a href="#苹果原生（自带）" class="headerlink" title="苹果原生（自带）"></a>苹果原生（自带）</h2><h3 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h3><p>用法简单，最古老最经典最直接的一种方案。</p>
<p>负责发送请求，建立客户端和服务器的连接。发送NSURLRequest到数据给服务器，并收集来自服务器的响应数据。</p>
<h4 id="NSURL"><a href="#NSURL" class="headerlink" title="NSURL"></a>NSURL</h4><p>请求地址。</p>
<h4 id="NSURLRequest"><a href="#NSURLRequest" class="headerlink" title="NSURLRequest"></a>NSURLRequest</h4><p>一个NSURLRequest对象就代表一个请求，它包含的信息有：</p>
<pre><code>一个NSURL对象
请求方法、请求头、请求体
请求超时
... ...
</code></pre><h4 id="NSMutableURLRequest"><a href="#NSMutableURLRequest" class="headerlink" title="NSMutableURLRequest"></a>NSMutableURLRequest</h4><p>NSURLRequest的子类。</p>
<p><strong>常用方法</strong></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">设置请求超时等待时间（超过这个时间就算超时，请求失败）</span><br><span class="line">- (<span class="type">void</span>)setTimeoutInterval:(<span class="type">NSTimeInterval</span>)seconds;</span><br><span class="line"></span><br><span class="line">设置请求方法（比如<span class="type">GET</span>和<span class="type">POST</span>）</span><br><span class="line">- (<span class="type">void</span>)setHTTPMethod:(<span class="type">NSString</span> *)<span class="keyword">method</span>;</span><br><span class="line"></span><br><span class="line">设置请求体</span><br><span class="line">- (<span class="type">void</span>)setHTTPBody:(<span class="type">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line">设置请求头</span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">NSString</span> *)value forHTTPHeaderField:(<span class="type">NSString</span> *)field;</span><br></pre></td></tr></table></figure>
<h4 id="NSURLConnection的使用步骤"><a href="#NSURLConnection的使用步骤" class="headerlink" title="NSURLConnection的使用步骤"></a>NSURLConnection的使用步骤</h4><p>使用NSURLConnection发送请求到步骤很简单，创建一个NSURL对象，设置请求路径；传入NSURL创建一个NSURLRequest对象，设置请求头和请求体；使用NSURLConnection发送NSURLRequest。</p>
<p>NSURLConnection常见的发送请求方法有以下几种：</p>
<h5 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (NSData <span class="keyword">*</span>)sendSynchronousRequest:(NSURLRequest <span class="keyword">*</span>)request returningResponse:(NSURLResponse <span class="keyword">*</span><span class="keyword">*</span>)response error:(NSError <span class="keyword">*</span><span class="keyword">*</span>)error;</span><br></pre></td></tr></table></figure>
<h5 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h5><p>根据对服务器返回数据的处理方式掉不同，又可以分为2种：</p>
<p><strong>block回调</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span>*) request queue:(<span class="built_in">NSOperationQueue</span>*) queue completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>* response, <span class="built_in">NSData</span>* data, <span class="built_in">NSError</span>* connectionError)) handler;</span><br></pre></td></tr></table></figure>
<p><strong>代理</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request delegate:(<span class="keyword">id</span>)delegate;</span><br><span class="line">+ (<span class="built_in">NSURLConnection</span>*)connectionWithRequest:(<span class="built_in">NSURLRequest</span> *)request delegate:(<span class="keyword">id</span>)delegate;</span><br><span class="line">- (<span class="keyword">id</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request delegate:(<span class="keyword">id</span>)delegate startImmediately:(<span class="built_in">BOOL</span>)startImmediately;<span class="comment">//在startImmediately = NO的情况下，需要调用start方法开始发送请求</span></span><br><span class="line">- (<span class="keyword">void</span>)start;</span><br></pre></td></tr></table></figure>
<pre><code>成为NSURLConnection的代理，最好遵守NSURLConnectionDataDelegate协议
</code></pre><h5 id="NSURLConnectionDataDelegate协议中的代理方法"><a href="#NSURLConnectionDataDelegate协议中的代理方法" class="headerlink" title="NSURLConnectionDataDelegate协议中的代理方法"></a>NSURLConnectionDataDelegate协议中的代理方法</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">开始接收到服务器的响应时调用</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connection</span>:<span class="value">(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response</span></span>;</span><br><span class="line"></span><br><span class="line">接收到服务器返回的数据时调用（服务器返回的数据比较大时会调用多次）</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connection</span>:<span class="value">(NSURLConnection *)connection didReceiveData:(NSData *)data</span></span>;</span><br><span class="line"></span><br><span class="line">服务器返回的数据完全接收完毕后调用</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connectionDidFinishLoading</span>:<span class="value">(NSURLConnection *)connection</span></span>;</span><br><span class="line"></span><br><span class="line">请求出错时调用（比如请求超时）</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connection</span>:<span class="value">(NSURLConnection *)connection didFailWithError:(NSError *)error</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h3><p>iOS7新出的技术，功能比NSURLConnection更加强大。</p>
<h3 id="CFNetwork"><a href="#CFNetwork" class="headerlink" title="CFNetwork"></a>CFNetwork</h3><p>NSURLConnection和NSURLSession的底层，纯C语言。</p>
<h2 id="第三方框架"><a href="#第三方框架" class="headerlink" title="第三方框架"></a>第三方框架</h2><h3 id="ASIHttpRequest"><a href="#ASIHttpRequest" class="headerlink" title="ASIHttpRequest"></a>ASIHttpRequest</h3><p>外号“HTTP终结者”，功能极其强大，可惜早已停止更新。</p>
<h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p>简单易用，提供了基本够用的常用功能，维护和使用者多。</p>
<h3 id="MKNetworkKit"><a href="#MKNetworkKit" class="headerlink" title="MKNetworkKit"></a>MKNetworkKit</h3><p>简单易用，维护和使用者少。</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON是一种轻量级的数据格式，一般用于数据交互。服务器返回给客户端的数据，一般都是JSON格式或者XML格式（文件下载除外）。</p>
<h2 id="JSON解析方案"><a href="#JSON解析方案" class="headerlink" title="JSON解析方案"></a>JSON解析方案</h2><p>在iOS中，JSON的常见解析方案有4种</p>
<p>第三方框架：<code>JSONKit</code>、<code>SBJson</code>、<code>TouchJSON</code>（性能从左到右越差）</p>
<p>苹果原生（自带）：<code>NSJSONSerialization</code>（性能最好）</p>
<h3 id="NSJSONSerialization的常见方法"><a href="#NSJSONSerialization的常见方法" class="headerlink" title="NSJSONSerialization的常见方法"></a>NSJSONSerialization的常见方法</h3><p><strong>JSON数据 –&gt; OC对象</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (id)<span class="type">JSONObjectWithData</span>:(<span class="type">NSData</span> *)<span class="typedef"><span class="keyword">data</span> options:<span class="container">(<span class="type">NSJSONReadingOptions</span>)</span>opt error:<span class="container">(<span class="type">NSError</span> **)</span>error;</span></span><br></pre></td></tr></table></figure>
<p><strong>OC对象 –&gt; JSON数据</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSData</span> *)dataWithJSONObject:(<span class="keyword">id</span>)obj options:(<span class="built_in">NSJSONWritingOptions</span>)opt error:(<span class="built_in">NSError</span> **)error;</span><br></pre></td></tr></table></figure>
<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>全称是Extensible Markup Language，译作“可扩展标记语言”，跟JSON一样，也是常用的一种用于交互的数据格式，一般也叫XML文档（XML Document）。</p>
<h2 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h2><p>一个常见的XML文档一般由<code>文档声明</code>、<code>元素（Element）</code>、<code>属性（Attribute）</code>三部分组成。</p>
<h3 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h3><p>在XML文档的最前面，必须编写一个文档声明，用来声明XML文档的类型。</p>
<p><strong>最简单的声明</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" ?&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>用encoding属性说明文档的字符编码</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="元素（Element）"><a href="#元素（Element）" class="headerlink" title="元素（Element）"></a>元素（Element）</h3><p>一个元素包括了开始标签和结束标签，规范的XML文档最多只有1个根元素，其他元素都是根元素的子孙元素。</p>
<p>XML中的所有空格和换行，都会当做具体内容处理。</p>
<h3 id="属性（Attribute）"><a href="#属性（Attribute）" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h3><p>一个元素可以拥有多个属性，属性值必须用 双引号”” 或者 单引号’’ 括住。</p>
<p>实际上，属性表示的信息也可以用子元素来表示。</p>
<h2 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h2><p>XML的解析方式有2种：</p>
<pre><code>DOM：一次性将整个XML文档加载进内存，比较适合解析小文件
SAX：从根元素开始，按顺序一个元素一个元素往下解析，比较适合解析大文件
</code></pre><p>在iOS中，解析XML的手段有很多种。</p>
<h3 id="苹果原生"><a href="#苹果原生" class="headerlink" title="苹果原生"></a>苹果原生</h3><p>NSXMLParse：SAX方式解析，使用简单。</p>
<p>NSXMLParser采取的是SAX方式解析，特点是事件驱动，下面情况都会通知代理</p>
<pre><code>当扫描到文档（Document）的开始与结束
当扫描到元素（Element）的开始与结束
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用步骤</span><br><span class="line"><span class="comment">// 传入XML数据，创建解析器</span></span><br><span class="line"><span class="built_in">NSXMLParser</span> *parser = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:data];</span><br><span class="line"><span class="comment">// 设置代理，监听解析过程</span></span><br><span class="line">parser<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">// 开始解析</span></span><br><span class="line">[parser parse];</span><br></pre></td></tr></table></figure>
<p><strong>NSXMLParserDelegate</strong></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当扫描到文档的开始时调用（开始解析）</span><br><span class="line"><span class="pp">- <span class="params">(void)</span>parserDidStartDocument:<span class="params">(<span class="variable">NSXMLParser</span> *)</span>parser</span><br><span class="line"></span><br><span class="line">当扫描到文档的结束时调用（解析完毕）</span><br><span class="line">- <span class="params">(void)</span>parserDidEndDocument:<span class="params">(<span class="variable">NSXMLParser</span> *)</span>parser</span><br><span class="line"></span><br><span class="line">当扫描到元素的开始时调用（attributeDict存放着元素的属性）</span><br><span class="line">- <span class="params">(void)</span>parser:<span class="params">(<span class="variable">NSXMLParser</span> *)</span>parser didStartElement:<span class="params">(<span class="variable">NSString</span> *)</span>elementName namespaceURI:<span class="params">(<span class="variable">NSString</span> *)</span>namespaceURI qualifiedName:<span class="params">(<span class="variable">NSString</span> *)</span>qName attributes:<span class="params">(<span class="variable">NSDictionary</span> *)</span>attributeDict</span><br><span class="line"></span><br><span class="line">当扫描到元素的结束时调用</span><br><span class="line">- <span class="params">(void)</span>parser:<span class="params">(<span class="variable">NSXMLParser</span> *)</span>parser didEndElement:<span class="params">(<span class="variable">NSString</span> *)</span>elementName namespaceURI:<span class="params">(<span class="variable">NSString</span> *)</span>namespaceURI qualifiedName:<span class="params">(<span class="variable">NSString</span> *)</span>qName</span></span><br></pre></td></tr></table></figure>
<h3 id="第三方框架-1"><a href="#第三方框架-1" class="headerlink" title="第三方框架"></a>第三方框架</h3><p>libxml2：纯C语言，默认包含在iOS SDK中，同时支持DOM和SAX方式解析</p>
<p>GDataXML：DOM方式解析，由Google开发，基于libxml2</p>
<p><strong>GDataXML中常用的类</strong></p>
<pre><code>GDataXMLDocument：代表整个XML文档
GDataXMLElement：代表文档中的每个元素
使用attributeForName:方法可以获得属性值
</code></pre><p><strong>XML解析方式的选择建议</strong></p>
<pre><code>大文件：NSXMLParser、libxml2
小文件：GDataXML
</code></pre><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="http://objccn.io/issue-5-4/" target="_blank" rel="external">从 NSURLConnection 到 NSURLSession</a></p>
<p><a href="http://blog.shiqichan.com/using-afnetworking-sdwebimage-and-ohhttpstubs/" target="_blank" rel="external">使用AFNetworking, SDWebimage和OHHTTPStubs</a></p>
]]></content>
    <summary type="html">
    <![CDATA[iOS网络相关总结]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式总结]]></title>
    <link href="http://www.zhuli8.com/2015/08/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://www.zhuli8.com/2015/08/30/设计模式总结/</id>
    <published>2015-08-30T06:08:47.000Z</published>
    <updated>2015-09-11T06:13:22.000Z</updated>
    <content type="html"><![CDATA[<p>开始前请先看<a href="https://github.com/zhuli8com/DesignPattern.git" target="_blank" rel="external">源码Demo</a>。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在软件设计领域，设计模式是对通用问题的可复用的解决方案。设计模式是一系列帮你写出更可理解和复用代码的模板，设计模式帮你创建松耦合的代码以便你不需要费多大力就可以改变或者替换代码中的组件。</p>
<p>创建型：单利（单态）和 抽象工厂</p>
<p>结构型：模型-视图-控制器、装饰器、适配器、外观（门面)和组合模式</p>
<p>行为型：观察者、备忘录、责任链和命令模式</p>
<h1 id="MVC（模型-视图-控制器）"><a href="#MVC（模型-视图-控制器）" class="headerlink" title="MVC（模型-视图-控制器）"></a>MVC（模型-视图-控制器）</h1><p>模型-视图-控制器（MVC) 是Cocoa的构建块之一，毫无疑问它是使用最频繁的设计模式。它根据通用的角色去划分类，这样就使得类的职责可以根据角色清晰的划分开来。</p>
<blockquote>
<p>Model:模型保存应用程序的数据，定义了怎么去操作它。例如在本应用中模型就是Album类。</p>
<p>View:  视图是模型的可视化表示以及用户交互的控件；基本上来说，所有的UIView对象以及它的子类都属于视图。在本应用中AlbumView代表了视图。</p>
<p>Controller:控制器是一个协调所有工作的中介者（Mediator）。它访问模型中的数据并在视图中展示它们，同时它们还监听事件和根据需要操作数据。例如在本应用中ViewController。</p>
</blockquote>
<p>模型会把任何数据的变更通知控制器，然后控制器更新视图数据。视图对象通知控制器用户的操作，控制器要么根据需要来更新模型，要么检索任何被请求的数据。</p>
<p>你可能在想为什么不能仅仅使用控制器，在一个类中实现视图和模型，这样貌似更加容易? </p>
<p>所有的这些都归结于代码关注点分离以及复用。在理想的状态下，视图应该和模型完全的分离。如果视图不依赖某个实际的模型，那么视图就可以被复用来展示不同模型的数据。</p>
<p>举个例子来说，如果将来你打算加入电影或者书籍到你的资料库中，你仍然可以使用同样的AlbumView去显示电影和书籍数据。更进一步来说，如果你想创建一个新的与专辑有关联的工程，你可以很简单的复用Album类，因为它不依赖任何视图。这就是MVC的强大之处。</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例设计模式确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点。它通常采用懒加载的方式在第一次用到实例的时候再去创建它。</p>
<p>苹果大量使用了此模式。例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[NSUserDefaults standardUserDefaults]</span><br><span class="line">[UIApplication sharedApplication]</span><br><span class="line">[UIScreen mainScreen]</span><br><span class="line">[NSFileManager defaultManager]</span><br></pre></td></tr></table></figure>
<p>有一些情况下，只有一个实例显得非常合理。举例来说，你不需要有多个Logger的实例，除非你想去写多个日志文件。或者一个全局的配置处理类：实现线程安全的方式访问共享实例是容易的，比如一个配置文件，有好多个类同时修改这个文件。</p>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观模式针对复杂的子系统提供了单一的接口，不需要暴漏一系列的类和API给用户，你仅仅暴漏一个简单统一的API。这个API的使用者完全不需要关心背后的复杂性。这个模式非常适合有一大堆很难使用或者理解的类的情况。外观模式解耦了使用系统的代码和需要隐藏的接口和实现类。它也降低了外部代码对内部子系统的依赖性。当隐藏在外观之后的类很容易发生变化的时候，此模式就很有用了，因为当背后的类发生变化的时候，外观类始终保持了同样的API。</p>
<p>本应用中用PersistencyManager本地保存专辑数据，使用HTTPClient处理远程连接，工程中的其它类暂时与本次实现的逻辑无关。</p>
<p>为了实现这个模式，只有LibraryAPI应该保存PersistencyManager和HTTPClient的实例，然后LibraryAPI将暴漏一个简单的API去访问这些服务。LibraryAPI将暴漏给其它代码，但是它隐藏了HTTPClient和PersistencyManager的复杂性。</p>
<h1 id="装饰器（Decorator）模式"><a href="#装饰器（Decorator）模式" class="headerlink" title="装饰器（Decorator）模式"></a>装饰器（Decorator）模式</h1><p>装饰器模式在不修改原来代码的情况下动态的给对象增加新的行为和职责，它通过一个对象包装被装饰对象的方法来修改类的行为，这种方法可以做为子类化的一种替代方法。<br>在Objective-C中，存在两种非常常见的实现:Category(类别）和Delegation（委托）。</p>
<h2 id="Category-类别"><a href="#Category-类别" class="headerlink" title="Category(类别)"></a>Category(类别)</h2><p>Category(类别)是一种不需要子类化就可以让你能动态的给已经存在的类增加方法的强有力的机制。新增的方法是在编译期增加的，这些方法执行的时候和被扩展的类的其它方法是一样的。它可能与装饰器设计模式的定义稍微有点不同，因为Category(类别)不会保存被扩展类的引用。</p>
<p>除了可以扩展你自己的类以外，还可以给Cocoa自己的类增加方法。</p>
<p>本应用中需要让Album(专辑)对象显示在一个表格视图（TableView）中：专辑的标题从何而来？因为专辑是模型对象，它本身不需要关心你如何显示它的数据。你需要增加一些代码去扩展专辑类的行为，但是不需要直接修改专辑类。创建一个专辑类扩展的类别，定义一个新的方法，这个方法会返回能很容易和UITableViews使用的数据结构。 </p>
<h2 id="Delegation-委托"><a href="#Delegation-委托" class="headerlink" title="Delegation(委托)"></a>Delegation(委托)</h2><p>当你使用UITableView的时候，你必须要实现tableView:numberOfRowsInSection:方法。<br>你不可能让UITableView知道它需要在每个区域显示多少行，因为这些是应用特定的数据。因此计算每个区域需要显示多少行的职责就给了UITableView的委托。这就让UITableView类独立于它要显示的数据。</p>
<p>UITableView的职责就是显示一个表格视图。然而最终它需要一些它自身没有的信息。那么它就求助于它的委托，通过发送消息给委托来获取信息。在Objective-C实现委托模式的时候，一个类可以通过协议（Protocol）来声明可选以及必要的方法。</p>
<p>这个是一个重要的模式。苹果在UIKit类中大量使用了它：UITableView, UITextView, UITextField, UIWebView, UIAlert, UIActionSheet, UICollectionView, UIPickerView,UIGestureRecognizer, UIScrollView等等等。</p>
<h1 id="适配器（Adapter）模式"><a href="#适配器（Adapter）模式" class="headerlink" title="适配器（Adapter）模式"></a>适配器（Adapter）模式</h1><p>适配器可以让一些接口不兼容的类一起工作。它包装一个对象然后暴漏一个标准的交互接口。</p>
<p>苹果通过一个稍微不同的方式来实现它-苹果使用了协议的方式来实现。你可能已经熟悉UITableViewDelegate, UIScrollViewDelegate, NSCoding 和 NSCopying协议。举个例子，使用NSCopying协议，任何类都可以提供一个标准的copy方法。</p>
<h1 id="观察者（Observer）模式"><a href="#观察者（Observer）模式" class="headerlink" title="观察者（Observer）模式"></a>观察者（Observer）模式</h1><p>在观察者模式中，一个对象任何状态的变更都会通知另外的对改变感兴趣的对象。这些对象之间不需要知道彼此的存在，这其实是一种松耦合的设计。当某个属性变化的时候，我们通常使用这个模式去通知其它对象。</p>
<p>此模式的通用实现中，观察者注册自己感兴趣的其它对象的状态变更事件。当状态发生变化的时候，所有的观察者都会得到通知。苹果的推送通知（Push Notification）就是一个此模式的例子。</p>
<p>如果你要遵从MVC模式的概念，你需要让模型对象和视图对象在不相互直接引用的情况下通信。这正是观察者模式的用武之地。</p>
<p>Cocoa通过通知（Notifications）和Key-Value Observing(KVO)来实现观察者模式。</p>
<h2 id="通知（Notifications）"><a href="#通知（Notifications）" class="headerlink" title="通知（Notifications）"></a>通知（Notifications）</h2><p>不要和远程推送以及本地通知所混淆，通知是一种基于订阅-发布模式的模型，它让发布者可以给订阅者发送消息，并且发布者不需要对订阅者有任何的了解。</p>
<p>通知在苹果官方被大量的使用。举例来说，当键盘弹出或者隐藏的时候，系统会独立发送UIKeyboardWillShowNotification/UIKeyboardWillHideNotification通知。当你的应用进入后台运行的时候，系统会发送一个UIApplicationDidEnterBackgroundNotification通知。</p>
<h2 id="Key-Value-Observing-KVO-模式"><a href="#Key-Value-Observing-KVO-模式" class="headerlink" title="Key-Value Observing(KVO)模式"></a>Key-Value Observing(KVO)模式</h2><p>在KVO中，一个对象可以要求在它自身或者其它对象的属性发送变化的时候得到通知。</p>
<p>KVO机制让对象可以感知到属性的变化。在本例中，你可以使用KVO去观察UIImageView的image属性的变化。</p>
<h1 id="备忘录（Memento）模式"><a href="#备忘录（Memento）模式" class="headerlink" title="备忘录（Memento）模式"></a>备忘录（Memento）模式</h1><p>备忘录模式快照对象的内部状态并将其保存到外部。换句话说，它将状态保存到某处，过会你可以不破坏封装的情况下恢复对象的状态，也就是说原来对象中的私有数据仍然是私有的。</p>
<h2 id="归档（Archiving）"><a href="#归档（Archiving）" class="headerlink" title="归档（Archiving）"></a>归档（Archiving）</h2><p>归档是苹果对于备忘录模式的特定实现之一。这种机制可以转换一个对象到一个可保存的数据流中，过会可以在不暴漏私有属性给外部的情况下重建它们。</p>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令模式将一个请求封装为一个对象。封装以后的请求会比原生的请求更加灵活，因为这些封装后的请求可以在多个对象之间传递，存储以便以后使用，还可以动态的修改，或者放进一个队列中。苹果通过Target-Action机制和Invocation实现命令模式。</p>
<p>你可以通过苹果的官方在线文档阅读更多关于Target-Action的内容，至于Invocation，它采用了NSInvocation类，这个类包含了一个目标对象，方法选择器，以及一些参数。这个对象可以动态的修改并且可以按需执行。实践中它是一个命令模式很好的例子。它解耦了发送对象和接受对象，并且可以保存一个或者多个请求。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://xmuzyq.iteye.com/blog/1942376" target="_blank" rel="external">IOS设计模式之一（MVC模式，单例模式）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[在软件设计领域，设计模式是对通用问题的可复用的解决方案。设计模式是一系列帮你写出更可理解和复用代码的模板，设计模式帮你创建松耦合的代码以便你不需要费多大力就可以改变或者替换代码中的组件。]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="设计模式" scheme="http://www.zhuli8.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://www.zhuli8.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shell编程实践]]></title>
    <link href="http://www.zhuli8.com/2015/08/23/Shell%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.zhuli8.com/2015/08/23/Shell编程实践/</id>
    <published>2015-08-23T08:15:35.000Z</published>
    <updated>2015-09-07T08:21:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>简单的说Shell就是一个包含若干行Shell或者Linux命令的文件。对于一次编写，多次使用的大量命令，就可以使用单独的文件保存下来，以便日后使用。</p>
<p>通常Shell脚本以.sh为后缀。如果要执行该脚本，必须先使其可执行</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chmod</span> +<span class="keyword">x</span> filename</span><br></pre></td></tr></table></figure>
<p>此后在该脚本所在目录下，输入./filename即可执行该脚本。</p>
<p>还有一种更简单的方法就是直接在终端用 <strong>sh</strong> 指令来执行。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sh</span> filename</span><br></pre></td></tr></table></figure>
<p>最近打包webRTC库时重复的工作和容易出错的机会让我想到了Shell脚本。基本需求就是把C++工程师那边的arm64、armv7、i386三个架构的zip包（webRTC静态库包的压缩文件）打成一个.a静态库。</p>
<p>下面就是这个过程中解决的两个版本。</p>
<h1 id="第一个版本"><a href="#第一个版本" class="headerlink" title="第一个版本"></a>第一个版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/usr/sh</span></span><br><span class="line"><span class="comment"># arm64包的名称</span></span><br><span class="line">arm64=Release-iphoneos</span><br><span class="line"><span class="comment"># armv7包的名称</span></span><br><span class="line">armv7=Release-iphoneos</span><br><span class="line"><span class="comment"># i386包的名称</span></span><br><span class="line">i386=Debug-iphonesimulator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩该目录下的$arm64.zip文件到该目录下的$arm64文件夹下,不提示的情况下覆盖文件</span></span><br><span class="line">unzip -o <span class="operator">-d</span> arm64/<span class="variable">$arm64</span>  arm64/<span class="variable">$arm64</span></span><br><span class="line"><span class="comment"># 解压缩该目录下的$armv7.zip文件到该目录下的$armv7文件夹下,不提示的情况下覆盖文件</span></span><br><span class="line">unzip -o <span class="operator">-d</span> armv7/<span class="variable">$armv7</span>  armv7/<span class="variable">$armv7</span></span><br><span class="line"><span class="comment"># 解压缩该目录下的$i386.zip文件到该目录下的$i386文件夹下,不提示的情况下覆盖文件</span></span><br><span class="line">unzip -o <span class="operator">-d</span> i386/<span class="variable">$i386</span>  i386/<span class="variable">$i386</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"解压缩成功"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上面的两个静态库移到其上一个目录</span></span><br><span class="line">mv arm64/<span class="variable">$arm64</span>/<span class="variable">$arm64</span>/<span class="variable">$capture</span> arm64/<span class="variable">$arm64</span>/<span class="variable">$arm64</span>/<span class="variable">$render</span> arm64/<span class="variable">$arm64</span>/</span><br><span class="line">mv armv7/<span class="variable">$armv7</span>/<span class="variable">$armv7</span>/<span class="variable">$capture</span> armv7/<span class="variable">$armv7</span>/<span class="variable">$armv7</span>/<span class="variable">$render</span> armv7/<span class="variable">$armv7</span>/</span><br><span class="line">mv i386/<span class="variable">$i386</span>/<span class="variable">$i386</span>/<span class="variable">$capture</span> i386/<span class="variable">$i386</span>/<span class="variable">$i386</span>/<span class="variable">$render</span> i386/<span class="variable">$i386</span>/</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"成功移动两个特殊的静态库"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并arm64/$arm64/$arm64/下所有*.a构建arm64为libWebRTC-arm64.a</span></span><br><span class="line">libtool -static -o arm64/<span class="variable">$arm64</span>/libWebRTC-arm64.a arm64/<span class="variable">$arm64</span>/<span class="variable">$arm64</span>/*.a</span><br><span class="line"><span class="comment"># 合并armv7/$armv7/$armv7/下所有*.a构建armv7为libWebRTC-armv7.a</span></span><br><span class="line">libtool -static -o armv7/<span class="variable">$armv7</span>/libWebRTC-armv7.a armv7/<span class="variable">$armv7</span>/<span class="variable">$armv7</span>/*.a</span><br><span class="line"><span class="comment"># 合并i386/$i386/$i386/下所有*.a构建i386为libWebRTC-i386.a</span></span><br><span class="line">libtool -static -o i386/<span class="variable">$i386</span>/libWebRTC-i386.a i386/<span class="variable">$i386</span>/<span class="variable">$i386</span>/*.a</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"成功构建libWebRTC-arm64.a、libWebRTC-armv7.a、libWebRTC-i386.a"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"正在执行最后的合成操作，请稍后..."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建支持arm64、armv7、i386的libWebRTC</span></span><br><span class="line">lipo -create arm64/<span class="variable">$arm64</span>/<span class="variable">$capture</span> armv7/<span class="variable">$armv7</span>/<span class="variable">$capture</span> i386/<span class="variable">$i386</span>/<span class="variable">$capture</span> -output libVideoCapture.a</span><br><span class="line">lipo -create arm64/<span class="variable">$arm64</span>/<span class="variable">$render</span> armv7/<span class="variable">$armv7</span>/<span class="variable">$render</span> i386/<span class="variable">$i386</span>/<span class="variable">$render</span> -output libVideoRender.a</span><br><span class="line">lipo -create arm64/<span class="variable">$arm64</span>/libWebRTC-arm64.a armv7/<span class="variable">$armv7</span>/libWebRTC-armv7.a i386/<span class="variable">$i386</span>/libWebRTC-i386.a -output libWebRTC.a</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"成功创建支持arm64、armv7、i386的libWebRTC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理中间垃圾文件(把子目录及子目录中所有档案删除,并且不用一一确认)</span></span><br><span class="line">rm -rf arm64/<span class="variable">$arm64</span></span><br><span class="line">rm -rf armv7/<span class="variable">$armv7</span></span><br><span class="line">rm -rf i386/<span class="variable">$i386</span></span><br></pre></td></tr></table></figure>
<h1 id="第二个版本"><a href="#第二个版本" class="headerlink" title="第二个版本"></a>第二个版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arm64包的名称</span></span><br><span class="line">arm64=Release-iphoneos</span><br><span class="line"><span class="comment"># armv7包的名称</span></span><br><span class="line">armv7=Release-iphoneos</span><br><span class="line"><span class="comment"># i386包的名称</span></span><br><span class="line">i386=Debug-iphonesimulator</span><br><span class="line"></span><br><span class="line">tempArm64Path=arm64/<span class="variable">$arm64</span></span><br><span class="line">tempArmv7Path=armv7/<span class="variable">$armv7</span></span><br><span class="line">tempI386Path=i386/<span class="variable">$i386</span></span><br><span class="line"><span class="comment"># 定义需要移动的两个静态库的别名</span></span><br><span class="line">capture=libvideo_capture_module_internal_impl.a</span><br><span class="line">render=libvideo_render_module_internal_impl.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩第一个参数下的zip文件到该目录下，不提示的情况覆盖文件</span></span><br><span class="line"><span class="function"><span class="title">funUnzip</span></span>()&#123;</span><br><span class="line">    unzip -o <span class="operator">-d</span> <span class="variable">$&#123;1&#125;</span> <span class="variable">$&#123;1&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"解压缩<span class="variable">$&#123;1&#125;</span>成功"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上面的两个静态库移到其上一个目录</span></span><br><span class="line"><span class="function"><span class="title">funMoveStatic</span></span>()&#123;</span><br><span class="line">    funUnzip <span class="variable">$&#123;1&#125;</span></span><br><span class="line"></span><br><span class="line">    mv <span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>/<span class="variable">$capture</span> <span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>/<span class="variable">$render</span> <span class="variable">$&#123;1&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"成功移动<span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>中两个特殊的静态库"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并arm64/$arm64/$arm64/下所有*.a构建arm64为libWebRTC-arm64.a这种情况</span></span><br><span class="line"><span class="function"><span class="title">funMergeStatic</span></span>()&#123;</span><br><span class="line">    funMoveStatic <span class="variable">$&#123;1&#125;</span> <span class="variable">$&#123;2&#125;</span></span><br><span class="line"></span><br><span class="line">    libtool -static -o <span class="variable">$&#123;1&#125;</span>/libWebRTC-<span class="variable">$&#123;3&#125;</span>.a <span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>/*.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"成功构建libWebRTC-<span class="variable">$&#123;3&#125;</span>.a"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">funBuildWebRTC</span></span>()&#123;</span><br><span class="line">    funMergeStatic <span class="variable">$&#123;tempArm64Path&#125;</span> <span class="variable">$&#123;arm64&#125;</span> <span class="string">"arm64"</span></span><br><span class="line">    funMergeStatic <span class="variable">$&#123;tempArmv7Path&#125;</span> <span class="variable">$&#123;armv7&#125;</span> <span class="string">"armv7"</span></span><br><span class="line">    funMergeStatic <span class="variable">$&#123;tempI386Path&#125;</span> <span class="variable">$&#123;i386&#125;</span> <span class="string">"i386"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"正在执行最后的合成操作，请稍后..."</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建支持arm64、armv7、i386的libWebRTC</span></span><br><span class="line">    lipo -create <span class="variable">$&#123;tempArm64Path&#125;</span>/<span class="variable">$capture</span> <span class="variable">$&#123;tempArmv7Path&#125;</span>/<span class="variable">$capture</span> <span class="variable">$&#123;tempI386Path&#125;</span>/<span class="variable">$capture</span> -output libVideoCapture.a</span><br><span class="line">    lipo -create <span class="variable">$&#123;tempArm64Path&#125;</span>/<span class="variable">$render</span> <span class="variable">$&#123;tempArmv7Path&#125;</span>/<span class="variable">$render</span> <span class="variable">$&#123;tempI386Path&#125;</span>/<span class="variable">$render</span> -output libVideoRender.a</span><br><span class="line">    lipo -create <span class="variable">$&#123;tempArm64Path&#125;</span>/libWebRTC-arm64.a <span class="variable">$&#123;tempArmv7Path&#125;</span>/libWebRTC-armv7.a <span class="variable">$&#123;tempI386Path&#125;</span>/libWebRTC-i386.a -output libWebRTC.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"成功创建支持arm64、armv7、i386的libWebRTC"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清理中间垃圾文件(把子目录及子目录中所有档案删除,并且不用一一确认)</span></span><br><span class="line">    rm -rf <span class="variable">$&#123;tempArm64Path&#125;</span></span><br><span class="line">    rm -rf <span class="variable">$&#123;tempArmv7Path&#125;</span></span><br><span class="line">    rm -rf <span class="variable">$&#123;tempI386Path&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">funBuildWebRTC</span><br></pre></td></tr></table></figure>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.lampweb.org/linux/1/" target="_blank" rel="external">shell 命令</a></p>
<p><a href="http://c.biancheng.net/cpp/shell/" target="_blank" rel="external">Linux Shell脚本教程：30分钟玩转Shell脚本编程</a></p>
<p><a href="http://segmentfault.com/a/1190000002924882#articleHeader16" target="_blank" rel="external">Shell常用招式大全之入门篇</a></p>
]]></content>
    <summary type="html">
    <![CDATA[简单的说Shell就是一个包含若干行Shell或者Linux命令的文件。对于一次编写，多次使用的大量命令，就可以使用单独的文件保存下来，以便日后使用。]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="开发利器" scheme="http://www.zhuli8.com/tags/%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Runtime]]></title>
    <link href="http://www.zhuli8.com/2015/08/16/Runtime/"/>
    <id>http://www.zhuli8.com/2015/08/16/Runtime/</id>
    <published>2015-08-16T03:12:52.000Z</published>
    <updated>2015-09-06T03:14:59.000Z</updated>
    <content type="html"><![CDATA[<p>Objective-C是基于C语言加入了 <strong>面向对象特性</strong> 和 <strong>消息转发机制</strong> 的动态语言，这意味着它不仅需要一个编译器，还需要 <strong>Runtime系统</strong> 来动态创建类和对象，进行消息发送和转发。</p>
<p>Runtime即运行时，是系统在运行的时候的一些机制，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据 <strong>函数的名称</strong> 找到对应的函数来调用。</p>
<blockquote>
<p>事实证明，在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。而C语言在这种情况下，编译阶段就会报错。对于C语言，函数的调用在编译的时候就会决定调用哪个函数，编译完成之后直接顺序执行，无任何二议性。</p>
</blockquote>
<p><a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">RunTime源码</a>，它是一套比较底层的纯C语言API，属于一个C语言库，包含了很多底层的C语言API。平时编写的OC代码，在程序运行过程中，其实最终都是转成了Runtime的C语言代码，Runtime算是OC的幕后工作者。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>SEL其主要作用是快速的通过方法名字查找到对应方法的函数指针，然后调用其函数。SEL其本身是一个Int类型的一个地址，地址中存放着方法的名字。对于一个类中每一个方法对应着一个SEL,所以iOS类中不能存在2个名称相同的方法，即使参数类型不同，因为SEL是根据方法名字生成的，相同的方法名称只能对应一个SEL。</p>
<p>可以通过Objc编译器命令@selector()或者Runtime系统的sel_registerName函数来获取一个SEL类型的方法选择器。如果你知道selector对应的方法名是什么，可以通过NSString* NSStringFromSelector(SEL aSelector)方法将SEL转化为字符串，再用NSLog打印。</p>
<h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>id是通用类型指针，能够表示任何对象。id其实就是一个指向objc_object结构体指针，它包含一个Class isa成员，根据isa指针就可以顺藤摸瓜找到对象所属的类。</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> </span>&#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">详见官方文档</a>。</p>
</blockquote>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">  Class isa; <span class="comment">// 指向metaclass</span></span><br><span class="line">   </span><br><span class="line">  Class super_class ; <span class="comment">// 指向其父类</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">char</span> *name ; <span class="comment">// 类名</span></span><br><span class="line">  <span class="built_in">long</span> <span class="keyword">version</span> ; <span class="comment">// 类的版本信息，初始化默认为0，可以通过runtime函数class_setVersion和class_getVersion进行修改、读取</span></span><br><span class="line">  <span class="built_in">long</span> info; <span class="comment">// 一些标识信息,如CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含对象方法和成员变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;</span></span><br><span class="line">  <span class="built_in">long</span> instance_size ; <span class="comment">// 该类的实例变量大小(包括从父类继承下来的实例变量);</span></span><br><span class="line">  <span class="keyword">struct</span> objc_ivar_list *ivars; <span class="comment">// 用于存储每个成员变量的地址</span></span><br><span class="line">  <span class="keyword">struct</span> objc_method_list **methodLists ; <span class="comment">// 与 info 的一些标志位有关,如CLS_CLASS (0x1L),则存储对象方法，如CLS_META (0x2L)，则存储类方法;</span></span><br><span class="line">  <span class="keyword">struct</span> objc_cache *cache; <span class="comment">// 指向最近使用的方法的指针，用于提升效率；</span></span><br><span class="line">  <span class="keyword">struct</span> objc_protocol_list *protocols; <span class="comment">// 存储该类遵守的协议</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。</p>
<p>在objc_class结构体中：ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。也就是说可以动态修改*methodLists的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。关于二级指针，可以参考<a href="http://www.fenesky.com/blog/2014/07/03/pointers-to-pointers.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line">struct objc_method <span class="comment">&#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span>                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>Method表示类中的某个方法，是一个指向objc_method结构体指针，它存储了方法名(method_name)、方法类型(method_types)和方法实现(method_imp)等信息。</p>
<h2 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id <span class="list">(<span class="keyword">*IMP</span>)</span><span class="list">(<span class="keyword">id</span>, SEL, ...)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>IMP指向的方法与objc_msgSend函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的SEL对应的方法实现肯定是唯一的，通过一组id和SEL参数就能确定唯一的方法实现地址；反之亦然。它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。</p>
<h2 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an instance variable.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ivar表示类中的实例变量，是一个指向objc_ivar结构体指针，它包含了变量名(ivar_name)、变量类型(ivar_type)等信息。</p>
<p>##Property<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *Property;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *<span class="keyword">objc_property_t</span>;<span class="comment">//这个更常用</span></span><br></pre></td></tr></table></figure></p>
<p>Property代表类中的属性，它是一个指向objc_property结构体的指针。可以通过class_copyPropertyList 和 protocol_copyPropertyList方法来获取类和协议中的属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">objc_property_t</span> *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="keyword">objc_property_t</span> *protocol_copyPropertyList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br></pre></td></tr></table></figure>
<p>返回类型为指向指针的指针，因为属性列表是个数组，每个元素内容都是一个objc_property_t指针，而这两个函数返回的值是指向这个数组的指针。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache</span><br></pre></td></tr></table></figure>
<p>Cache为方法调用的性能进行优化，通俗地讲，每当实例对象接收到一个消息时，它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在Cache中查找。Runtime 系统会把被调用的方法存到Cache中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。这根计算机组成原理中学过的 CPU 绕过主存先访问Cache的道理挺像。</p>
<h1 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h1><p>Objc 中发送消息是用中括号（[]）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。下面详细叙述下消息发送步骤：</p>
<ol>
<li>检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。</li>
<li>检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>
<li>如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。</li>
<li>如果 cache 找不到就找Class中的方法列表。</li>
<li>如果Class中的方法列表找不到就到超类的Class中的方法列表去找，一直找，直到找到NSObject类为止。</li>
<li>如果还找不到就要开始进入动态方法解析了。</li>
</ol>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>Runtime是属于OC的底层，可以进行一下非常底层的操作：</p>
<ol>
<li>在程序运行过程中动态地创建一个类（比如KVO底层的实现）。</li>
<li>在程序运行过程中动态地为某个类添加属性、方法，修改属性值和方法。</li>
<li>遍历一个类的所有成员变量、属性、方法。如：字典转模型利用Runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值设置到模型的属性上。</li>
</ol>
<p>相关的头文件：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;objc/runtime.h&gt;</span></span><br><span class="line"><span class="tag">&lt;objc/message.h&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://chun.tips" target="_blank" rel="external">刨根问底Objective－C Runtime</a></p>
<p><a href="http://www.jianshu.com/p/25a319aee33d#" target="_blank" rel="external">Objective-C特性：Runtime</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Runtime是属于OC的底层，可以进行一下非常底层的操作。]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="开发利器" scheme="http://www.zhuli8.com/tags/%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大话@property]]></title>
    <link href="http://www.zhuli8.com/2015/08/09/%E5%A4%A7%E8%AF%9D-property/"/>
    <id>http://www.zhuli8.com/2015/08/09/大话-property/</id>
    <published>2015-08-09T06:29:16.000Z</published>
    <updated>2015-08-10T06:32:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h1><p>在普通的OC对象中，@property就是编译器自动帮我们生成一个私有的成员变量和getter、setter方法的声明及实现。为了研究编译器是如何实现@property的，我们需要使用clang。clang提供一个命令，可以将OC的源码改写成c++的，借此可以研究@property具体的源码实现方式。该命令是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">clang</span> <span class="tag">-rewrite-objc</span> <span class="tag">xxx</span><span class="class">.m</span></span><br></pre></td></tr></table></figure>
<p>除此之外我们还可以通过苹果开源的runtime进行研究，源码地址。<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">源码</a></p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="atomic、nonatomic"><a href="#atomic、nonatomic" class="headerlink" title="atomic、nonatomic"></a>atomic、nonatomic</h3><p>atomic为原子性，会对set方法的实现进行加锁，多线程下可以一个线程写多个线程读，主要用在mac开发；nonatomic为非原子性，set方法的实现不加锁（比atomic性能高）。因为mac开发早于iOS开发，所以默认值为atomic。（A joke!）在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备nonatomic特质，则不使用同步锁。</p>
<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。因此，在iOS开发中，你会发现，几乎所有属性都声明为nonatomic；但是在开发Mac OS X程序时，使用 atomic属性通常都不会有性能瓶颈。</p>
<p>问题来了：</p>
<blockquote>
<p>@property (strong) NSMutableArray *array; 有什么问题？</p>
</blockquote>
<p>线程安全特性默认为atomic，该属性使用了同步锁，会在创建属性时生成一些额外的代码用于帮助写多线程程序，这会带来性能问题，通过显示声明nonatomic可以节省这些虽然很小但是不必要的额外开销。</p>
<p>##访问权限</p>
<h3 id="readonly、readwrite"><a href="#readonly、readwrite" class="headerlink" title="readonly、readwrite"></a>readonly、readwrite</h3><p>readonly只生成get方法的声明和实现； readwrite同时生成get方法和set方法的声明和实现。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>每个对象都有一个引用计数器，每个新对象的计数器默认是1，当对象的计数器减为0时就会被销毁；通过retain可以让对象的计数器加1、release可以让对象的计数器减1，还可以通过 <strong>autorelease pool</strong> 管理内存；只要调用了alloc、copy、new、retain方法产生的新对象，都必须在最后调用一次release或者autorelease；如果使用ARC，编译器会自动生成管理内存的代码。</p>
<h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p>set方法的实现是直接赋值，用于基本数据类型的简单赋值操作，用于非OC对象。</p>
<h3 id="weak-ARC"><a href="#weak-ARC" class="headerlink" title="weak(ARC)"></a>weak(ARC)</h3><p>weak表明该属性定义了一种“非拥有关系（nonowning relationship）”，set方法的实现既不release旧也不retain新值，同assign类似，然而当对象销毁的时候，指针会被自动设置为nil，weak必须用于OC对象。</p>
<p>使用场合：</p>
<blockquote>
<p>*在ARC中，出现循环引用的时候，必须要有一端使用weak，比如：delegate。</p>
<p>*自身已经对它进行一次强引用，没有必要在强引用一次，此时也会使用weak，比如@IBOutlet。</p>
</blockquote>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>set方法的实现是release旧值，copy新值，用于NSString、block等类型。<br>栗子来了：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(nonatomic, <span class="keyword">copy</span>) NSString *<span class="property">name</span>;</span><br><span class="line">- (void)setName:(NSString *)<span class="property">name</span>&#123;	<span class="keyword">if</span> (_name != <span class="property">name</span>) &#123;		[_name release];		_name = [<span class="property">name</span> <span class="keyword">copy</span>];	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>字符串使用copy是为了外部把字符串内容改了不影响该属性；block使用copy是在MRC遗留下来的，在MRC中方法内部的block是在栈区的，使用copy可以把它放到堆区。在ARC中对于block使用copy还是strong效果是一样的。</p>
<h3 id="Copy扩展"><a href="#Copy扩展" class="headerlink" title="Copy扩展"></a>Copy扩展</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>实现NSCopying或NSMutableCoping。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>改变原对象不影响拷贝对象。</li>
<li>改变拷贝对象不影响源对象。</li>
</ol>
<h4 id="浅复制和深复制"><a href="#浅复制和深复制" class="headerlink" title="浅复制和深复制"></a>浅复制和深复制</h4><p>Copy产生的是不可变副本，MutableCopy产生的是可变副本。</p>
<p>只要源对象是不可变类型且产生的对象也是不可变类型的时的情况是浅复制，其他情况都是深复制。浅复制是源对象和拷贝对象指向同一对象，深复制是产生了不同的对象。</p>
<h4 id="property和copy"><a href="#property和copy" class="headerlink" title="@property和copy"></a>@property和copy</h4><p>在set方法中release旧值copy新值，用于NSString和block，可以保证属性不会被外部变量（例如NSMutableString类型变量）的改变所影响。</p>
<p>问题来了：</p>
<blockquote>
<p>@property (nonatomic，copy) NSMutableArray *array;这个写法会出什么问题？</p>
</blockquote>
<p>copy产生的是不可变副本，在set方法中release旧值copy新值，所以运行时类型为NSArray，编译时类型为NSMutableArray，所以对array执行添加、删除、修改数组内的元素的时候程序会因为找不到对应的方法而崩溃。</p>
<p>栗子来了：</p>
<blockquote>
<p>当一个使用 <strong> initWithArray:</strong> 初始化方法创建的NSMutable对象赋值给array属性，那么之后array执行可变数组的方法，比如：<strong>removeObjectAtIndex:</strong> 时会出现”-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x100206cd0”的崩溃。原因在于array属性在被赋值（setter）的时候默认执行了copy方法后变为了不可变NSArray对象。</p>
</blockquote>
<h4 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h4><ol>
<li>遵守NSCopying或NSMutableCopying协议。其实也可以在代码中不写协议类的遵守，只实现里面的方法，协议只是用来方便生成快捷方法的。</li>
<li>实现copyWithZone或mutableCopyWithZone。即用self实例化对象（[[[self class] allocWithZone: zone]init];）、属性赋值、返回对象。</li>
</ol>
<h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><p>编译时类型和运行时类型，应以运行时类型为准。</p>
<h3 id="strong-ARC-、retain-MRC"><a href="#strong-ARC-、retain-MRC" class="headerlink" title="strong(ARC)、retain(MRC)"></a>strong(ARC)、retain(MRC)</h3><p>set方法的实现是release旧值，retain新值，用于OC对象类型。</p>
<p>栗子来了：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(nonatomic, <span class="keyword">copy</span>) NSString *<span class="property">name</span>;</span><br><span class="line">- (void)setName:(NSString *)<span class="property">name</span>&#123;	<span class="keyword">if</span> (_name != <span class="property">name</span>) &#123;		[_name release];		_name = [<span class="property">name</span> retain];	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>##指定方法名称<br>setter=</p>
<p>getter=</p>
<h2 id="synthesize和-dynamic"><a href="#synthesize和-dynamic" class="headerlink" title="@synthesize和@dynamic"></a>@synthesize和@dynamic</h2><p>@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">synthesize</span> var=_var</span>;</span><br></pre></td></tr></table></figure>
<h3 id="synthesize"><a href="#synthesize" class="headerlink" title="@synthesize"></a>@synthesize</h3><p>@synthesize的语义就是，如果没有指定成员变量的名称会自动生成一个属性同名的成员变量，如果这个成员变量已经存在了就不再生成。</p>
<p>如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</p>
<p>在@property被增强之后其实已经很少使用@synthesize</p>
<h3 id="dynamic"><a href="#dynamic" class="headerlink" title="@dynamic"></a>@dynamic</h3><p>@dynamic告诉编译器，属性的setter方法和getter方法由我自己实现不用自动生成（对于readonly的属性只需提供getter方法即可），如果你木有提供setter方法和getter方法，编译时是没问题，但是当程序运行时调用会由于缺少setter方法或gettr方法导致程序崩溃。</p>
<p>编译时是靠Xcode把关，运行时靠runtiime机制来执行相应的方法，这就是所谓的动态绑定。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.jianshu.com/p/4fea8fa60d75" target="_blank" rel="external">iOS面试题</a></p>
<p><a href="http://www.90159.com/2015/07/26/71/" target="_blank" rel="external">iOS面试题集锦</a></p>
<p><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md" target="_blank" rel="external">《招聘一个靠谱的iOS》面试题参考答案（上）</a></p>
]]></content>
    <summary type="html">
    <![CDATA[iOS中常见@property面试题分析]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发、Mac使用中这些你造吗]]></title>
    <link href="http://www.zhuli8.com/2015/08/01/iOS%E5%BC%80%E5%8F%91%E3%80%81Mac%E4%BD%BF%E7%94%A8%E4%B8%AD%E8%BF%99%E4%BA%9B%E4%BD%A0%E9%80%A0%E5%90%97/"/>
    <id>http://www.zhuli8.com/2015/08/01/iOS开发、Mac使用中这些你造吗/</id>
    <published>2015-08-01T02:02:14.000Z</published>
    <updated>2015-08-29T23:07:40.000Z</updated>
    <content type="html"><![CDATA[<p>子曰：工欲善其事，必先利其器。居是邦也。事其大夫之贤者，友其士之仁者。</p>
<p>有志者事竟成，破釜沉舟，百二秦关终属楚； 苦心人天不负，卧薪尝胆，三千越甲可吞吴。 </p>
<p>由此产生此文！</p>
<h1 id="Mac常用快捷键"><a href="#Mac常用快捷键" class="headerlink" title="Mac常用快捷键"></a>Mac常用快捷键</h1><h2 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+Q：退出程序</span><br></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dock右键App+Alt：退出程序<span class="comment">--&gt;强制退出</span></span><br></pre></td></tr></table></figure>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">W</span>：关闭程序的窗口，并没有真正退出程序</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command（长按）+<span class="keyword">Tab</span>：切换程序窗口</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command（长按）+空格：切换输入法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+⬆️：管理多个桌面</span><br></pre></td></tr></table></figure>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击一下文件、文件夹+空格：快速预览内容，无需双击打开。</span><br></pre></td></tr></table></figure>
<h1 id="Xcode常用快捷键"><a href="#Xcode常用快捷键" class="headerlink" title="Xcode常用快捷键"></a>Xcode常用快捷键</h1><p>##Xcode导航快捷键<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="number">1</span>：工程导航器</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="number">0</span>：显示、隐藏导航器面板</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">Option</span>+<span class="number">0</span>：显示、隐藏实用工具面板</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在项目导航器中选中文件，执行<span class="keyword">Option</span>+左键点击操作：在辅助编辑器中打开文件</span><br></pre></td></tr></table></figure>
<h2 id="Xcode搜索快捷键"><a href="#Xcode搜索快捷键" class="headerlink" title="Xcode搜索快捷键"></a>Xcode搜索快捷键</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">Shift</span>+F：搜索导航器(<span class="built_in">Find</span> Navigator，也就是搜索)</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Control</span>+<span class="number">6</span>（键入方法/变量名+<span class="keyword">Enter</span>跳转）：文件跳转栏</span><br></pre></td></tr></table></figure>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + O：快速打开</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Control</span> + Command + ⬆️：程序中(Objective-<span class="keyword">C</span>或<span class="keyword">C</span>++编写).h and .m文件间的快速切换</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">L</span>：输入行号进行快速查找</span><br></pre></td></tr></table></figure>
<h2 id="应用程序编译和清理"><a href="#应用程序编译和清理" class="headerlink" title="应用程序编译和清理"></a>应用程序编译和清理</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + R：运行app</span><br></pre></td></tr></table></figure>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + K：清除工程</span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + B：构建应用程序</span><br></pre></td></tr></table></figure>
<h2 id="调试相关"><a href="#调试相关" class="headerlink" title="调试相关"></a>调试相关</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + . ：方便地暂停运行iOS模拟器</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">K</span>：删除调试面板里的信息，相当于<span class="keyword">Debug</span> Workflow-&gt;<span class="keyword">Clear</span> Console</span><br></pre></td></tr></table></figure>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Command+<span class="keyword">Y</span>：继续执行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F6：跳过方法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F7：跳入方法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F8：跳出方法</span><br></pre></td></tr></table></figure>
<h2 id="文档和帮助"><a href="#文档和帮助" class="headerlink" title="文档和帮助"></a>文档和帮助</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + Shift + <span class="number">0</span> (Zero)：文档和参考</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在类或者方法名上执行<span class="keyword">Option</span> + 左键点击操作：快速帮助</span><br></pre></td></tr></table></figure>
<h2 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + J：可展示当前你在工程导航器中打开的文件</span><br></pre></td></tr></table></figure>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + <span class="number">1</span>：可打开<span class="string">"Show Related Items’弹出菜单</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Option</span> + Shift + 左键点击操作：该组合键可展示一个小尺寸的弹出视图，你可以查看你想要打开它的地方，比如辅助编辑器、标签或者窗口等。</span><br></pre></td></tr></table></figure>
<h1 id="VIM编辑器相关"><a href="#VIM编辑器相关" class="headerlink" title="VIM编辑器相关"></a>VIM编辑器相关</h1><h2 id="VIM的运行模式"><a href="#VIM的运行模式" class="headerlink" title="VIM的运行模式"></a>VIM的运行模式</h2><pre><code>编辑模式：等待编辑命令输入

插入模式：编辑模式下，输入 “i” 进行插入模式，插入文本信息

命令模式：在编辑模式下按Esc键，输入 “:” 进行命令模式
</code></pre><h2 id="VIM使用的命令"><a href="#VIM使用的命令" class="headerlink" title="VIM使用的命令"></a>VIM使用的命令</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:q</span>：直接退出</span><br></pre></td></tr></table></figure>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:wq</span>：保存后退出</span><br></pre></td></tr></table></figure>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:q!</span>：强制退出</span><br></pre></td></tr></table></figure>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Shift</span>+v：选中光标行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y：复制选中行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p：粘贴选中行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x：删除光标前的一个字符</span><br></pre></td></tr></table></figure>
<h1 id="常见Unix指令"><a href="#常见Unix指令" class="headerlink" title="常见Unix指令"></a>常见Unix指令</h1><p>因为Mac系统是基于UNIX系统的，因此可以在“终端”中输入一些UNIX指令来操作Mac系统。比如：新建文件（夹）、打开文件（夹）等。</p>
<h2 id="文件目录操作指令"><a href="#文件目录操作指令" class="headerlink" title="文件目录操作指令"></a>文件目录操作指令</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span>：列出当前目录下的所有内容（文件、文件夹）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-l：列出文件的详细信息</p>
<p>-a：列出当前目录所有文件，包括隐藏文件</p>
</blockquote>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>：新建一个目录</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p：父目录不存在的情况下先生成父目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>：改变当前操作的目录</span><br></pre></td></tr></table></figure>
<figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">touch</span>：新建一个文件（文件不存在才会新建）</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>（tac）：显示文本文件内容</span><br></pre></td></tr></table></figure>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span>：复制文件或目录</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rm</span>：删除文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-r：同时（递归）删除该目录下的所有文件</p>
<p>-f：强制删除文件或目录</p>
</blockquote>
<pre><code>mv：移动文件或目录
</code></pre><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>：在文件系统中查找指定的文件</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>：显示当前目录的名称</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span>：打开一个文件（夹）</span><br></pre></td></tr></table></figure>
<p><strong>注：按一下Tab键可以自动补齐指令名称、文件名、文件夹名等。</strong></p>
<h2 id="Unix指令中的特殊路径"><a href="#Unix指令中的特殊路径" class="headerlink" title="Unix指令中的特殊路径"></a>Unix指令中的特殊路径</h2><p>Mac系统采用的是UNIX文件系统，所有的文件都放在根目录下（即“\”）,因此没有Windows中的C盘、D盘的概念，文件路径就不再有盘符。例如：</p>
<pre><code>Windows中：c://Users/你的用户名/Desktop

Mac中：/Users/你的用户名/Desktop
</code></pre><p>在使用Unix指令过程中，经常会涉及到目录（路径）操作，下面列出几个有特殊含义的路径：</p>
<pre><code>/：根路径
./：当前路径
../：上一级路径
/：根目录，以斜杠表示，其他所有文件和目录在根目录下展开。
/bin：“binary”的缩写，存放提供用户级基础功能的二进制文件，如ls、ps等。
/boot：存放能使系统成功启动的所有文件，这些文件一般在内核用户程序开始执行前得到调用。在iOS中此目录为空。
/dev：“device”的简写，存放BSD设备文件。每个文件代表系统的一个块设备或字符设备，一般来说，“块设备”以块为单位传输数据，如硬盘；而“字符设备”以字符为单位传输数据，如调整解调器。
/sbin：“system binaries”的简写，存放提供系统级基础功能的二进制文件，如netstat、reboot等。
/etc：“et cetera”的简写，存放系统脚本及配置文件，如passwd、hosts等。在iOS中，/etc是一个符号链接，实际指向/private/etc。
/lib：存放系统库文件、内核模块及设备驱动等。iOS中此目录为空。
/mnt：“mount”的简写，存放临时的文件系统挂载点。iOS中此目录为空。
/private：存放两个目录，分别是/private/etc和/private/var。
/tmp：临时目录。在iOS中，/tmp是一个符号链接，实际指向/private/tmp。
/usr：包含了大多数用户工具和程序。/usr/bin包含那些/bin和/sbin中未出现的基础功能，如nm、killall等；/usr/include包含所有的标准C头文件；/usr/lib存放库文件。
/var：“variable”的简写，存放一些经常更改的文件，如日志、用户数据、临时文件等。其中/var/mobile/Applications下存放了所有App Store App，是要重点关注的目录之一。
</code></pre><h2 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who（w）：显示在线登陆用户</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami：显示用户自己的身份</span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hostname</span>：显示主机名称</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname：显示系统信息</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>：显示当前系统中耗费资源最多的进程</span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span>：显示瞬间的进程状态</span><br></pre></td></tr></table></figure>
<pre><code>ifconfig en0：显示网络接口信息
</code></pre><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clear</span>：清屏</span><br></pre></td></tr></table></figure>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">man</span>：命令帮助信息查询</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export</span><br><span class="line"></span><br><span class="line">设置或显示环境变量，但是只在本次登陆中有效。在shell中执行程序时，shell会提供一组环境变量，export可新增、修改或删除环境变量，供后续执行的程序使用，效力仅及于此登陆操作。export设置环境变量是暂时的，只在本次登陆中有效。=前的<span class="constant">PATH</span>变量不加<span class="variable">$符</span>号，再增加的路径用<span class="symbol">:</span>追加。</span><br><span class="line"></span><br><span class="line">export <span class="constant">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:/Library/Developer/IceTouch-</span><span class="number">1.3</span>/<span class="constant">SDKs</span>/<span class="constant">Objc</span>/bin</span><br></pre></td></tr></table></figure>
<h1 id="iphone的一些操作"><a href="#iphone的一些操作" class="headerlink" title="iphone的一些操作"></a>iphone的一些操作</h1><p>双击Shift开启大写</p>
<p>摇一摇撤销</p>
<p>计算器输入的时候手指右划可以删除输入的数字</p>
<p>按住键盘上的小地球切换输入法</p>
<p>拍照可以按声音键</p>
<p>点击状态栏回到顶部</p>
<p>导航侧滑</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>iOS开发和Mac使用中你还有哪些能提高开发效率的小技巧和快捷键以及黑科技，在评论中一起分享吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>子曰：工欲善其事，必先利其器。居是邦也。事其大夫之贤者，友其士之仁者。</p>
<p>有志者事竟成，破釜沉舟，百二秦关终属楚； 苦心人天不负，卧薪尝胆，三千越甲可吞吴。 </p>
<p>由此产生此文！</p>
<h1 id="Mac常用快捷键"><a href="#Mac常]]>
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="开发利器" scheme="http://www.zhuli8.com/tags/%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/"/>
    
      <category term="开发利器" scheme="http://www.zhuli8.com/categories/%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[信令、stun、turn、ice]]></title>
    <link href="http://www.zhuli8.com/2015/07/26/%E4%BF%A1%E4%BB%A4%E3%80%81stun%E3%80%81turn/"/>
    <id>http://www.zhuli8.com/2015/07/26/信令、stun、turn/</id>
    <published>2015-07-26T09:48:27.000Z</published>
    <updated>2015-07-22T07:04:23.000Z</updated>
    <content type="html"><![CDATA[<p>webRTC支持点对点通讯，但是webRTC仍然需要服务端：</p>
<ul>
<li>协调通讯过程中客户端之间需要交换元数据，如一个客户端找到另一个客户端以及通知另一个客户端开始通讯。</li>
<li>需要处理NAT（网络地址转换）或防火墙，这是公网上通讯首要处理的问题。</li>
</ul>
<p>所以我们需要了解服务端相关的知识：信令、Stun、trun、ice。</p>
<h1 id="什么是信令"><a href="#什么是信令" class="headerlink" title="什么是信令"></a>什么是信令</h1><p>信令就是协调通讯的过程，为了建立一个webRTC的通讯过程，客户端需要交换如下信息：</p>
<ul>
<li>会话控制信息，用来开始和结束通话，即开始视频、结束视频这些操作指令。</li>
<li>处理错误的消息。</li>
<li>元数据，如各自的音视频解码方式、带宽。</li>
<li>网络数据，对方的公网IP、端口、内网IP及端口。</li>
</ul>
<p>信令处理过程需要客户端能够来回传递消息，这个过程在webRTC里面是没有实现的，需要自己创建。一旦信令服务建立好了,两个客户端之间建立了连接,理论上他们就可以进行点对点通讯了,这样可以减轻信令服务的压力和消息传递的延迟。</p>
<p>因为信令是我们自己定义的,所以安全性问题跟webrtc无关,需要自己处理。一旦黑客掌握了你的信令,那他就是控制会话的开始、结束、重定向等等。最重要的因素在信令安全中还是要靠使用安全协议,如HTTPS,WSS(如TLS),他们能确保未加密的消息不能被截取。为确保信令安全,强烈推荐使用TLS。</p>
<h1 id="TURN和STUN"><a href="#TURN和STUN" class="headerlink" title="TURN和STUN"></a>TURN和STUN</h1><p>元数据是通过信令服务器中转发给另一个客户端,但是对于流媒体数据,一旦会话建立,首先尝试使用点对点连接。简单一点说就是:每个客户端都有一个唯一的地址,他能用来和其他客户端进行通讯和数据交换。现实生活中客户端都位于一个或多个NAT之后,或者一些杀毒软件还阻止了某些端口和协议,或者在公司还有防火墙或代理等等,防火墙和NAT或许是同一个设备,如我们家里用的路由器。</p>
<p>webrtc就是通过 ICE 这套框架来处理复杂的网络环境的,如果想启用这个功能,你必须让你的应用程序传 ICE 服务器的URL：ICE试着找最好的路径来让客户端建立连接,他会尝试所有可能的选项,然后选择最合适的方案,ICE首先尝试P2P连接,如果失败就会通过Turn服务器进行转接。换一个说法就是:</p>
<p><strong> STUN服务器是用来取外网地址的。</strong></p>
<p><strong> TURN服务器是在P2P失败时进行转发的 </strong></p>
<p>stun和turn服务的作用主要处理打洞与转发，配合完成ICE协议。首先尝试使用P2P，如果失败将求助于TCP，使用turn转发两个端点的音视频数据，turn转发的是两个端点之间的音视频数据不是信令数据。因为turn服务器是在公网上，所以他能被各个客户端找到，另外turn服务器转发的是数据流，很占用带宽和资源。</p>
<p>#ICE技术<br>基于IP的语音、数据、视频等业务在NGN（Next Generation Network）网络中所面临的一个实际困难就是如何有效地穿透各种NAT（Network Address Translator）/FW(Fire Wall)的问题。对此，SIP（会话初始化协议）以往的解决方法由ALGs（(Application Layer Gateway Service)）、STUN、TURN等方式。现在有一种新的媒体会话信令穿透NAT/FW的解决方案-交互式连通建立方式ICE。它通过综合利用现有协议，以一种更有效的方式来组织会话建立过程，使之在不增加任何延迟同时比STUN等单一协议更具有健壮性、灵活性。</p>
<p>多媒体会话信令协议是在准备建立媒体流传输的代理之间交互信息的协议，例如SIP、RTSP（real time streaming protocol）等。媒体流与信令流截然不同，它们所采用的网络通道也不一致。由于协议自身设计上的原因，使得媒体流无法直接穿透网络地址转换/防火墙(NAT/FW)。因为它们生存期的目标只是为了建立一个在信息中携带IP地址的分组流，这在遇到NAT/FW 时会带来许多问题。而且这些协议的目标是通过建立P2P(Peer to Peer)媒体流以减小时延，而协议本身很多方面却与NAT存在兼容性问题，这也是穿透 NAT/FW的困难所在。</p>
<p>##ICE简介<br>交互式连通建立方式ICE(Interactive Connectivity Establishment)并非一种新的协议，它不需要对STUN、TURN或RSIP进行扩展就可适用于各种NAT。ICE是通过综合运用上面某几种协议，使之在最适合的情况下工作，以弥补单独使用其中任何一种所带来的固有缺陷。对于SIP来说，ICE只需要定义一些SDP(Session Description Protocol)附加属性即可，对于别的多媒体信令协议也需要制定一些相应的机制来实现。</p>
<p>##多媒体信令<br>媒体流穿透NAT的过程是独立于某种具体的信令协议的。通信发生在两个客户端－会话发起者和会话响应者。初始化信息(Initiate Message)包含了描述会话发起者媒体流的配置与特征，并经过信令调停者(也叫信令中继)，最后到达会话响应者。假设会话响应者同意通信，接受信息(Accept Message)将产生并反馈至会话初始者，媒体流建立成功。此外，信令协议还对媒体流参数修改以及会话终止消息等提供支持。对于SIP，会话发起者即UAC(User Agent Client)，会话响应者即UAS(User Agent Server)，初始化消息对应SDP请求里面的INVITE，接受消息对应于SDP应答里面的200 OK，终止消息对应于BYE。</p>
<p>##流程</p>
<p>###收集传输地址<br>会话发起者需要收集的对象包括本地传输地址(Local Transport Address)和来源传输地址(Derived Transport Address)。本地传输地址通常由主机上一个物理(或虚拟)接口绑定一个端口而获得。会话发起者还将访问提供UNSAF(Unilateral self-address fixing)的服务器，例如STUN、TURN或TEREDO。对于每一个本地传输地址，会话者都可以从服务器上获得一组来源传输地址。显然，实现物理或虚拟连通方式越多，ICE将工作得越好。但为了建立对等通信，ICE通常要求至少有一个来源地址由位于公网上的中继服务器(如TURN)所提供的，而且需要知道具体是哪一个来源传输地址。</p>
<p>###启动STUN<br>会话发起者获得一组传输地址后，将在本地传输地址启动STUN服务器，这意味着发送到来源地址的STUN服务将是可达的。与传统的STUN不同，客户端不需要在任何其它IP或端口上提供STUN服务，也不必支持TLS， ICE用户名和密码已经通过信令协议进行交换。客户端将在每个本地传输地址上同时接受STUN请求包和媒体包，所以发起者需要消除STUN消息与媒体流协议之间的歧义。在RTP和RTCP中实现这个并不难，因为RTP与RTCP包总是以0b10(v=2)打头，而STUN是0b00。对于每个运行STUN服务器的本地传输地址，客户端都必须选择相应的用户名和密码。用户名要求必须是全局唯一的，用户名和密码将被包含在初始化消息里传至响应者，由响应者对STUN请求进行鉴别。</p>
<p>###确定传输地址的优先级<br>STUN服务器启动后，下一步就是确定传输地址的优先级。优先级反映了UA在该地址上接收媒体流的优先级别，取值范围在0到1之间，通常优先级按照被传输媒体流量来确定。流量小者优先，而且对于相同流量者的Ipv6地址比Ipv4地址具有更高优先级。因此物理接口产生的本地Ipv6传输地址具有最高的优先级，然后是本地Ipv4传输地址，然后是STUN、RSIP、TEREDO来源地址，最后是通过VPN接口获得的本地传输地址。</p>
<p>###构建初始化信息(Initiate Message)<br>初始化消息由一系列媒体流组成，每个媒体流都有一个缺省地址和候选地址列表。缺省地址通常被Initiate消息映射到SIP信令消息传递地址上，而候选地址列表用于提供一些额外的地址。对于每个媒体流来说，任意Peer之间实现最大连通可能性的传输地址是由公网上转发服务器(如TURN)提供的地址，通常这也是优先级最低的传输地址。客户端将可用的传输地址编成一个候选地址列表(包括一个缺省地址)，并且为每个候选元素分配一个会话中唯一的标识符。该标识符以及上述的优先级都被编码在候选元素的id属性中。一旦初始化信息生成后即可被发送。</p>
<p>###响应处理：连通性检查和地址收集<br>会话应答方接收到初始化信息Initiate Message后，会同时做几个事情：首先，执行 <em>收集传输地址</em> 中描述的地址收集过程。这些地址可以在呼叫到达前预收集，这样可以避免增加呼叫建立的时间。当获得来源地址以后，应答方会发送STUN Bind请求，该请求要求必须包含Username属性和Password属性，属性值为从 “alt”中得到的用户名和密码。STUN Bind请求还应包括一个Message-Integrity属性，它是由Initiate Message中候选元素的用户名和密码计算得来的。此外，STUN Bind请求不应有Change-Request或Response-Address属性。当一个客户端收到Initiate Message时，它将通过其中缺省地址和端口发送媒体流。如果STUN Bind请求消息引起错误应答，则需要检查错误代码。如果是401，430，432或500，说明客户端应该重新发送请求。如果错误代码是400，431和600，那么客户端不必重试，直接按超时处理即可。</p>
<p>###生成接受信息(Accept Message)<br>应答者可以决定是接受或拒绝该通信，若拒绝则ICE过程终止，若接受则发送Accept消息。Accept消息的构造过程与Initiate Message类似。</p>
<p>###接受信息处理<br>接受过程有两种可能。如果Initiate Message的接受者不支持ICE，则Accept Message将只包含缺省的地址信息，这样发起方就知道它不用执行连通性检查了。然而如果本地配置信息要求发起者通过TURN服务器发包来进行连通性检查，这将意味着那些直接发给响应者的包会被对方防火墙丢弃。为解决这个问题，发起者需要重新分配一个TURN来源地址，然后使用Send命令。一旦Send命令被接受，发起者将发送所有的媒体包到TURN服务器，由服务器转发至响应者。如果Accept Message包含候选项，则发起方处理Accept Message的过程就与响应方处理Initiate Message很相似了。</p>
<p>###附加ICE过程<br>Initiate或Accept消息交换过程结束后，双方可能仍将继续收集传输地址，这通常是由于某些STUN事务过长而未结束引起，另一种可能是由于Initiate/Accept消息交换时提供了新的地址。</p>
<p>###ICE到SIP的映射<br>使用ICE方式穿透NAT，必须映射ICE定义的参数到SIP消息格式中，同时对其SDP属性进行简单扩展—在SDP的Media块中定义一个新的属性“alt”来支持ICE。它包含一个候选IP地址和端口，SDP的接受端可以用该地址来替换m和c中的地址。Media块中可能会有多个alt属性，这时每个alt应该包括不重复的IP地址和端口。</p>
<p>#写在最后<br>ICE方式的优势是显而易见的，它消除了现有的UNSAF机制的许多脆弱性。例如传统的STUN有几个脆弱点，其中一个就是发现过程需要客户端自己去判断所在NAT类型，这实际上不是一个可取的做法。而应用ICE之后，这个发现过程已经不需要了。另一点脆弱性在于STUN、TURN等机制都完全依赖于一个附加的服务器，而ICE利用服务器分配单边地址的同时，还允许客户端直接相连，因此即使STUN或TRUN服务器中有任何一个失败了，ICE方式仍可让呼叫过程继续下去。此外，传统的STUN最大的缺陷在于它不能保证在所有网络拓扑结构中都正常工作，最典型的问题就是Symmetric NAT。对于TURN或类似转发方式工作的协议来说，由于服务器的负担过重，很容易出现丢包或者延迟情况。而ICE方式正好提供了一种负载均衡的解决方案，它将转发服务作为优先级最低的服务，从而在最大程度上保证了服务的可靠性和灵活性。此外，ICE的优势还在于对Ipv6的支持，目前Cisco等公司正在设计基于ICE方式的NAT/FW解决方案。由于广泛的适应能力以及对未来网络的支持，ICE作为一种综合的解决方案将有着非常广阔的应用前景。</p>
]]></content>
    <summary type="html">
    <![CDATA[iOS下的webRTC开发实现IM]]>
    
    </summary>
    
      <category term="IM" scheme="http://www.zhuli8.com/tags/IM/"/>
    
      <category term="webRTC" scheme="http://www.zhuli8.com/tags/webRTC/"/>
    
      <category term="IM" scheme="http://www.zhuli8.com/categories/IM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[构建支持armv7和arm64的webRTC静态库]]></title>
    <link href="http://www.zhuli8.com/2015/07/19/%E6%9E%84%E5%BB%BA%E6%94%AF%E6%8C%81armv7%E5%92%8Carm64%E7%9A%84webRTC%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <id>http://www.zhuli8.com/2015/07/19/构建支持armv7和arm64的webRTC静态库/</id>
    <published>2015-07-19T04:13:57.000Z</published>
    <updated>2018-02-23T07:30:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。需要注意的是iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。</p>
<p><strong>目前为止Apple移动设备默认指令集</strong></p>
<hr>
<p>armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch</p>
<p>armv7 设备：iPhone3GS, iPhone4, iPhone4S, iPad, iPad2, iPad3(The New iPad), iPad mini,<br>iPod Touch 3G, iPod Touch4</p>
<p>armv7s设备： iPhone5, iPhone5C, iPad4(iPad with Retina Display)</p>
<p>arm64 设备： iPhone5S, iPad Air, iPad mini2(iPad mini with Retina Display)</p>
<hr>
<p>现在苹果默认要求支持armv7&amp;arm64，知道了这些信息我们进入下一话题！</p>
<p>#构建支持armv7和arm64的webRTC静态库<br>总体思路就是将webRTC中的armv7静态库合并优化成一个单一的静态库，arm64中的所有静态库合并优化成一个单一的静态库，最后利用lipo指令合并这两个静态库为一个最终的静态库。</p>
<p>##armv7<br>合并所有的*.a构建armv7为libWebRTC-armv7.a并优化静态库</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libtool -<span class="keyword">static</span> -o src<span class="regexp">/armv7/</span>Release-iphoneos<span class="regexp">/libWebRTC-temp.a src/</span>armv7<span class="regexp">/Release-iphoneos/</span>*.a</span><br><span class="line"></span><br><span class="line">strip -S -x -o src<span class="regexp">/armv7/</span>Release-iphoneos<span class="regexp">/libWebRTC-armv7.a -r src/</span>armv7<span class="regexp">/Release-iphoneos/</span>libWebRTC-temp.a</span><br></pre></td></tr></table></figure>
<p>##arm64<br>合并所有的*.a构建arm64为libWebRTC-arm64.a</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libtool -<span class="keyword">static</span> -o src<span class="regexp">/arm64/</span>Release-iphoneos<span class="regexp">/libWebRTC-temp.a src/</span>arm64<span class="regexp">/Release-iphoneos/</span>*.a</span><br><span class="line"></span><br><span class="line">strip -S -x -o src<span class="regexp">/arm64/</span>Release-iphoneos<span class="regexp">/libWebRTC-arm64.a -r src/</span>arm64<span class="regexp">/Release-iphoneos/</span>libWebRTC-temp.a</span><br></pre></td></tr></table></figure>
<p><strong>2015年7月27日更新</strong></p>
<p><strong>之前的指令用在音频没有问题，但是用在视频只有声音没有图像。最后检查发现没有使用strip优化之前的包可以使用，而且不能包括iOS生成的静态库。
</strong></p>
<p>##创建支持armv7&amp;arm64的libWebRTC</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -<span class="built_in">create</span> src/armv7/Release-iphoneos/libWebRTC-armv7.<span class="operator">a</span> src/arm64/Release-iphoneos/libWebRTC-arm64.<span class="operator">a</span> -output libWebRTC.<span class="operator">a</span></span><br></pre></td></tr></table></figure>
<p><strong>lipo -info libWebRTC.a，可以查看支持的架构信息</strong></p>
<p><strong>2015年8月19日更新</strong><br><strong>当测试armv7指令集通过后，在原来的工程中删掉armv7添加arm64对应的库时编译通不过，因为同一个文件下包含了两种架构信息所导致。解决方案：</strong></p>
<ol>
<li>选择工程, 编译的 (targets)</li>
<li>选择 Build Settings 菜单</li>
<li>查找 Library Search Paths 和 Framework Search Paths， 删掉编译报warning的路径即OK</li>
</ol>
<p><strong>关于Category位于静态库时,引用该静态库的工程使用Category,出现”unrecognized selector sent to class”提示。</strong></p>
<blockquote>
<p>标准UNIX静态库与Objective-C之间Linker的差异：在标准的UNIX静态库内,linker symbol是依照每一个类别而产生的,但由于Category并没有真正产生一个类别,所以出错。</p>
</blockquote>
<ol>
<li>在该静态库的Taraget-&gt;Build Settings-&gt;Other Linker Flags-&gt;加上 -ObjC</li>
<li>在使用该静态库的工程Taraget-&gt;Build Settings-&gt;Other Linker Flags-&gt;加上-all_load或-force_load</li>
</ol>
<p><strong>如果你的项目使用的非ARC模式，则为ARC模式的代码文件加入-fobjc-arc标签。如果你的项目使用的ARC模式，则为非ARC模式的代码文件加入 -fno-objc-arc标签。添加标签的方法:</strong></p>
<ol>
<li>打开target - Bulid Phases -Compile Sources</li>
<li>双击对应的*.m文件</li>
<li>在弹出的窗口中输入上面提到的标签 -fobjc-arc / -fno-objc-arc4</li>
<li>按Enter键保存</li>
</ol>
<p>#其他<br>libtool和lipo的相关指令选项参数可用通过man帮助进行查看，里面写的还是比较详细的。</p>
<p>##XCode中与指令集相关的选项（Build Settings 面板下 Architectures）：</p>
<p>1.Architectures：      </p>
<p>指明选定Target要求被编译生成的二进制包所支持的指令集是通过编译生成对应的二进制数据包实现的，如果支持的指令集数目有多个，就会编译出包含多个指令集代码的数据包，从而会造成最终编译生成的包很大。</p>
<p>2.Valid Architectures：</p>
<p>指明可能支持的指令集并非Architectures列表中指明的指令集都会被支持，Valid Architectures限制可能被支持的指令集的范围，即Valid Architectures和Architectures列表的交集，才是XCode最终生成二进制包所支持的指令集。比如，将Architectures支持arm指令集设置为：armv7,armv7s，对应的Valid Architectures的支持的指令集设置为：armv7s,arm64，那么此时，XCode生成二进制包所支持的指令集只有armv7s 。</p>
<p>3.Build Active Architecture Only:</p>
<p>指明是否只编译当前连接设备所支持的指令集,该选项起作用的条件有两个，必须同时满足才会起作用：</p>
<ul>
<li>其值设置为YES</li>
<li>XCode成功连接调试设备</li>
</ul>
<p>当Build Active Architecture Only起作用时,连接的手机指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。<br>建议：通常Debug模式设置值为Yes，Release模式设置为No。</p>
<p>##<a href="http://www.it165.net/pro/html/201503/35541.html" target="_blank" rel="external">WebRTC.framework的依赖</a><br>如果项目使用了该框架,那么编译的时候需要在项目的Build Phases中添加如下库和框架:</p>
<blockquote>
<ul>
<li>libstdc++.6.dylib</li>
<li>libsqlite3.dylib</li>
<li>libc++.dylib</li>
<li>libicucore.dylib</li>
<li>Security.framework</li>
<li>CFNetwork.framework</li>
<li>GLKit.framework</li>
<li>AudioToolbox.framework</li>
<li>AVFoundation.framework</li>
<li>CoreAudio.framework</li>
<li>CoreMedia.framework</li>
<li>CoreVideo.framework</li>
<li>CoreGraphics.framework</li>
<li>OpenGLES.framework</li>
<li>QuartzCore.framework</li>
</ul>
</blockquote>
<p><strong>由于公司c++人员打包webRTC时模拟器的包有点问题，还有之前和linphone的libvpx.a的冲突最后删掉了linphone的而公用webRTC的，以至于模拟器缺少i386的libvpx.a库，解决办法：</strong></p>
<ol>
<li>将lib库拆分出armv7、armv7s、i386类型的.a，较麻烦<br>lipo -extract_family armv7 -output libDomobOfferWallSDK_arm.a libDomobOfferWallSDK.a<br>lipo -info libDomobOfferWallSDK_arm.a</li>
<li>对于i386则不用上述那么麻烦，直接用第一句-extract_family指令就能分离出只含i386版本的库<br>lipo -extract_family i386 -output libDomobOfferWallSDK_i386.a libDomobOfferWallSDK.a</li>
<li><a href="http://www.cnblogs.com/wengzilin/p/3800856.html" target="_blank" rel="external">http://www.cnblogs.com/wengzilin/p/3800856.html</a></li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://www.jianshu.com/p/60ac3ded34a0" target="_blank" rel="external">自建framework提交审核报错 ERROR ITMS-90087解决办法</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色]]>
    </summary>
    
      <category term="IM" scheme="http://www.zhuli8.com/tags/IM/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="IM" scheme="http://www.zhuli8.com/categories/IM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[The Internet Communications (ice)]]></title>
    <link href="http://www.zhuli8.com/2015/07/12/The-Internet-Communications-Ice-%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.zhuli8.com/2015/07/12/The-Internet-Communications-Ice-简介/</id>
    <published>2015-07-12T09:26:50.000Z</published>
    <updated>2015-07-22T07:03:57.000Z</updated>
    <content type="html"><![CDATA[<p>#简介<br>The Internet Communications Engine (ice) is a modern object-oriented toolkit that enables you to build distributed applications with minimal effort. Ice allows you to focus your efforts on your application logic, and it takes care of all interactions with low-level network programming interfaces. With Ice, there is no need to worry about details such as opening network connections, serializing and deserializing data for network transmission, or retrying failed connection attempts (to name but a few of dozens of such low-level details).</p>
<p>#开发环境搭建<br>ICE安装文件：<a href="https://zeroc.com/icetouch/download.html" target="_blank" rel="external">https://zeroc.com/icetouch/download.html</a><br>ICE编译插件：<a href="https://github.com/zeroc-ice/ice-builder-xcode" target="_blank" rel="external">https://github.com/zeroc-ice/ice-builder-xcode</a></p>
<p>#相关文档<br>ICE官网：<a href="http://www.zeroc.com/ice.html" target="_blank" rel="external">http://www.zeroc.com/ice.html</a><br>官网文档：<a href="http://doc.zeroc.com/display/Doc/Home" target="_blank" rel="external">http://doc.zeroc.com/display/Doc/Home</a><br>性能评测：<a href="http://zeroc.com/articles/IcePerformanceWhitePaper.pdf" target="_blank" rel="external">http://zeroc.com/articles/IcePerformanceWhitePaper.pdf</a></p>
<p>#ICE通讯框架基本原理<br>ICE的思路是，用一个中间语言，建立数据结构规范和接口规范，然后再用一个IDE编译插件，将中间语言数据结构规范和接口规范编译为当前的语言，譬如OC的.h/.m文件，接下来，你在客户端和服务端实现中间语言定义号的接口，再做一些其它处理，就可以实现一个分布式程序了。这个思路确实很Nice，值得我们借鉴。</p>
<p>#通讯方式选择<br>P2P（设备直连）</p>
<p>通过服务器中转</p>
<p>#网络连接方式<br>基于TCP的长连接</p>
<p>基于HTTP短连接PULL的方式</p>
<p>#协议选择<br>XMPP</p>
<p>SIP</p>
<p>MQTT</p>
<p>私有协议（二进制协议）</p>
<p>#其他<br>p2p视频聊天的过程：音视频数据采集—&gt;编码—&gt;发送—&gt;接收—&gt;解码—&gt;播放</p>
<p><a href="http://www.cnblogs.com/HouZhiHouJueBlogs/p/3864677.html" target="_blank" rel="external">The Internet Communications Engine (Ice) 跨平台异构通讯方案 第一弹-ICE简介</a></p>
<p><a href="http://www.cnblogs.com/HouZhiHouJueBlogs/p/3864737.html" target="_blank" rel="external">The Internet Communications Engine (Ice) 跨平台异构通讯方案 第二弹-Hello world！</a></p>
<p><a href="http://www.cnblogs.com/lingyunhu/category/626157.html" target="_blank" rel="external">webrtc</a></p>
]]></content>
    <summary type="html">
    <![CDATA[IM相关学习]]>
    
    </summary>
    
      <category term="IM" scheme="http://www.zhuli8.com/tags/IM/"/>
    
      <category term="ice" scheme="http://www.zhuli8.com/tags/ice/"/>
    
      <category term="IM" scheme="http://www.zhuli8.com/categories/IM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Grand Central Dispatch (gcd)]]></title>
    <link href="http://www.zhuli8.com/2015/07/05/Grand-Central-Dispatch-gcd/"/>
    <id>http://www.zhuli8.com/2015/07/05/Grand-Central-Dispatch-gcd/</id>
    <published>2015-07-05T06:50:07.000Z</published>
    <updated>2015-10-28T08:10:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h2><ul>
<li>全称是Grand Central Dispatch，可译为“大中央调度”</li>
<li>纯C语言，提供了非常多强大的函数库</li>
</ul>
<p>##GCD的优势</p>
<ul>
<li>GCD是苹果公司为<strong>多核</strong>的<strong>并行</strong>运算提出的解决方案</li>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码<h1 id="任务和队列"><a href="#任务和队列" class="headerlink" title="任务和队列"></a>任务和队列</h1></li>
<li>GCD中有两个核心概念</li>
</ul>
<ol>
<li><strong>任务</strong>：执行什么操作</li>
<li><strong>队列</strong>：用来存放任务</li>
</ol>
<ul>
<li>GCD的使用步骤</li>
</ul>
<ol>
<li><strong>定制任务</strong>：确定想做的事情</li>
<li><strong>将任务添加到队列中</strong>：GCD会自动将<em>队列</em>中的<em>任务</em>取出，放到对应的<em>线程</em>中执行；<em>任务</em>的取出遵循<em>队列</em>的FIFO原则：先进先出，后进后出<h2 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h2>GCD中有2个用来执行任务的函数</li>
</ol>
<ul>
<li>用<strong>同步</strong>的方式执行任务<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>queue：队列<br>  block：任务</p>
</blockquote>
<ul>
<li><p>用<strong>异步</strong>的方式执行任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block); </span><br></pre></td></tr></table></figure>
</li>
<li><p>同步和异步的区别</p>
<blockquote>
<p>同步：只能在<strong>当前</strong>线程中执行任务，<strong>不具备</strong>开启新线程的能力<br>异步：可以在<strong>新的</strong>线程中执行任务，<strong>具备</strong>开启新线程的能力</p>
</blockquote>
</li>
</ul>
<h2 id="队列的类型"><a href="#队列的类型" class="headerlink" title="队列的类型"></a>队列的类型</h2><p>GCD的队列可以分为2大类型</p>
<ul>
<li><p><strong>并发</strong>队列（Concurrent Dispatch Queue）</p>
<blockquote>
<p>可以让多个任务<strong>并发（同时）</strong>执行（自动开启多个线程同时执行任务）<br><strong>并发</strong>功能只有在<strong>异步（dispatch_async）</strong>函数下才有效</p>
</blockquote>
</li>
<li><p><strong>串行</strong>队列（Serial Dispatch Queue）</p>
<blockquote>
<p>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</p>
</blockquote>
</li>
<li>容易混淆的术语 <blockquote>
<p>有4个术语比较容易混淆：同步、异步、并发、串行<br><strong>同步和异步主要影响：能不能开启新的线程</strong><br>同步：在当前线程中执行任务，不具备开启新线程的能力<br>异步：在新的线程中执行任务，具备开启新线程的能力<br><strong>并发和串行主要影响：任务的执行方式</strong><br>并发：多个任务并发（同时）执行<br>串行：一个任务执行完毕后，再执行下一个任务</p>
</blockquote>
</li>
</ul>
<h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><ul>
<li>GCD默认已经提供了全局的并发队列，供整个应用使用，不需要手动创建<br><strong>使用dispatch_get_global_queue函数获得全局的并发队列</strong><blockquote>
<p>dispatch_queue_t dispatch_get_global_queue(<br>dispatch_queue_priority_t priority, // 队列的优先级<br>unsigned long flags); // 此参数暂时无用，用0即可</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>); <span class="comment">// 获得全局并发队列</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>全局并发队列的优先级<br><code>#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高</code><br><code>#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中</code>）<br><code>#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低</code><br><code>#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台</code></p>
</blockquote>
<h3 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列 "></a>串行队列 </h3><ul>
<li>GCD中获得串行有2种途径</li>
</ul>
<p><strong>使用dispatch_queue_create函数创建串行队列</strong></p>
<blockquote>
<p>dispatch_queue_t<br>dispatch_queue_create(const char *label, // 队列名称<br>dispatch_queue_attr_t attr); // 队列属性，一般用NULL即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"cn.itcast.queue"</span>, <span class="literal">NULL</span>); <span class="comment">// 创建</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>使用主队列（跟主线程相关联的队列）</strong><br>主队列是GCD自带的一种特殊的串行队列<br>放在主队列中的任务，都会放到主线程中执行<br>使用dispatch_get_main_queue()获得主队列<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure></p>
<pre><code>凡是函数名种带有create\copy\new\retain等字眼, 都应该在不需要使用这个数据的时候进行release
GCD的数据类型在ARC环境下不需要再做release
CF(Core Foundation)的数据类型在ARC环境下还是需要再做release
</code></pre><h3 id="各种队列的执行效果"><a href="#各种队列的执行效果" class="headerlink" title="各种队列的执行效果"></a>各种队列的执行效果</h3><p><img src="http://www.zhuli8.com/photos/gcd.png" alt=""></p>
<blockquote>
<p><strong>注意</strong><br>使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列</p>
</blockquote>
<h1 id="线程间通信示例"><a href="#线程间通信示例" class="headerlink" title="线程间通信示例 "></a>线程间通信示例 </h1><h2 id="从子线程回到主线程"><a href="#从子线程回到主线程" class="headerlink" title="从子线程回到主线程"></a>从子线程回到主线程</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行耗时的异步操作...</span><br><span class="line">      dispatch_async<span class="list">(<span class="keyword">dispatch_get_main_queue</span><span class="list">()</span>, ^&#123;</span><br><span class="line">        // 回到主线程，执行UI刷新操作</span><br><span class="line">        &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="延时执行"><a href="#延时执行" class="headerlink" title="延时执行"></a>延时执行</h2><p>iOS常见的延时执行有2种方式</p>
<h3 id="调用NSObject的方法"><a href="#调用NSObject的方法" class="headerlink" title="调用NSObject的方法"></a>调用NSObject的方法</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> <span class="symbol">performSelector:</span><span class="variable">@selector</span>(run) <span class="symbol">withObject:</span><span class="literal">nil</span> <span class="symbol">afterDelay:</span><span class="number">2.0</span>];<span class="regexp">//</span> <span class="number">2</span>秒后再调用<span class="keyword">self</span>的run方法</span><br></pre></td></tr></table></figure>
<h3 id="使用GCD函数"><a href="#使用GCD函数" class="headerlink" title="使用GCD函数"></a>使用GCD函数</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">dispatch_after</span>(<span class="function">dispatch_time</span>(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * NSEC_PER_SEC)), <span class="tag">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">    <span class="comment">// 2秒后异步执行这里的代码...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="一次性代码"><a href="#一次性代码" class="headerlink" title="一次性代码"></a>一次性代码</h2><p>使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h2><p>有这么1种需求<br>首先：分别异步执行2个耗时的操作<br>其次：等2个异步操作都执行完毕后，再回到主线程执行操作<br>如果想要快速高效地实现上述需求，可以考虑用队列组<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group =  dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行<span class="number">1</span>个耗时的异步操作</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行<span class="number">1</span>个耗时的异步操作</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    // 等前面的异步操作都执行完毕后，回到主线程...</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="单例模式的作用"><a href="#单例模式的作用" class="headerlink" title="单例模式的作用"></a>单例模式的作用</h3><p>可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问，从而方便地控制了实例个数，并节约系统资源</p>
<h3 id="单例模式的使用场合"><a href="#单例模式的使用场合" class="headerlink" title="单例模式的使用场合"></a>单例模式的使用场合</h3><ul>
<li>在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次）</li>
<li>单例模式在ARC\MRC环境下的写法有所不同，需要编写2套不同的代码<br>可以用宏判断是否为ARC环境<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __has_feature(objc_arc)</span></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ARC单例模式的实现"><a href="#ARC单例模式的实现" class="headerlink" title="ARC单例模式的实现"></a>ARC单例模式的实现</h4><ul>
<li><p>在.m中保留一个全局的static的实例</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写allocWithZone:方法，在这里创建唯一的实例（注意线程安全）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_instance) &#123;</span><br><span class="line">            _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供1个类方法让外界访问唯一的实例</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedSoundTool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_instance) &#123;</span><br><span class="line">            _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现copyWithZone:方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h4><p>非ARC中（MRC），单例模式的实现（比ARC多了几个步骤）<br><em>实现内存管理方法</em></p>
<pre><code>- (id)retain { return self; }
- (NSUInteger)retainCount { return 1; }
- (oneway void)release {}
- (id)autorelease { return self; }
</code></pre><p>#推荐阅读<br><a href="http://www.jianshu.com/p/50c060bab0ff" target="_blank" rel="external">Ethan Joe：Grand Central Dispatch 基础教程：Part 1/2</a><br><a href="[Ethan Joe：Grand Central Dispatch 基础教程：Part 1/2](http://www.jianshu.com/p/50c060bab0ff">cocoachina：Grand Central Dispatch 基础教程：Part 2/2</a>)<br><a href="http://www.devtang.com/blog/2012/02/22/use-gcd/" target="_blank" rel="external">唐巧：使用GCD</a><br><a href="http://www.cocoachina.com/ios/20140428/8248.html" target="_blank" rel="external">GCD 深入理解（一）</a><br><a href="http://www.cocoachina.com/ios/20140515/8433.html" target="_blank" rel="external">GCD 深入理解（二）</a></p>
<h1 id="NSOperation-amp-NSOperationQueue"><a href="#NSOperation-amp-NSOperationQueue" class="headerlink" title="NSOperation&amp;NSOperationQueue"></a>NSOperation&amp;NSOperationQueue</h1><p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<p><a href="http://blog.xcodev.com/archives/operation-queue-intro/" target="_blank" rel="external">并发编程之Operation Queue</a></p>
<p><a href="http://www.jianshu.com/p/0b0d9b1f1f19#" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></p>
<p><a href="http://limboy.me/ios/2015/08/08/advanced-nsoperations.html" target="_blank" rel="external">Advanced NSOperations</a></p>
<p><a href="http://oncenote.com/2015/03/22/Threading-Run-Loop/" target="_blank" rel="external">iOS并发编程（Concurrency Programming）系列</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什]]>
    </summary>
    
      <category term="GCD" scheme="http://www.zhuli8.com/tags/GCD/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift学习参考]]></title>
    <link href="http://www.zhuli8.com/2015/06/28/swift%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83/"/>
    <id>http://www.zhuli8.com/2015/06/28/swift学习参考/</id>
    <published>2015-06-28T04:41:20.000Z</published>
    <updated>2015-08-28T03:11:22.000Z</updated>
    <content type="html"><![CDATA[<p>#官方文档<br><a href="https://developer.apple.com/swift/" target="_blank" rel="external">苹果出品，必属精品！</a></p>
<p><a href="https://github.com/zhuli8com/Welcome-to-Swift" target="_blank" rel="external">Welcome-to-Swift</a>（中文版）</p>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/" target="_blank" rel="external">The Swift Programming Language</a></p>
<p><a href="http://www.cocoachina.com/ios/20150701/12328.html" target="_blank" rel="external">没机会参加 WWDC 2015，那你可以看看这10个视频</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="external">swift 2.0</a>(中文版)</p>
<p>#精彩博文<br><a href="http://southpeak.github.io/blog/2015/06/30/ioszhi-shi-xiao-ji-di-san-qi-2015-dot-06-dot-30/" target="_blank" rel="external">Tint Color\Build Configurations in Swift\键盘事件</a></p>
<p><a href="http://www.cocoachina.com/swift/20150630/12305.html" target="_blank" rel="external">怎样在Swift中使用CocoaPods</a></p>
<p><a href="http://www.cocoachina.com/swift/20150806/12831.html" target="_blank" rel="external">怎样在swift中创建一个CocoaPods</a></p>
<p><a href="http://www.cocoachina.com/ios/20150629/12298.html" target="_blank" rel="external">使用Xcode HeaderDoc和Doxygen文档化你的Objective-C和Swift代码</a></p>
<p><a href="http://00red.com" target="_blank" rel="external">Swift项目兼容Objective-c问题汇总</a></p>
<p><a href="http://benbeng.leanote.com/post/On-Demand-Resources-Guide" target="_blank" rel="external">按需加载资源开发指南</a></p>
<p><a href="http://www.cocoachina.com/ios/20150617/12165.html" target="_blank" rel="external">10步成为专业iOS开发者——从零起步</a></p>
<p><a href="http://www.cocoachina.com/swift/" target="_blank" rel="external">cocoachina-swift集锦</a></p>
<p><a href="http://www.cocoachina.com/special/xcode/" target="_blank" rel="external">cocoachina-xcode集锦</a></p>
<h1 id="swift函数"><a href="#swift函数" class="headerlink" title="swift函数"></a>swift函数</h1><p><a href="http://swift.gg/2015/08/06/swift-2-flatmap/" target="_blank" rel="external">Swift 2.0: 理解 flatMap</a></p>
<p><a href="http://swift.gg/2015/08/28/swift_when_the_functional_approach_is_not_right/" target="_blank" rel="external">Swift:什么时候不适合使用函数式方法</a></p>
<p><a href="http://www.cocoachina.com/industry/20140619/8885.html" target="_blank" rel="external">Swift中的标准函数</a></p>
<p><a href="http://www.cocoachina.com/swift/20150619/12173.html" target="_blank" rel="external">Swift高阶函数：Map，Filter，Reduce等-Part 1</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="http://www.niaogebiji.com/article-6325-1.html" target="_blank" rel="external">App store最新审核标准公布</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>#官方文档<br><a href="https://developer.apple.com/swift/" target="_blank" rel="external">苹果出品，必属精品！</a></p>
<p><a href="https://github.com/zh]]>
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="swift" scheme="http://www.zhuli8.com/tags/swift/"/>
    
      <category term="swift" scheme="http://www.zhuli8.com/categories/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift版设计模式之代理模式-Proxy程序替你聊天]]></title>
    <link href="http://www.zhuli8.com/2015/06/21/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy%E7%A8%8B%E5%BA%8F%E6%9B%BF%E4%BD%A0%E8%81%8A%E5%A4%A9/"/>
    <id>http://www.zhuli8.com/2015/06/21/代理模式-Proxy程序替你聊天/</id>
    <published>2015-06-21T09:05:10.000Z</published>
    <updated>2015-07-20T02:17:40.000Z</updated>
    <content type="html"><![CDATA[<p>#代理模式比喻<br>跟MM在网上聊天，她们一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
<p>#代理模式意图<br>代理模式(Proxy)为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>#代理模式类图<br><img src="http://www.zhuli8.com/photos/designpattern/proxy.gif" alt=""></p>
<p>#代理模式实现<br>定义RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Proxy所代表的真实实体</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span>: <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> mm:<span class="type">Girl</span></span><br><span class="line">    <span class="keyword">init</span>(mm:<span class="type">Girl</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.mm=mm</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">operation</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> mm.word!&#123;<span class="comment">//记得强制解包哦</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"hi,你好"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"hi,你好"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"你从哪里来呀？"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"火星"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"你多大了？"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="number">18</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"身高多少呀？"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"2.5m"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            say()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"我出场了……"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存一个RealSubject引用，使得代理可以访问实体并提供一个与Subject相同的接口来代替实体</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>: <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rs:<span class="type">RealSubject</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(mm:<span class="type">Girl</span>)&#123;</span><br><span class="line">        rs=<span class="type">RealSubject</span>(mm: mm)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">operation</span><span class="params">()</span></span> &#123;</span><br><span class="line">        rs.operation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>聊天的MM</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> word:<span class="built_in">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理模式客户端应用</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> mm=<span class="function"><span class="title">Girl</span><span class="params">()</span></span></span><br><span class="line">mm.word=<span class="string">"hi,你好"</span></span><br><span class="line"></span><br><span class="line"><span class="tag">var</span> proxy=<span class="function"><span class="title">Proxy</span><span class="params">(mm: mm)</span></span></span><br><span class="line">proxy.<span class="function"><span class="title">operation</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>#代理模式总结<br>吼吼，这是不是就是传说中的机器人聊天原理啊！代理模式给某一个对象提供一个代理对象，由代理对象控制对源对象的引用。代理就是一个人或一个结构代表另一个人或者一个机构采取行动。我们身边到处都是代理模式，如远程代理、虚拟代理、安全代理、智能指引等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>#代理模式比喻<br>跟MM在网上聊天，她们一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
<p>#代理模式意]]>
    </summary>
    
      <category term="swift" scheme="http://www.zhuli8.com/tags/swift/"/>
    
      <category term="设计模式" scheme="http://www.zhuli8.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://www.zhuli8.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift版设计模式之中介者模式-MM们打麻将我来算账]]></title>
    <link href="http://www.zhuli8.com/2015/06/14/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-MM%E4%BB%AC%E6%89%93%E9%BA%BB%E5%B0%86%E6%88%91%E6%9D%A5%E7%AE%97%E8%B4%A6/"/>
    <id>http://www.zhuli8.com/2015/06/14/中介者模式-MM们打麻将我来算账/</id>
    <published>2015-06-14T04:05:10.000Z</published>
    <updated>2015-07-20T02:18:18.000Z</updated>
    <content type="html"><![CDATA[<p>#中介者模式比喻<br>四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</p>
<p>#中介者模式意图<br>中介者模式(Mediator)用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p>#中介者模式类图<br><img src="http://www.zhuli8.com/photos/designpattern/mediator.gif" alt=""></p>
<p>#中介者模式实现<br>抽象中介者，定义了MM需要什么样的中介者</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(money:Double,girl:Girl)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体中介者对象，实现抽象类的方法，他需要知道所有具体的MM，并给MM核算服务</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>: <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl1:<span class="type">FirstGirl</span>?</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl2:<span class="type">SecondGirl</span>?</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl3:<span class="type">ThirdGirl</span>?</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl4:<span class="type">FourthGirl</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(<span class="keyword">var</span> money: Double, girl: Girl)</span></span> &#123;</span><br><span class="line">        money=money*<span class="number">10</span><span class="comment">////中介者的处理，此处业务比较简单假设一个筹码代表10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> girl===girl1&#123;</span><br><span class="line">            girl1?.getResult(money)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> girl===girl2&#123;</span><br><span class="line">            girl2?.getResult(money)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> girl===girl3&#123;</span><br><span class="line">            girl3?.getResult(money)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> girl===girl4&#123;</span><br><span class="line">            girl4?.getResult(money)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象女孩类</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mediator:<span class="type">Mediator</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(mediator:<span class="type">Mediator</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.mediator=mediator<span class="comment">////得到中介者对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    告诉中介者筹码数，让其帮我核算</span><br><span class="line">    */</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        mediator.calculate(money, girl: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩1，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识且依靠中介者对象核算</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The FirstGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩2，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识依靠中介者对象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The SecondGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩3，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识依靠中介者对象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The ThirdGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩4，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识依靠中介者对象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourthGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The FourthGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中介者模式客户端应用</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> boy=<span class="function"><span class="title">Boy</span><span class="params">()</span></span><span class="comment">//核算中介</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//四个打麻将的MM</span></span><br><span class="line"><span class="tag">var</span> girl1=<span class="function"><span class="title">FirstGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"><span class="tag">var</span> girl2=<span class="function"><span class="title">SecondGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"><span class="tag">var</span> girl3=<span class="function"><span class="title">ThirdGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"><span class="tag">var</span> girl4=<span class="function"><span class="title">FourthGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//四个MM让我调节</span></span><br><span class="line">boy.girl1=girl1</span><br><span class="line">boy.girl2=girl2</span><br><span class="line">boy.girl3=girl3</span><br><span class="line">boy.girl4=girl4</span><br><span class="line">girl1.<span class="function"><span class="title">notify</span><span class="params">(<span class="number">10</span>)</span></span></span><br><span class="line">girl2.<span class="function"><span class="title">notify</span><span class="params">(<span class="number">20</span>)</span></span></span><br><span class="line">girl3.<span class="function"><span class="title">notify</span><span class="params">(-<span class="number">20</span>)</span></span></span><br><span class="line">girl4.<span class="function"><span class="title">notify</span><span class="params">(-<span class="number">10</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>#中介者模式总结<br>中介者的出现减少了MM们的耦合，使得可以独立地改变和复用各个Mediator和Girl，具体女孩类的改变不会影响到其他女孩类，而只是Boy发生变化。Boy把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，关注的对象就从对象各自本身的行为转移到她们之间的交互上来。即中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而是它们可以松散耦合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象，保证这些作用可以彼此独立的变化。中介者模式将多对多的相互作用转化为一对多的相互作用。中介者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>#中介者模式比喻<br>四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</p>
<p>#中介者模式意图<br>中介者模式(Mediator)用一个中介对]]>
    </summary>
    
      <category term="swift" scheme="http://www.zhuli8.com/tags/swift/"/>
    
      <category term="设计模式" scheme="http://www.zhuli8.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://www.zhuli8.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[@OBJC和DYNAMIC]]></title>
    <link href="http://www.zhuli8.com/2015/06/07/OBJC%E5%92%8CDYNAMIC/"/>
    <id>http://www.zhuli8.com/2015/06/07/OBJC和DYNAMIC/</id>
    <published>2015-06-07T02:44:45.000Z</published>
    <updated>2015-07-20T02:18:42.000Z</updated>
    <content type="html"><![CDATA[<p><div class="post-content clearfix"><br>        <p>虽然说 Swift 语言的初衷是希望能摆脱 Objective-C 的沉重的历史包袱和约束，但是不可否认的是经过了二十多年的洗礼，Cocoa 框架早就烙上了不可磨灭的 Objective-C 的印记。无数的第三方库是用 Objective-C 写成的，这些积累无论是谁都不能小觑。因此，在最初的版本中，Swift 不得不考虑与 Objective-C 的兼容。</p></div></p>
<p>Apple 采取的做法是允许我们在同一个项目中同时使用 Swift 和 Objective-C 来进行开发。其实一个项目中的 Objective-C 文件和 Swift 文件是处于两个不同世界中的，为了让它们能相互联通，我们需要添加一些桥梁。</p><br><p>首先通过添加 <code>{product-module-name}-Bridging-Header.h</code> 文件，并在其中填写想要使用的头文件名称，我们就可以很容易地在 Swift 中使用 Objective-C 代码了。Xcode 为了简化这个设定，甚至在 Swift 项目中第一次导入 Objective-C 文件时会主动弹框进行询问是否要自动创建这个文件，可以说是非常方便。</p><br><p>但是如果想要在 Objective-C 中使用 Swift 的类型的时候，事情就复杂一些。如果是来自外部的框架，那么这个框架与 Objective-C 项目肯定不是处在同一个 target 中的，我们需要对外部的 Swift module 进行导入。这个其实和使用 Objective-C 的原来的 Framework 是一样的，对于一个项目来说，外界框架是由 Swift 写的还是 Objective-C 写的，两者并没有太大区别。我们通过使用 2013 年新引入的 <code>@import</code> 来引入 module：</p><br><pre><code>@import MySwiftKit;<br></code></pre><br><p>之后就可以正常使用这个 Swift 写的框架了。</p><br><p>如果想要在 Objective-C 里使用的是同一个项目中的 Swift 的源文件的话，可以直接导入自动生成的头文件 <code>{product-module-name}-Swift.h</code> 来完成。比如项目的 target 叫做 <code>MyApp</code> 的话，我们就需要在 Objective-C 文件中写</p><br><pre><code>#import “MyApp-Swift.h”<br></code></pre><br><p>但这只是故事的开始。Objective-C 和 Swift 在底层使用的是两套完全不同的机制，Cocoa 中的 Objective-C 对象是基于运行时的，它从骨子里遵循了 KVC (Key-Value Coding，通过类似字典的方式存储对象信息) 以及动态派发 (Dynamic Dispatch，在运行调用时再决定实际调用的具体实现)。而 Swift 为了追求性能，如果没有特殊需要的话，是不会在运行时再来决定这些的。也就是说，Swift 类型的成员或者方法在编译时就已经决定，而运行时便不再需要经过一次查找，而可以直接使用。</p><br><p>显而易见，这带来的问题是如果我们要使用 Objective-C 的代码或者特性来调用纯 Swift 的类型时候，我们会因为找不到所需要的这些运行时信息，而导致失败。解决起来也很简单，在 Swift 类型文件中，我们可以将需要暴露给 Objective-C 使用的任何地方 (包括类，属性和方法等) 的声明前面加上 <code>@objc</code> 修饰符。注意这个步骤只需要对那些不是继承自 <code>NSObject</code> 的类型进行，如果你用 Swift 写的 class 是继承自 <code>NSObject</code> 的话，Swift 会默认自动为所有的非 private 的类和成员加上 <code>@objc</code>。这就是说，对一个 <code>NSObject</code> 的子类，你只需要导入相应的头文件就可以在 Objective-C 里使用这个类了。</p><br><p><code>@objc</code> 修饰符的另一个作用是为 Objective-C 侧重新声明方法或者变量的名字。虽然绝大部分时候自动转换的方法名已经足够好用 (比如会将 Swift 中类似 <code>init(name: String)</code> 的方法转换成 <code>-initWithName:(NSString *)name</code> 这样)，但是有时候我们还是期望 Objective-C 里使用和 Swift 中不一样的方法名或者类的名字，比如 Swift 里这样的一个类：</p><br><pre><code>class 我的类 {<br>    func 打招呼(名字: String) {<br>        println(“哈喽，(名字)”)<br>    }<br>}<br>我的类().打招呼(“小明”)<br></code></pre><br><p>Objective-C 的话是无法使用中文来进行调用的，因此我们<strong>必须</strong>使用 <code>@objc</code> 将其转为 ASCII 才能在 Objective-C 里访问：</p>

<p><pre><code>@objc(MyClass)<br>class 我的类 {<br>    @objc(greeting:)<br>    func 打招呼(名字: String) {<br>        println(“哈喽，(名字)”)<br>    }<br>}<br></code></pre></p>
<p></p><p>这样，我们在 Objective-C 里就能调用 <code>[[MyClass new] greeting:@”XiaoMing”]</code> 这样的代码了 (虽然比起原来一点都不好玩了)。另外，正如上面所说的以及在 <a href="http://swifter.tips/selector/" target="_blank" rel="external">Selector</a> 一节中所提到的，即使是 <code>NSObject</code> 的子类，Swift 也不会在被标记为 <code>private</code> 的方法或成员上自动加 <code>@objc</code>。如果我们需要使用这些内容的动态特性的话，我们需要手动给它们加上 <code>@objc</code> 修饰。</p><p></p>
<p></p><p>添加 <code>@objc</code> 修饰符并不意味着这个方法或者属性会变成动态派发，Swift 依然可能会将其优化为静态调用。如果你需要和 Objective-C 里动态调用时相同的运行时特性的话，你需要使用的修饰符是 <code>dynamic</code>。一般情况下在做 app 开发时应该用不上，但是在施展一些像动态替换方法或者运行时再决定实现这样的 “黑魔法” 的时候，我们就需要用到 <code>dynamic</code> 修饰符了。在之后的 KVO 一节中，我们还会提到一个关于使用 <code>dynamic</code> 的实例。</p><br>    <br>作者王巍 <a href="http://swifter.tips/" target="_blank" rel="external">(@onevcat)</a> 原文地址 <a href="http://swifter.tips/objc-dynamic/" target="_blank" rel="external">http://swifter.tips/objc-dynamic/</a><p></p>
]]></content>
    <summary type="html">
    <![CDATA[swift的@OBJC和DYNAMIC]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="swift" scheme="http://www.zhuli8.com/tags/swift/"/>
    
      <category term="swift" scheme="http://www.zhuli8.com/categories/swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[与调试器共舞 - LLDB 的华尔兹]]></title>
    <link href="http://www.zhuli8.com/2015/05/31/%E4%B8%8E%E8%B0%83%E8%AF%95%E5%99%A8%E5%85%B1%E8%88%9E%20-%20LLDB%20%E7%9A%84%E5%8D%8E%E5%B0%94%E5%85%B9/"/>
    <id>http://www.zhuli8.com/2015/05/31/与调试器共舞 - LLDB 的华尔兹/</id>
    <published>2015-05-31T12:40:39.000Z</published>
    <updated>2016-01-19T08:14:27.000Z</updated>
    <content type="html"><![CDATA[<p>你是否曾经苦恼于理解你的代码，而去尝试打印一个变量的值？</p>

<pre><code>NSLog(@"%@", whatIsInsideThisThing);
</code></pre>

<p>或者跳过一个函数调用来简化程序的行为？</p>

<pre><code>NSNumber *n = @7; // 实际应该调用这个函数：Foo();
</code></pre>

<p>或者短路一个逻辑检查？</p>

<pre><code>if (1 || theBooleanAtStake) { ... }
</code></pre>

<p>或者伪造一个函数实现？</p>

<pre><code>int calculateTheTrickyValue {
  return 9;

  /*
   先这么着
   ...
}
</code></pre>

<p>并且每次必须重新编译，从头开始？</p>

<p>构建软件是复杂的，并且 Bug 总会出现。一个常见的修复周期就是修改代码，编译，重新运行，并且祈祷出现最好的结果。</p>

<p>但是不一定要这么做。你可以使用调试器。而且即使你已经知道如何使用调试器检查变量，它可以做的还有很多。</p>

<p>这篇文章将试图挑战你对调试的认知，并详细地解释一些你可能还不了解的基本原理，然后展示一系列有趣的例子。现在就让我们开始与调试器共舞一曲华尔兹，看看最后能达到怎样的高度。</p>

<h2 id="lldb">LLDB</h2>

<p><a href="http://lldb.llvm.org/" target="_blank" rel="external">LLDB</a> 是一个有着 REPL 的特性和 C++ ,Python 插件的<a href="http://lldb.llvm.org/source.html" target="_blank" rel="external">开源</a>调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。(<a href="http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1.html" target="_blank" rel="external">这里</a>有一个关于调试器如何工作的总体的解释。)</p>

<p>你以前有可能已经使用过调试器，即使只是在 Xcode 的界面上加一些断点。但是通过一些小的技巧，你就可以做一些非常酷的事情。<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="external">GDB to LLDB</a> 参考是一个非常好的调试器可用命令的总览。你也可以安装 <a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a>，它是一个开源的 LLDB 插件合辑，这会使调试变得更加有趣。</p>

<p>与此同时，让我们以在调试器中打印变量来开始我们的旅程吧。</p>

<h2 id="">基础</h2>

<p>这里有一个简单的小程序，它会打印一个字符串。注意断点已经被加在第 8 行。断点可以通过点击 Xcode 的源码窗口的侧边槽进行创建。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-20_at_10.01.46_PM.png" width="400"></p>

<p>程序会在这一行停止运行，并且控制台会被打开，允许我们和调试器交互。那我们应该打些什么呢？</p>

<h3 id="_help_"><em>help</em></h3>

<p>最简单命令是 <code>help</code>，它会列举出所有的命令。如果你忘记了一个命令是做什么的，或者想知道更多的话，你可以通过 <code>help &lt;command&gt;</code> 来了解更多细节，例如 <code>help print</code> 或者 <code>help thread</code>。如果你甚至忘记了 <code>help</code> 命令是做什么的，你可以试试 <code>help help</code>。不过你如果知道这么做，那就说明你大概还没有忘光这个命令。😛</p>

<h3 id="_print_"><em>print</em></h3>

<p>打印值很简单；只要试试 <code>print</code> 命令:</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-20_at_10.09.38_PM.png" width="600"></p>

<p>LLDB 实际上会作前缀匹配。所以你也可以使用 <code>prin</code>，<code>pri</code>，或者 <code>p</code>。但你不能使用 <code>pr</code>，因为 LLDB 不能消除和 <code>process</code> 的歧义 (幸运的是 <code>p</code> 并没有歧义)。</p>

<p>你可能还注意到了，结果中有个 <code>$0</code>。实际上你可以使用它来指向这个结果。试试 <code>print $0 + 7</code>，你会看到 <code>106</code>。任何以美元符开头的东西都是存在于 LLDB 的命名空间的，它们是为了帮助你进行调试而存在的。</p>

<h3 id="_expression_"><em>expression</em></h3>

<p>如果想改变一个值怎么办？你或许会猜 <em>modify</em>。其实这时候我们要用到的是 <code>expression</code> 这个方便的命令。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-20_at_10.15.01_PM.png" width="240"></p>

<p>这不仅会改变调试器中的值，实际上它改变了程序中的值。这时候继续执行程序，将会打印 <code>42 red balloons</code>。神奇吧。</p>

<p>注意，从现在开始，我们将会偷懒分别以 <code>p</code> 和 <code>e</code> 来代替 <code>print</code> 和 <code>expression</code>。</p>

<h3 id="_print_">什么是 <em>print</em> 命令</h3>

<p>考虑一个有意思的表达式：<code>p count = 18</code>。如果我们运行这条命令，然后打印 <code>count</code> 的内容。我们将看到它的结果与 <code>expression count = 18</code> 一样。</p>

<p>和 <code>expression</code> 不同的是，<code>print</code> 命令不需要参数。比如 <code>e -h +17</code> 中，你很难区分到底是以 <code>-h</code> 为标识，仅仅执行 <code>+17</code> 呢，还是要计算 <code>17</code> 和 <code>h</code> 的差值。连字符号确实很让人困惑，你或许得不到自己想要的结果。</p>

<p>幸运的是，解决方案很简单。用 <code>–</code> 来表征标识的结束，以及输入的开始。如果想要 <code>-h</code> 作为标识，就用 <code>e -h – +17</code>，如果想计算它们的差值，就使用 <code>e – -h +17</code>。因为一般来说不使用标识的情况比较多，所以 <code>e –</code> 就有了一个简写的方式，那就是 <code>print</code>。</p>

<p>输入 <code>help print</code>，然后向下滚动，你会发现：</p>

<pre><code>'print' is an abbreviation for 'expression --'.   
(print是 `expression --` 的缩写)
</code></pre>

<h3 id="">打印对象</h3>

<p>尝试输入</p>

<pre><code>p objects
</code></pre>

<p>输出会有点啰嗦</p>

<pre><code>(NSString *) $7 = 0x0000000104da4040 @"red balloons"
</code></pre>

<p>如果我们尝试打印结构更复杂的对象，结果甚至会更糟</p>

<pre><code>(lldb) p @[ @"foo", @"bar" ]

(NSArray *) $8 = 0x00007fdb9b71b3e0 @"2 objects" 
</code></pre>

<p>实际上，我们想看的是对象的 <code>description</code> 方法的结果。我么需要使用 <code>-O</code> (字母 O，而不是数字 0) 标志告诉 <code>expression</code> 命令以 <code>对象</code> (Object) 的方式来打印结果。 </p>

<pre><code>(lldb) e -O -- $8
&lt;__NSArrayI 0x7fdb9b71b3e0&gt;(
foo,
bar
)
</code></pre>

<p>幸运的是，<code>e -o –</code> 有也有个别名，那就是 <code>po</code> (<strong>p</strong>rint <strong>o</strong>bject 的缩写)，我们可以使用它来进行简化：</p>

<pre><code>(lldb) po $8
&lt;__NSArrayI 0x7fdb9b71b3e0&gt;(
foo,
bar
)
(lldb) po @"lunar"
lunar
(lldb) p @"lunar"
(NSString *) $13 = 0x00007fdb9d0003b0 @"lunar"
</code></pre>

<h3 id="">打印变量</h3>

<p>可以给 <code>print</code> 指定不同的打印格式。它们都是以 <code>print/&lt;fmt&gt;</code> 或者简化的 <code>p/&lt;fmt&gt;</code> 格式书写。下面是一些例子：</p>

<p>默认的格式</p>

<pre><code>(lldb) p 16
16
</code></pre>

<p>十六进制:</p>

<pre><code>(lldb) p/x 16
0x10
</code></pre>

<p>二进制 (<code>t</code> 代表 <strong>t</strong>wo)：</p>

<pre><code>(lldb) p/t 16
0b00000000000000000000000000010000
(lldb) p/t (char)16
0b00010000
</code></pre>

<p>你也可以使用 <code>p/c</code> 打印字符，或者 <code>p/s</code> 打印以空终止的字符串 (译者注：以 ‘\0’ 结尾的字符串)。 <br><br><a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="external">这里</a>是格式的完整清单。</p>

<h3 id="">变量</h3>

<p>现在你已经可以打印对象和简单类型，并且知道如何使用 <code>expression</code> 命令在调试器中修改它们了。现在让我们使用一些变量来减少输入量。就像你可以在 C 语言中用 <code>int a = 0</code> 来声明一个变量一样，你也可以在 LLDB 中做同样的事情。不过为了能使用声明的变量，变量<strong>必须</strong>以美元符开头。</p>

<pre><code>(lldb) e int $a = 2
(lldb) p $a * 19
38
(lldb) e NSArray *$array = @[ @"Saturday", @"Sunday", @"Monday" ]
(lldb) p [$array count]
2
(lldb) po [[$array objectAtIndex:0] uppercaseString]
SATURDAY
(lldb) p [[$array objectAtIndex:$a] characterAtIndex:0]
error: no known method '-characterAtIndex:'; cast the message send to the method's return type
error: 1 errors parsing expression
</code></pre>

<p>悲剧了，LLDB 无法确定涉及的类型 (译者注：返回的类型)。这种事情常常发生，给个说明就好了：</p>

<pre><code>(lldb) p (char)[[$array objectAtIndex:$a] characterAtIndex:0]
'M'
(lldb) p/d (char)[[$array objectAtIndex:$a] characterAtIndex:0]
77
</code></pre>

<p>变量使调试器变的容易使用得多，想不到吧？😉</p>

<h3 id="">流程控制</h3>

<p>当你通过 Xcode 的源码编辑器的侧边槽 (或者通过下面的方法) 插入一个断点，程序到达断点时会就会停止运行。</p>

<p>调试条上会出现四个你可以用来控制程序的执行流程的按钮。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_10.37.45_AM.png" width="200"></p>

<p>从左到右，四个按钮分别是：continue，step over，step into，step out。</p>

<p>第一个，continue 按钮，会取消程序的暂停，允许程序正常执行 (要么一直执行下去，要么到达下一个断点)。在 LLDB 中，你可以使用 <code>process continue</code> 命令来达到同样的效果，它的别名为 <code>continue</code>，或者也可以缩写为 <code>c</code>。</p>

<p>第二个，step over 按钮，会以黑盒的方式执行一行代码。如果所在这行代码是一个函数调用，那么就<strong>不会</strong>跳进这个函数，而是会执行这个函数，然后继续。LLDB 则可以使用 <code>thread step-over</code>，<code>next</code>，或者 <code>n</code> 命令。</p>

<p>如果你确实想跳进一个函数调用来调试或者检查程序的执行情况，那就用第三个按钮，step in，或者在LLDB中使用 <code>thread step in</code>，<code>step</code>，或者 <code>s</code> 命令。注意，当前行不是函数调用时，<code>next</code> 和 <code>step</code> 效果是一样的。</p>

<p>大多数人知道 <code>c</code>，<code>n</code> 和 <code>s</code>，但是其实还有第四个按钮，step out。如果你曾经不小心跳进一个函数，但实际上你想跳过它，常见的反应是重复的运行 <code>n</code> 直到函数返回。其实这种情况，step out 按钮是你的救世主。它会继续执行到下一个返回语句 (直到一个堆栈帧结束) 然后再次停止。</p>

<h4 id="">例子</h4>

<p>考虑下面一段程序：</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_10.53.52_AM.png" width="320"></p>

<p>假如我们运行程序，让它停止在断点，然后执行下面一些列命令：</p>

<pre><code>p i
n
s
p i
finish
p i
frame info
</code></pre>

<p>这里，<code>frame info</code> 会告诉你当前的行数和源码文件，以及其他一些信息；查看 <code>help frame</code>，<code>help thread</code> 和 <code>help process</code> 来获得更多信息。这一串命令的结果会是什么？看答案之前请先想一想。</p>

<pre><code>(lldb) p i
(int) $0 = 99
(lldb) n
2014-11-22 10:49:26.445 DebuggerDance[60182:4832768] 101 is odd!
(lldb) s
(lldb) p i
(int) $2 = 110
(lldb) finish
2014-11-22 10:49:35.978 DebuggerDance[60182:4832768] 110 is even!
(lldb) p i
(int) $4 = 99
(lldb) frame info
frame #0: 0x000000010a53bcd4 DebuggerDance`main + 68 at main.m:17
</code></pre>

<p>它始终在 17 行的原因是 <code>finish</code> 命令一直运行到 <code>isEven()</code> 函数的 <code>return</code>，然后立刻停止。注意即使它还在 17 行，其实这行已经被执行过了。</p>

<h4 id="threadreturn">Thread Return</h4>

<p>调试时，还有一个很棒的函数可以用来控制程序流程：<code>thread return</code> 。它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后立刻执行返回命令，跳出当前栈帧。这意味这函数剩余的部分<strong>不会被执行</strong>。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是在函数的开头执行这个命令，是个非常好的隔离这个函数，伪造返回值的方式 。</p>

<p>让我们稍微修改一下上面代码段并运行：</p>

<pre><code>p i
s
thread return NO
n
p even0
frame info
</code></pre>

<p>看答案前思考一下。下面是答案：</p>

<pre><code>(lldb) p i
(int) $0 = 99
(lldb) s
(lldb) thread return NO
(lldb) n
(lldb) p even0
(BOOL) $2 = NO
(lldb) frame info
frame #0: 0x00000001009a5cc4 DebuggerDance`main + 52 at main.m:17
</code></pre>

<h2 id="">断点</h2>

<p>我们都把断点作为一个停止程序运行，检查当前状态，追踪 bug 的方式。但是如果我们改变和断点交互的方式，很多事情都变成可能。</p>

<blockquote><br>  <p>断点允许控制程序什么时候停止，然后允许命令的运行。</p><br></blockquote>

<p>想象把断点放在函数的开头，然后用 <code>thread return</code> 命令重写函数的行为，然后继续。想象一下让这个过程自动化，听起来不错，不是吗？</p>

<h3 id="">管理断点</h3>

<p>Xcode 提供了一系列工具来创建和管理断点。我们会一个个看过来并介绍 LLDB 中等价的命令 (是的，你可以在调试器<strong>内部</strong>添加断点)。</p>

<p>在 Xcode 的左侧面板，有一组按钮。其中一个看起来像断点。点击它打开断点导航，这是一个可以快速管理所有断点的面板。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_11.38.24_AM.png" width="620"></p>

<p>在这里你可以看到所有的断点 - 在 LLDB 中通过 <code>breakpoint list</code> (或者 <code>br li</code>) 命令也做同样的事儿。你也可以点击单个断点来开启或关闭 - 在 LLDB 中使用 <code>breakpoint enable &lt;breakpointID&gt;</code> 和 <code>breakpoint disable &lt;breakpointID&gt;</code>：</p>

<pre><code>(lldb) br li
Current breakpoints:
1: file = '/Users/arig/Desktop/DebuggerDance/DebuggerDance/main.m', line = 16, locations = 1, resolved = 1, hit count = 1

  1.1: where = DebuggerDance`main + 27 at main.m:16, address = 0x000000010a3f6cab, resolved, hit count = 1

(lldb) br dis 1
1 breakpoints disabled.
(lldb) br li
Current breakpoints:
1: file = '/Users/arig/Desktop/DebuggerDance/DebuggerDance/main.m', line = 16, locations = 1 Options: disabled

  1.1: where = DebuggerDance`main + 27 at main.m:16, address = 0x000000010a3f6cab, unresolved, hit count = 1

(lldb) br del 1
1 breakpoints deleted; 0 breakpoint locations disabled.
(lldb) br li
No breakpoints currently set.
</code></pre>

<h3 id="">创建断点</h3>

<p>在上面的例子中，我们通过在源码页面器的滚槽 <code>16</code> 上点击来创建断点。你可以通过把断点拖拽出滚槽，然后释放鼠标来删除断点 (消失时会有一个非常可爱的噗的一下的动画)。你也可以在断点导航页选择断点，然后按下删除键删除。</p>

<p>要在调试器中创建断点，可以使用 <code>breakpoint set</code> 命令。</p>

<pre><code>(lldb) breakpoint set -f main.m -l 16
Breakpoint 1: where = DebuggerDance`main + 27 at main.m:16, address = 0x000000010a3f6cab
</code></pre>

<p>也可以使用缩写形式 <code>br</code>。虽然 <code>b</code> 是一个完全不同的命令 (<code>_regexp-break</code> 的缩写)，但恰好也可以实现和上面同样的效果。</p>

<pre><code>(lldb) b main.m:17
Breakpoint 2: where = DebuggerDance`main + 52 at main.m:17, address = 0x000000010a3f6cc4
</code></pre>

<p>也可以在一个符号 (C 语言函数) 上创建断点，而完全不用指定哪一行 </p>

<pre><code>(lldb) b isEven
Breakpoint 3: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x000000010a3f6d00
(lldb) br s -F isEven
Breakpoint 4: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x000000010a3f6d00
</code></pre>

<p>这些断点会准确的停止在函数的开始。Objective-C 的方法也完全可以：</p>

<pre><code>(lldb) breakpoint set -F "-[NSArray objectAtIndex:]"
Breakpoint 5: where = CoreFoundation`-[NSArray objectAtIndex:], address = 0x000000010ac7a950
(lldb) b -[NSArray objectAtIndex:]
Breakpoint 6: where = CoreFoundation`-[NSArray objectAtIndex:], address = 0x000000010ac7a950
(lldb) breakpoint set -F "+[NSSet setWithObject:]"
Breakpoint 7: where = CoreFoundation`+[NSSet setWithObject:], address = 0x000000010abd3820
(lldb) b +[NSSet setWithObject:]
Breakpoint 8: where = CoreFoundation`+[NSSet setWithObject:], address = 0x000000010abd3820
</code></pre>

<p>如果想在 Xcode 的UI上创建符号断点，你可以点击断点栏左侧的 <code>+</code> 按钮。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_11.52.50_AM.png" width="300"></p>

<p>然后选择第三个选项：</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_11.54.44_AM.png" width="430"></p>

<p>这时会出现一个弹出框，你可以在里面添加例如 <code>-[NSArray objectAtIndex:]</code> 这样的符号断点。这样<strong>每次</strong>调用这个函数的时候，程序都会停止，不管是你调用还是苹果调用。</p>

<p>如果你 Xcode 的 UI 上右击<strong>任意</strong>断点，然后选择 “Edit Breakpoint” 的话，会有一些非常诱人的选择。</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_11.58.06_AM.png" width="570"></p>

<p>这里，断点已经被修改为<strong>只有</strong>当 <code>i</code> 是 <code>99</code> 的时候才会停止。你也可以使用 “ignore” 选项来告诉断点最初的 <code>n</code> 次调用 (并且条件为真的时候) 的时候不要停止。</p>

<p>接下来介绍 ‘Add Action’ 按钮…</p>

<h3 id="action">断点行为 (Action)</h3>

<p>上面的例子中，你或许想知道每一次到达断点的时候 <code>i</code> 的值。我们可以使用 <code>p i</code> 作为断点行为。这样每次到达断点的时候，都会自动运行这个命令。</p>

<p><img src="http://img.objccn.io/issue-19/Screen_Shot_2014-11-22_at_12.01.32_PM.png" width="600"></p>

<p>你也可以添加多个行为，可以是调试器命令，shell 命令，也可以是更直接的打印：</p>

<p><img src="http://img.objccn.io/issue-19/Image_2014-11-22_at_12.06.34_PM.png" width="400"></p>

<p>可以看到它打印 <code>i</code>，然后大声念出那个句子，接着打印了自定义的表达式。</p>

<p>下面是在 LLDB 而不是 Xcode 的 UI 中做这些的时候，看起来的样子。</p>

<pre><code>(lldb) breakpoint set -F isEven
Breakpoint 1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00
(lldb) breakpoint modify -c 'i == 99' 1
(lldb) breakpoint command add 1
Enter your debugger command(s).  Type 'DONE' to end.
&gt; p i
&gt; DONE
(lldb) br li 1
1: name = 'isEven', locations = 1, resolved = 1, hit count = 0
    Breakpoint commands:
      p i

Condition: i == 99

  1.1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00, resolved, hit count = 0 
</code></pre>

<p>接下来说说自动化。</p>

<h3 id="">赋值后继续运行</h3>

<p>看编辑断点弹出窗口的底部，你还会看到一个选项： <em>“Automatically continue after evaluation actions.”</em> 。它仅仅是一个选择框，但是却很强大。选中它，调试器会运行你所有的命令，然后继续运行。看起来就像没有执行任何断点一样 (除非断点太多，运行需要一段时间，拖慢了你的程序)。</p>

<p>这个选项框的效果和让最后断点的最后一个行为是 <code>continue</code> 一样。选框只是让这个操作变得更简单。调试器的输出是：</p>

<pre><code>(lldb) breakpoint set -F isEven
Breakpoint 1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00
(lldb) breakpoint command add 1
Enter your debugger command(s).  Type 'DONE' to end.
&gt; continue
&gt; DONE
(lldb) br li 1
1: name = 'isEven', locations = 1, resolved = 1, hit count = 0
    Breakpoint commands:
      continue

  1.1: where = DebuggerDance`isEven + 16 at main.m:4, address = 0x00000001083b5d00, resolved, hit count = 0
</code></pre>

<p>执行断点后自动继续运行，允许你完全通过断点来修改程序！你可以在某一行停止，运行一个 <code>expression</code> 命令来改变变量，然后继续运行。</p>

<h4 id="">例子</h4>

<p>想想所谓的”打印调试”技术吧，不要这么做：</p>

<pre><code>NSLog(@"%@", whatIsInsideThisThing);
</code></pre>

<p>而是用个打印变量的断点替换 log 语句，然后继续运行。</p>

<p>也不要：</p>

<pre><code>int calculateTheTrickyValue {
  return 9;

  /*
   Figure this out later.
   ...
}
</code></pre>

<p>而是加一个使用 <code>thread return 9</code> 命令的断点，然后让它继续运行。</p>

<p>符号断点加上 action 真的很强大。你也可以在你朋友的 Xcode 工程上添加一些断点，并且加上大声朗读某些东西的 action。看看他们要花多久才能弄明白发生了什么。😄</p>

<h3 id="">完全在调试器内运行</h3>

<p>在开始舞蹈之前，还有一件事要看一看。实际上你可以在调试器中执行任何 C/Objective-C/C++/Swift 的命令。唯一的缺点就是不能创建新函数… 这意味着不能创建新的类，block，函数，有虚拟函数的 C++ 类等等。除此之外，它都可以做。</p>

<p>我们可以申请分配一些字节：</p>

<pre><code>(lldb) e char *$str = (char *)malloc(8)
(lldb) e (void)strcpy($str, "munkeys")
(lldb) e $str[1] = 'o'
(char) $0 = 'o'
(lldb) p $str
(char *) $str = 0x00007fd04a900040 "monkeys"
</code></pre>

<p>我们可以查看内存 (使用 <code>x</code> 命令)，来看看新数组中的四个字节：</p>

<pre><code>(lldb) x/4c $str
0x7fd04a900040: monk
</code></pre>

<p>我们也可以去掉 3 个字节 (<code>x</code> 命令需要斜引号，因为它只有一个内存地址的参数，而不是表达式；使用 <code>help x</code> 来获得更多信息)：</p>

<pre><code>(lldb) x/1w `$str + 3`
0x7fd04a900043: keys
</code></pre>

<p>做完了之后，一定不要忘了释放内存，这样才不会内存泄露。(哈，虽然这是调试器用到的内存)：</p>

<pre><code>(lldb) e (void)free($str)
</code></pre>

<h2 id="">让我们起舞</h2>

<p>现在我们已经知道基本的步调了，是时候开始跳舞并玩一些疯狂的事情了。我曾经写过一篇 <a href="http://arigrant.com/blog/2014/1/19/adventures-in-the-land-of-nsarray" target="_blank" rel="external"><code>NSArray</code> 深度探究</a>的博客。这篇博客用了很多 <code>NSLog</code> 语句，但实际上我的所有探索都是在调试器中完成的。看看你能不能弄明白怎么做的，这会是一个有意思的练习。</p>

<h3 id="">不用断点调试</h3>

<p>程序运行时，Xcode 的调试条上会出现暂停按钮，而不是继续按钮：</p>

<p><img src="http://img.objccn.io/issue-19/Screen_Shot_2014_11_22_at_1_50_56_PM.png" width="300"></p>

<p>点击按钮会暂停 app (这会运行 <code>process interrupt</code> 命令，因为 LLDB 总是在背后运行)。这会让你可以访问调试器，但看起来可以做的事情不多，因为在当前作用域没有变量，也没有特定的代码让你看。</p>

<p>这就是有意思的地方。如果你正在运行 iOS app，你可以试试这个： (因为全局变量是可访问的)</p>

<pre><code>    (lldb) po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]
&lt;UIWindow: 0x7f82b1fa8140; frame = (0 0; 320 568); gestureRecognizers = &lt;NSArray: 0x7f82b1fa92d0&gt;; layer = &lt;UIWindowLayer: 0x7f82b1fa8400&gt;&gt;
   | &lt;UIView: 0x7f82b1d01fd0; frame = (0 0; 320 568); autoresize = W+H; layer = &lt;CALayer: 0x7f82b1e2e0a0&gt;&gt;
</code></pre>

<p>你可以看到整个层次。<a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 中 <code>pviews</code> 就是这么实现的。</p>

<h3 id="ui">更新UI</h3>

<p>有了上面的输出，我们可以获取这个 view：</p>

<pre><code>(lldb) e id $myView = (id)0x7f82b1d01fd0
</code></pre>

<p>然后在调试器中改变它的背景色：</p>

<pre><code>(lldb) e (void)[$myView setBackgroundColor:[UIColor blueColor]]
</code></pre>

<p>但是只有程序继续运行之后才会看到界面的变化。因为改变的内容必须被发送到渲染服务中，然后显示才会被更新。</p>

<p>渲染服务实际上是一个另外的进程 (被称作 <code>backboardd</code>)。这就是说即使我们正在调试的内容所在的进程被打断了，<code>backboardd</code> 也还是继续运行着的。</p>

<p>这意味着你可以运行下面的命令，而不用继续运行程序：</p>

<pre><code>(lldb) e (void)[CATransaction flush]
</code></pre>

<p>即使你仍然在调试器中，UI 也会在模拟器或者真机上实时更新。<a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 为此提供了一个别名叫做 <code>caflush</code>，这个命令被用来实现其他的快捷命令，例如 <code>hide &lt;view&gt;</code>，<code>show &lt;view&gt;</code> 以及其他很多命令。所有 <a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 的命令都有文档，所以安装后随意运行 <code>help show</code> 来看更多信息。</p>

<h3 id="pushviewcontroller">Push 一个 View Controller</h3>

<p>想象一个以 <code>UINavigationController</code> 为 root ViewController 的应用。你可以通过下面的命令，轻松地获取它：</p>

<pre><code>(lldb) e id $nvc = [[[UIApplication sharedApplication] keyWindow] rootViewController]
</code></pre>

<p>然后 push 一个 child view controller:</p>

<pre><code>(lldb) e id $vc = [UIViewController new]
(lldb) e (void)[[$vc view] setBackgroundColor:[UIColor yellowColor]]
(lldb) e (void)[$vc setTitle:@"Yay!"]
(lldb) e (void)[$nvc pushViewContoller:$vc animated:YES]
</code></pre>

<p>最后运行下面的命令：</p>

<pre><code>(lldb) caflush // e (void)[CATransaction flush]
</code></pre>

<p>navigation Controller 就会立刻就被 push 到你眼前。</p>

<h3 id="target">查找按钮的 target</h3>

<p>想象你在调试器中有一个 <code>$myButton</code> 的变量，可以是创建出来的，也可以是从 UI 上抓取出来的，或者是你停止在断点时的一个局部变量。你想知道，按钮按下的时候谁会接收到按钮发出的 action。非常简单：</p>

<pre><code>(lldb) po [$myButton allTargets]
{(
    &lt;MagicEventListener: 0x7fb58bd2e240&gt;
)}
(lldb) po [$myButton actionsForTarget:(id)0x7fb58bd2e240 forControlEvent:0]
&lt;__NSArrayM 0x7fb58bd2aa40&gt;(
_handleTap:
)
</code></pre>

<p>现在你或许想在它发生的时候加一个断点。在 <code>-[MagicEventListener _handleTap:]</code> 设置一个符号断点就可以了，在 Xcode 和 LLDB 中都可以，然后你就可以点击按钮并停在你所希望的地方了。</p>

<h3 id="">观察实例变量的变化</h3>

<p>假设你有一个 <code>UIView</code>，不知道为什么它的 <code>_layer</code> 实例变量被重写了 (糟糕)。因为有可能并不涉及到方法，我们不能使用符号断点。相反的，我们想<strong>监视</strong>什么时候这个地址被写入。</p>

<p>首先，我们需要找到 <code>_layer</code> 这个变量在对象上的相对位置：</p>

<pre><code>(lldb) p (ptrdiff_t)ivar_getOffset((struct Ivar *)class_getInstanceVariable([MyView class], "_layer"))
(ptrdiff_t) $0 = 8
</code></pre>

<p>现在我们知道 <code>($myView + 8)</code> 是被写入的内存地址：</p>

<pre><code>(lldb) watchpoint set expression -- (int *)$myView + 8
Watchpoint created: Watchpoint 3: addr = 0x7fa554231340 size = 8 state = enabled type = w
    new value: 0x0000000000000000
</code></pre>

<p>这被以 <code>wivar $myView _layer</code> 加入到 <a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 中。</p>

<h3 id="">非重写方法的符号断点</h3>

<p>假设你想知道 <code>-[MyViewController viewDidAppear:]</code> 什么时候被调用。如果这个方法并没有在<code>MyViewController</code> 中实现，而是在其父类中实现的，该怎么办呢？试着设置一个断点，会出现以下结果：</p>

<pre><code>(lldb) b -[MyViewController viewDidAppear:]
Breakpoint 1: no locations (pending).
WARNING:  Unable to resolve breakpoint to any actual locations.
</code></pre>

<p>因为 LLDB 会查找一个<strong>符号</strong>，但是实际在这个类上却找不到，所以断点也永远不会触发。你需要做的是为断点设置一个条件 <code>[self isKindOfClass:[MyViewController class]]</code>，然后把断点放在 <code>UIViewController</code> 上。正常情况下这样设置一个条件可以正常工作。但是这里不会，因为我们没有父类的实现。</p>

<p><code>viewDidAppear:</code> 是苹果实现的方法，因此没有它的符号；在方法内没有 <code>self</code> 。如果想在符号断点上使用 <code>self</code>，你必须知道它在哪里 (它可能在寄存器上，也可能在栈上；在 x86 上，你可以在 <code>$esp+4</code> 找到它)。但是这是很痛苦的，因为现在你必须至少知道四种体系结构 (x86，x86-64，armv7，armv64)。想象你需要花多少时间去学习命令集以及它们每一个的<a href="http://en.m.wikipedia.org/wiki/Calling_convention" target="_blank" rel="external">调用约定</a>，然后正确的写一个在你的超类上设置断点并且条件正确的命令。幸运的是，这个在 <a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 被解决了。这被成为 <code>bmessage</code>：</p>

<pre><code>(lldb) bmessage -[MyViewController viewDidAppear:]
Setting a breakpoint at -[UIViewController viewDidAppear:] with condition (void*)object_getClass((id)$rdi) == 0x000000010e2f4d28
Breakpoint 1: where = UIKit`-[UIViewController viewDidAppear:], address = 0x000000010e11533c
</code></pre>

<h3 id="lldbpython">LLDB 和 Python</h3>

<p>LLDB 有内建的，完整的 <a href="http://lldb.llvm.org/python-reference.html" target="_blank" rel="external">Python</a> 支持。在LLDB中输入 <code>script</code>，会打开一个 Python REPL。你也可以输入一行 python 语句作为 <code>script 命令</code> 的参数，这可以运行 python 语句而不进入REPL：</p>

<pre><code>(lldb) script import os
(lldb) script os.system("open http://www.objc.io/")
</code></pre>

<p>这样就允许你创造各种酷的命令。把下面的语句放到文件 <code>~/myCommands.py</code> 中：</p>

<pre><code>def caflushCommand(debugger, command, result, internal_dict):
  debugger.HandleCommand("e (void)[CATransaction flush]")
</code></pre>

<p>然后再 LLDB 中运行：</p>

<pre><code>command script import ~/myCommands.py
</code></pre>

<p>或者把这行命令放在 <code>/.lldbinit</code> 里，这样每次进入 LLDB 时都会自动运行。<a href="https://github.com/facebook/chisel" target="_blank" rel="external">Chisel</a> 其实就是一个 Python 脚本的集合，这些脚本拼接 (命令) 字符串 ，然后让 LLDB 执行。很简单，不是吗？</p>

<h2 id="">紧握调试器这一武器</h2>

<p>LLDB 可以做的事情很多。大多数人习惯于使用 <code>p</code>，<code>po</code>，<code>n</code>，<code>s</code> 和 <code>c</code>，但实际上除此之外，LLDB 可以做的还有很多。掌握所有的命令 (实际上并不是很多)，会让你在揭示代码运行时的运行状态，寻找 bug，强制执行特定的运行路径时获得更大的能力。你甚至可以构建简单的交互原型 - 比如要是现在以 modal 方式弹出一个 View Controller 会怎么样？使用调试器，一试便知。</p>

<p>这篇文章是为了想你展示 LLDB 的强大之处，并且鼓励你多去探索在控制台输入命令。</p>

<p>打开 LLDB，输入 <code>help</code>，看一看列举的命令。你尝试过多少？用了多少？</p>

<p>但愿 <code>NSLog</code> 看起来不再那么吸引你去用，每次编辑再运行并不有趣而且耗时。</p>

<p>调试愉快！</p>

<p>#各种补</p>
<h2 id="编辑断点窗口中Action相关参数说明"><a href="#编辑断点窗口中Action相关参数说明" class="headerlink" title="编辑断点窗口中Action相关参数说明"></a><a href="http://supermao.cn/duan-dian-shen-ru-liao-jie/" target="_blank" rel="external">编辑断点窗口中Action相关参数说明</a></h2><h3 id="Log-Message"><a href="#Log-Message" class="headerlink" title="Log Message"></a>Log Message</h3><p>%B：打印断点的名字</p>
<p>%H：打印断点的调用次数</p>
<p>@exp@：输出表达式</p>
<p>###Debugger Command</p>
<p>po：打印对象信息</p>
<p>bt：打印函数栈</p>
<p>expression：表达式</p>
<h2 id="异常断点的作用"><a href="#异常断点的作用" class="headerlink" title="异常断点的作用"></a>异常断点的作用</h2><p>数组越界访问时程序运行崩溃，但是崩溃停在了main函数里面，就算看了栈信息也不能马上定位到到底是那个数组越界访问了。为什么崩溃不能停在数组越界哪里？这是因为数组越界访问不一定会导致程序崩溃的，数组越界访问会导致异常抛出，而抛出的异常没有得到处理才会导致程序崩溃。因此最后会导致崩溃停在CoreFoundation框架里面。这个时候就需要设置Exception Breakpoint产生断点来定位错误了。</p>
<h2 id="打印View-Controller-Hierarchy"><a href="#打印View-Controller-Hierarchy" class="headerlink" title="打印View Controller Hierarchy"></a>打印View Controller Hierarchy</h2><p>_printHierarchy是 UIViewController 的一个私有方法，你可以用它将view controller 层次打印到控制台。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">po <span class="comment">[<span class="comment">[<span class="comment">[<span class="comment">[UIApplication sharedApplication]</span> keyWindow]</span> rootViewController]</span> _printHierarchy]</span></span><br></pre></td></tr></table></figure>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><pre><code>光标切换到控制台：cmd+shift+c
控制台显示/隐藏：cmd+shift+y
</code></pre><h2 id="精彩博文"><a href="#精彩博文" class="headerlink" title="精彩博文"></a>精彩博文</h2><p><a href="http://blog.cnbluebox.com/blog/2015/03/05/chisel/" target="_blank" rel="external">Chisel-LLDB命令插件，让调试更Easy</a></p>
<p><a href="http://www.jianshu.com/p/b2371dd4443b" target="_blank" rel="external">LLdb篇2教你使用faceBook的chisel来提高调试效率</a></p>
<p><a href="http://www.jianshu.com/p/e89af3e9a8d7#" target="_blank" rel="external">小笨狼与LLDB的故事</a></p>
<h1 id="来源-objcio-cn"><a href="#来源-objcio-cn" class="headerlink" title="来源:objcio.cn"></a>来源:<a href="http://objccn.io/issue-19-2/" target="_blank" rel="external">objcio.cn</a></h1>]]></content>
    <summary type="html">
    <![CDATA[与调试器共舞 - LLDB 的华尔兹]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="调试" scheme="http://www.zhuli8.com/tags/%E8%B0%83%E8%AF%95/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS应用数据存储的常用方式]]></title>
    <link href="http://www.zhuli8.com/2015/05/24/iOS%E5%BA%94%E7%94%A8%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.zhuli8.com/2015/05/24/iOS应用数据存储的常用方式/</id>
    <published>2015-05-24T04:40:39.000Z</published>
    <updated>2016-02-24T06:25:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="应用沙盒"><a href="#应用沙盒" class="headerlink" title="应用沙盒"></a>应用沙盒</h1><pre><code>iOS应用数据一般存储于应用沙盒，每个iOS应用都有自己的应用沙盒（应用沙盒就是文件系统目录），与其他文件系统隔离。应用必须待在自己的沙盒里，其他应用不能访问该沙盒。
</code></pre><p>应用沙盒的文件系统目录如下图所示：</p>
<p><img src="http://www.zhuli8.com/photos/沙盒目录结构.png" alt=""></p>
<p>模拟器应用沙盒的根路径在：</p>
<p><code>/Users/用户名/Library/Developer/CoreSimulator/Devices/模拟器UDID/data/Containers/Data/Application/对应应用程序文件夹</code></p>
<h2 id="应用沙盒结构分析"><a href="#应用沙盒结构分析" class="headerlink" title="应用沙盒结构分析"></a>应用沙盒结构分析</h2><p>###Documents###</p>
<p>保存应用运行时生成的 <strong>需要持久化的数据</strong> ，iTunes同步设备时会 <strong>会备份</strong> 该目录。例如，游戏应用可将游戏存档保存在该目录。</p>
<p>###Library/Caches###</p>
<p>保存应用运行时生成的 <strong>需要持久化的数据</strong> ，iTunes同步设备时 <strong>不会备份</strong> 该目录。一般存储体积大、不需要备份的非重要数据。</p>
<p>###Library/Preference###</p>
<p>保存应用的所有 <strong>偏好设置</strong> ，iOS的Settings（设置）应用会在该目录中查找应用的设置信息。iTunes同步设备时 <strong>会备份</strong> 该目录。</p>
<p>###temp###</p>
<p>保存应用运行时所需的 <strong>临时文件</strong> ，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时 <strong>不会备份</strong> 该目录。</p>
<h2 id="应用沙盒目录的常见获取方式"><a href="#应用沙盒目录的常见获取方式" class="headerlink" title="应用沙盒目录的常见获取方式"></a>应用沙盒目录的常见获取方式</h2><h3 id="沙盒根目录"><a href="#沙盒根目录" class="headerlink" title="沙盒根目录"></a>沙盒根目录</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *home=<span class="built_in">NSHomeDirectory</span>();</span><br></pre></td></tr></table></figure>
<h3 id="Documnets"><a href="#Documnets" class="headerlink" title="Documnets"></a>Documnets</h3><p><strong>利用NSSearchPathForDirectoriesInDomains函数</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br></pre></td></tr></table></figure>
<p><strong>利用NSFileManager的URLsForDirectory:inDomains:函数</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *path=[[[<span class="built_in">NSFileManager</span> defaultManager] URLsForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomains:<span class="built_in">NSUserDomainMask</span>] lastObject];</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong></p>
<p>在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素。</p>
<blockquote>
<p>NSUserDomainMask 代表从用户文件夹下找</p>
<p>YES 代表展开路径中的波浪线字符“~”</p>
</blockquote>
<h3 id="Library-Caches"><a href="#Library-Caches" class="headerlink" title="Library/Caches"></a>Library/Caches</h3><p><strong>利用NSSearchPathForDirectoriesInDomains函数</strong></p>
<p><strong>利用NSFileManager的URLsForDirectory:inDomains:函数</strong></p>
<blockquote>
<p>将函数的第1个参数改为：NSCachesDirectory即可</p>
</blockquote>
<h3 id="Library-Preference"><a href="#Library-Preference" class="headerlink" title="Library/Preference"></a>Library/Preference</h3><p><strong>通过过 NSUserDefaults 类存取该目录下的设置信息</strong></p>
<h3 id="temp"><a href="#temp" class="headerlink" title="temp"></a>temp</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=<span class="built_in">NSTemporaryDirectory</span>();</span><br></pre></td></tr></table></figure>
<p>#XML属性列表（plist）归档<br>属性列表是一种XML格式的文件，拓展名为plist。<br>如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，就可以使用这些对象的writeToFile:atomically:方法直接将对象写到属性列表文件中。</p>
<blockquote>
<p>所谓归档，是一个过程，即用某种格式来保存一个或者多个对象以便以后还原这些对象。</p>
</blockquote>
<h2 id="归档NSDictionary"><a href="#归档NSDictionary" class="headerlink" title="归档NSDictionary"></a>归档NSDictionary</h2><p>将一个NSDictionary对象归档到一个plist属性列表中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=[[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"info.plist"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将数据封装成字典</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *dict=[<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">[dict setValue:<span class="string">@"朱利"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">[dict setValue:<span class="string">@"http://www.zhuli8.com"</span> forKey:<span class="string">@"site"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将字典持久化到Docums/info.plist文件中</span></span><br><span class="line">[dict writeToFile:path atomically:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>##恢复NSDictionary</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=[[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"info.plist"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="comment">//读取Documents/info.plist的内容，实例化NSDictionary。</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dict=[<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:path];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSString</span> *name=[dict objectForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *site=[dict objectForKey:<span class="string">@"site"</span>];</span><br></pre></td></tr></table></figure>
<p>#Preference（偏好设置）</p>
<p>很多iOS应用都支持偏好设置，比如保存用户名、是否自动登录、字体大小等设置，iOS提供了一套标准的解决方案来为应用程序加入偏好设置功能。每个应用都有个 <strong>NSUserDefaults</strong> 实例，通过它来存取偏好设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *defaults= [NSUserDefaults standardUserDefaults];</span><br><span class="line">[defaults <span class="built_in">set</span>Object:@<span class="string">"朱利"</span> <span class="keyword">for</span>Key:@<span class="string">"name"</span>];</span><br><span class="line">[defaults <span class="built_in">set</span>Float:<span class="number">18</span> <span class="keyword">for</span>Key:@<span class="string">"fontSize"</span>];</span><br><span class="line">[defaults <span class="built_in">set</span>Bool:YES <span class="keyword">for</span>Key:@<span class="string">"autoLogin"</span>];</span><br><span class="line">    </span><br><span class="line">[defaults synchronize];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
</blockquote>
<p><strong>NSUserDefauts设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。出现以上问题，可以通过调用synchronize方法强制写入。</strong></p>
<p>读取上次保存的偏好设置</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *defaults= [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSString</span> *name=[defaults objectForKey:<span class="string">@"name"</span>];</span><br><span class="line"><span class="keyword">float</span> fontSize=[defaults floatForKey:<span class="string">@"fontSize"</span>];</span><br><span class="line"><span class="built_in">BOOL</span> autoLogin=[defaults boolForKey:<span class="string">@"autoLogin"</span>];</span><br></pre></td></tr></table></figure>
<p>#NSKeyedArchiver归档（NSCoding）</p>
<p>如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用NSKeyedArchiver进行归档和恢复，不是所有的对象都可以直接用这种方法进行归档，只有遵守了NSCoding协议的对象才可以。</p>
<h2 id="NSCoding协议的2个方法"><a href="#NSCoding协议的2个方法" class="headerlink" title="NSCoding协议的2个方法"></a>NSCoding协议的2个方法</h2><h3 id="initWithCoder"><a href="#initWithCoder" class="headerlink" title="initWithCoder"></a>initWithCoder</h3><p>每次从文件中恢复（解码）对象时都会调用这个方法，一般在这个方法里面指定如何解码文件中的数据为对象的实例变量，可以使用 <strong>decodeObject:forKey:</strong>方法解码实例变量。</p>
<h3 id="encodeWithCoder"><a href="#encodeWithCoder" class="headerlink" title="encodeWithCoder"></a>encodeWithCoder</h3><p>每次归档对象时，都会调用这个方法，一般这个方法里面指定如何归档对象中的每个实例变量，可以使用 <strong>encoderObject:forKey:</strong>方法归档实例变量。</p>
<p>##NSKeyedArchiver归档NSArray</p>
<p>###归档一个NSArray对象到Documents/array.archive</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=[[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"array.archive"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:@”a”,@”b”,<span class="literal">nil</span>];</span><br><span class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:array toFile:path];</span><br></pre></td></tr></table></figure>
<p>###恢复(解码)NSArray对象</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=[[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"array.archive"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSArray</span> *array= [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array);</span><br></pre></td></tr></table></figure>
<p>##NSKeyedArchiver-归档Person对象</p>
<h3 id="Person-h"><a href="#Person-h" class="headerlink" title="Person.h"></a>Person.h</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Person </span>: NSObject&lt;NSCoding&gt;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *name;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) int age;</span><br><span class="line"><span class="variable">@property</span> (nonatomic, assign) float height;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="Person-m"><a href="#Person-m" class="headerlink" title="Person.m"></a>Person.m</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@implementation</span> Person</span><br><span class="line">-(<span class="typename">void</span>)<span class="string">encodeWithCoder:</span>(NSCoder *)encoder</span><br><span class="line">&#123;</span><br><span class="line">    [encoder <span class="string">encodeObject:</span>self.name <span class="string">forKey:</span>@<span class="string">"name"</span>];</span><br><span class="line">    [encoder <span class="string">encodeInt:</span>self.age <span class="string">forKey:</span>@<span class="string">"age"</span>];</span><br><span class="line">    [encoder <span class="string">encodeFloat:</span>self.height <span class="string">forKey:</span>@<span class="string">"height"</span>];</span><br><span class="line">&#125;</span><br><span class="line">-(id)<span class="string">initWithCoder:</span>(NSCoder *)decoder</span><br><span class="line">&#123;</span><br><span class="line">    self.name=[decoder <span class="string">decodeObjectForKey:</span>@<span class="string">"name"</span>];</span><br><span class="line">    self.age=[decoder <span class="string">decodeIntForKey:</span>@<span class="string">"age"</span>];</span><br><span class="line">    self.height=[decoder <span class="string">decodeFloatForKey:</span>@<span class="string">"height"</span>];</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"><span class="annotation">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="归档-编码"><a href="#归档-编码" class="headerlink" title="归档(编码)"></a>归档(编码)</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *path=<span class="comment">[<span class="comment">[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]</span> stringByAppendingPathComponent:@"person.archive"]</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">Person</span> *<span class="keyword">person</span>=<span class="comment">[<span class="comment">[Person alloc]</span> init]</span>;</span><br><span class="line"><span class="keyword">person</span>.name=@<span class="string">"zhuli8.com"</span>;</span><br><span class="line"><span class="keyword">person</span>.age=1;</span><br><span class="line"><span class="keyword">person</span>.height=2.0f;</span><br><span class="line"><span class="comment">[NSKeyedArchiver archiveRootObject:person toFile:path]</span>;</span><br></pre></td></tr></table></figure>
<h3 id="恢复-解码"><a href="#恢复-解码" class="headerlink" title="恢复(解码)"></a>恢复(解码)</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *path=[[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"person.archive"</span>];</span><br><span class="line">    </span><br><span class="line">Person *person= [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person);</span><br></pre></td></tr></table></figure>
<h3 id="NSKeyedArchiver-归档对象的注意"><a href="#NSKeyedArchiver-归档对象的注意" class="headerlink" title="NSKeyedArchiver-归档对象的注意"></a>NSKeyedArchiver-归档对象的注意</h3><p>如果父类也遵守了NSCoding协议，请注意：</p>
<ul>
<li>应该在encodeWithCoder:方法中加上一句<strong>[super encodeWithCode:encode];</strong>确保继承的实例变量也能被编码，即也能被归档；</li>
<li>应该在initWithCoder:方法中加上一句<strong>self = [super initWithCoder:decoder];</strong>确保继承的实例变量也能被解码，即也能被恢复。</li>
</ul>
<h2 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h2><p>使用archiveRootObject:toFile:方法可以将一个对象直接写入到一个文件中，但有时候可能想将多个对象写入到同一个文件中，那么就要使用NSData来进行归档对象。NSData可以为一些数据提供临时存储空间，以便随后写入文件，或者存放从磁盘读取的文件内容。可以使用[NSMutableData data]创建可变数据空间。</p>
<p><img src="http://www.zhuli8.com/photos/NSData.png" alt=""></p>
<h3 id="归档2个Person对象到同一文件中"><a href="#归档2个Person对象到同一文件中" class="headerlink" title="归档2个Person对象到同一文件中"></a>归档2个Person对象到同一文件中</h3><h4 id="归档（编码）"><a href="#归档（编码）" class="headerlink" title="归档（编码）"></a>归档（编码）</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Person *person1=[[Person alloc] init];</span><br><span class="line">person1<span class="variable">.name</span>=<span class="string">@"zhuli8.com"</span>;</span><br><span class="line">person1<span class="variable">.age</span>=<span class="number">1</span>;</span><br><span class="line">person1<span class="variable">.height</span>=<span class="number">1.2</span>f;</span><br><span class="line"></span><br><span class="line">Person *person2=[[Person alloc] init];</span><br><span class="line">person2<span class="variable">.name</span>=<span class="string">@"朱利"</span>;</span><br><span class="line">person2<span class="variable">.age</span>=<span class="number">28</span>;</span><br><span class="line">person2<span class="variable">.height</span>=<span class="number">1.7</span>f;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一块可变数据区</span></span><br><span class="line"><span class="built_in">NSMutableData</span> *data=[<span class="built_in">NSMutableData</span> data];</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据区连接到一个NSKeyedArchiver对象</span></span><br><span class="line"><span class="built_in">NSKeyedArchiver</span> *archiver=[[<span class="built_in">NSKeyedArchiver</span> alloc] initForWritingWithMutableData:data];</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始存档对象，存档的数据都会存储到NSMutableData中</span></span><br><span class="line">[archiver encodeObject:person1 forKey:<span class="string">@"person1"</span>];</span><br><span class="line">[archiver encodeObject:person2 forKey:<span class="string">@"person2"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//存档完毕（一定要调用这个方法）</span></span><br><span class="line">[archiver finishEncoding];</span><br><span class="line"></span><br><span class="line"><span class="comment">//将存档的数据写入文件</span></span><br><span class="line"><span class="built_in">NSString</span> *path=[[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"persons.archive"</span>];</span><br><span class="line">[data writeToFile:path atomically:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<h4 id="恢复（解码）"><a href="#恢复（解码）" class="headerlink" title="恢复（解码）"></a>恢复（解码）</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从文件中读取数据</span></span><br><span class="line"><span class="built_in">NSString</span> *path=[[<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject] stringByAppendingPathComponent:<span class="string">@"persons.archive"</span>];</span><br><span class="line"><span class="built_in">NSData</span> *data=[<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line"><span class="comment">//根据数据，解析成一个NSKeyedUnarchiver对象</span></span><br><span class="line"><span class="built_in">NSKeyedUnarchiver</span> *unarchiver=[[<span class="built_in">NSKeyedUnarchiver</span> alloc] initForReadingWithData:data];</span><br><span class="line">Person *person1=[unarchiver decodeObjectForKey:<span class="string">@"person1"</span>];</span><br><span class="line">Person *person2=[unarchiver decodeObjectForKey:<span class="string">@"person2"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复完毕</span></span><br><span class="line">[unarchiver finishDecoding];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@,%@"</span>,person1,person2);</span><br></pre></td></tr></table></figure>
<h3 id="利用归档实现深复制"><a href="#利用归档实现深复制" class="headerlink" title="利用归档实现深复制"></a>利用归档实现深复制</h3><p>比如对一个Person对象进行深复制</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person *person1=[[Person alloc] init];</span><br><span class="line">person1<span class="variable">.name</span>=<span class="string">@"zhuli8.com"</span>;</span><br><span class="line">person1<span class="variable">.age</span>=<span class="number">1</span>;</span><br><span class="line">person1<span class="variable">.height</span>=<span class="number">1.2</span>f;</span><br><span class="line"></span><br><span class="line"><span class="comment">//临时存储person1的数据</span></span><br><span class="line"><span class="built_in">NSData</span> *data=[<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:person1];</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析data，生成一个新的Person对象</span></span><br><span class="line">Person *person2=[<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:data];</span><br><span class="line"></span><br><span class="line"><span class="comment">//分别打印内存地址</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person1=%p,person2=%p"</span>,person1,person2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//person1=0x7fc478c49390,person2=0x7fc478e1c180</span></span><br></pre></td></tr></table></figure>
<h1 id="SQLite3"><a href="#SQLite3" class="headerlink" title="SQLite3"></a>SQLite3</h1><p>SQLite3是一款开源的嵌入式关系型数据库，可移植性好、易使用、内存开销小。<br>SQLite3是无类型的，意味着你可以保存任何类型的数据到任意表的任意字段中。比如下列的创表语句是合法的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> t_person(<span class="keyword">name</span>, age);</span></span><br></pre></td></tr></table></figure>
<p>为了保证可读性，建议还是把字段类型加上：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> t_person(<span class="keyword">name</span> <span class="built_in">text</span>, age <span class="built_in">integer</span>);</span></span><br></pre></td></tr></table></figure>
<p>SQLite3常用的5种数据类型：text、integer、float、boolean、blob。</p>
<p>##创建、打开、关闭数据库</p>
<h3 id="创建或打开数据库"><a href="#创建或打开数据库" class="headerlink" title="创建或打开数据库"></a>创建或打开数据库</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSString</span> *path=[[<span class="type">NSSearchPathForDirectoriesInDomains</span>(<span class="type">NSDocumentationDirectory</span>, <span class="type">NSUserDomainMask</span>, <span class="type">YES</span>) lastObject] stringByAppendingPathComponent:@<span class="string">"person.db"</span>];</span><br><span class="line"></span><br><span class="line">sqlite3 *db;//一个打开的数据库实例</span><br><span class="line"></span><br><span class="line">//将根据文件路径打开数据库，如果不存在，则会创建一个新的数据库。如果<span class="literal">result</span>等于常量<span class="type">SQLITE_OK</span>，则表示成功打开数据库。</span><br><span class="line"><span class="type">int</span> <span class="literal">result</span>=sqlite3_open([path <span class="type">UTF8String</span>], &amp;db);//数据库文件的路径必须以C字符串(而非<span class="type">NSString</span>)传入</span><br></pre></td></tr></table></figure>
<h3 id="关闭数据库："><a href="#关闭数据库：" class="headerlink" title="关闭数据库："></a>关闭数据库：</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_close<span class="list">(<span class="keyword">db</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="执行不返回数据的SQL语句"><a href="#执行不返回数据的SQL语句" class="headerlink" title="执行不返回数据的SQL语句"></a>执行不返回数据的SQL语句</h2><h3 id="执行创表语句"><a href="#执行创表语句" class="headerlink" title="执行创表语句"></a>执行创表语句</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *errorMsg;//用来存储错误信息</span><br><span class="line"><span class="type">char</span> *sql=<span class="string">"create table if not exists t_person(id integer primary key autoincrement,name text,age integer);"</span>;</span><br><span class="line"><span class="type">int</span> <span class="literal">result</span>=sqlite3_exec(db, sql, <span class="type">NULL</span>, <span class="type">NULL</span>, &amp;errorMsg);</span><br></pre></td></tr></table></figure>
<p>sqlite3_exec()可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据。<br>sqlite3_exec()还可以执行的语句：</p>
<ul>
<li>开启事务：begin transaction;</li>
<li>回滚事务：rollback;</li>
<li>提交事务：commit;</li>
</ul>
<h3 id="带占位符插入数据"><a href="#带占位符插入数据" class="headerlink" title="带占位符插入数据"></a>带占位符插入数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *sql=<span class="string">"insert into t_person(name,age) values(?,?);"</span>;</span><br><span class="line">sqlite3_stmt *stmt;</span><br><span class="line"><span class="keyword">if</span> (sqlite3_prepare_v2(db, sql, -<span class="number">1</span>, &amp;stmt, <span class="literal">NULL</span>)==SQLITE_OK) &#123;</span><br><span class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, <span class="string">"朱利"</span>, -<span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sqlite3_step(stmt)!=SQLITE_DONE) &#123;</span><br><span class="line">    NSLog(@<span class="string">"插入数据错误"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqlite3_finalize(stmt);</span><br></pre></td></tr></table></figure>
<p>sqlite3_prepare_v2()：返回值等于SQLITE_OK，说明SQL语句已经准备成功，没有语法问题。<br>sqlite3_bind_text()：大部分绑定函数都只有3个参数</p>
<ul>
<li>第1个参数是sqlite3_stmt *类型</li>
<li>第2个参数指占位符的位置，第一个占位符的位置是1，不是0</li>
<li>第3个参数指占位符要绑定的值</li>
<li>第4个参数指在第3个参数中所传递数据的长度，对于C字符串，可以传递-1代替字符串的长度</li>
<li>第5个参数是一个可选的函数回调，一般用于在语句执行后完成内存清理工作<br>sqlite_step()：执行SQL语句，返回SQLITE_DONE代表成功执行完毕。<br>sqlite_finalize()：销毁sqlite3_stmt *对象。</li>
</ul>
<p>##查询数据</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *sql = <span class="string">"select id,name,age from t_person;"</span>;</span><br><span class="line">sqlite3_stmt *stmt;</span><br><span class="line"><span class="keyword">if</span> (sqlite3_prepare_v2(db, sql, -<span class="number">1</span>, &amp;stmt, <span class="literal">NULL</span>) == SQLITE_OK) &#123;</span><br><span class="line">    <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;</span><br><span class="line">        <span class="keyword">int</span> _<span class="keyword">id</span> = sqlite3_column_int(stmt, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">char</span> *_name = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:_name];</span><br><span class="line">        <span class="keyword">int</span> _age = sqlite3_column_int(stmt, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"id=%i, name=%@, age=%i"</span>, _<span class="keyword">id</span>, name, _age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_finalize(stmt);</span><br></pre></td></tr></table></figure>
<p>sqlite3_step()：返回SQLITE_ROW代表遍历到一条新记录。<br>sqlite3<em>column</em>*()用于获取每个字段对应的值，第2个参数是字段的索引，从0开始。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="控制台操作"><a href="#控制台操作" class="headerlink" title="控制台操作"></a>控制台操作</h3><p>进入数据库目录后使用 <strong>sqlite3 msg.sqlite</strong><br>.tables 查看表<br>select * from 上面查到的表;（注意一定要加分号才符合sql语句）</p>
<h1 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a>Core Data</h1><p>Core Data框架提供了对象-关系映射(ORM)的功能，即能够将OC对象转化成数据，保存在SQLite3数据库文件中，也能够将保存在数据库中的数据还原成OC对象。在此数据操作期间，不需要编写任何SQL语句。</p>
<p>##推荐文章阅读<br><a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/" target="_blank" rel="external">初识Core Data(1)</a></p>
<p><a href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/" target="_blank" rel="external">初识Core Data(2)</a></p>
<p><a href="http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3/" target="_blank" rel="external">初识Core Data(3)</a></p>
<h2 id="打开Core-Data的SQL日志输出开关"><a href="#打开Core-Data的SQL日志输出开关" class="headerlink" title="打开Core Data的SQL日志输出开关"></a>打开Core Data的SQL日志输出开关</h2><ul>
<li>打开Product，点击Edit Scheme…</li>
<li>点击Arguments，在Arguments Passed On Launch中添加2项<ul>
<li>-com.apple.CoreData.SQLDebug</li>
<li>1</li>
</ul>
</li>
</ul>
<h2 id="Core-Data的延迟加载"><a href="#Core-Data的延迟加载" class="headerlink" title="Core Data的延迟加载"></a>Core Data的延迟加载</h2><p>Core Data不会根据实体中的关联关系立即获取相应的关联对象，比如通过Core Data取出Person实体时，并不会立即查询相关联的Card实体；当应用真的需要使用Card时，才会查询数据库，加载Card实体的信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[iOS应用数据存储的常用方式]]>
    
    </summary>
    
      <category term="iOS" scheme="http://www.zhuli8.com/tags/iOS/"/>
    
      <category term="数据存储" scheme="http://www.zhuli8.com/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
      <category term="iOS" scheme="http://www.zhuli8.com/categories/iOS/"/>
    
  </entry>
  
</feed>