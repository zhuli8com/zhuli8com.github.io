
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>zhuli8’blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="朱利">
    

    
    <meta name="description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">
<meta property="og:type" content="website">
<meta property="og:title" content="zhuli8’blog">
<meta property="og:url" content="http://www.zhuli8.com/index.html">
<meta property="og:site_name" content="zhuli8’blog">
<meta property="og:description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhuli8’blog">
<meta name="twitter:description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">

    
    <link rel="alternative" href="/atom.xml" title="zhuli8’blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="zhuli8’blog" title="zhuli8’blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="zhuli8’blog">zhuli8’blog</a></h1>
				<h2 class="blog-motto">Talk is cheap, show me the code.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
    <input type="text" id="st-search-input" maxlength="20" placeholder="搜索" />
    </form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/10/Grand-Central-Dispatch-基础教程：Part-1-2/" title="Grand Central Dispatch 基础教程：Part 1/2" itemprop="url">Grand Central Dispatch 基础教程：Part 1/2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-06-10T06:33:40.000Z" itemprop="datePublished"> 发表于 2015-06-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <div class="show-content"><br><p>原文 <a href="http://www.raywenderlich.com/79149/grand-central-dispatch-tutorial-swift-part-1" target="_blank">Grand Central Dispatch Tutorail for Swift: Part 1/2</a></p><br><p>原文作者：Bjørn Olav Ruud<br>译者：<a href="http://www.jianshu.com/p/50c060bab0ff" target="_blank">Ethan Joe</a></p><br><p>尽管<code>Grand Central Dispatch</code>（以下简称为<code>GCD</code>）已推出一段时间了，但并不是所有人都明白其原理；当然这是可以理解的，毕竟程序的<code>并发</code>机制很繁琐，而且基于C的GCD的API对于Swift的新世界并不是特别友好。</p><br><p>在接下来的两节教程中，你将学习GCD的<code>输入 (in)</code>与<code>输出 (out)</code>。第一节将解释什么是GCD并了解几个GCD的基础函数。在第二节，你将学习几个更加进阶的GCD函数。</p><br><h1>Getting Started</h1><br><p><br>GCD是<code>libdispatch</code>的代名词，<code>libdispatch</code>代表着运行iOS与OS X的多核设备上执行并行代码的官方代码库。它经常有以下几个特点：</p><br><ul><br><li>GCD通过将高代价任务推迟执行并调至后台运行的方式来提升App的交互速度。</li><br><li>GCD提供比<code>锁</code>与<code>多线程</code>更简单的并发模型，以此来避免一些由并发引起的Bug。</li><br></ul><br><p>为了理解GCD，你需要明白一些与<code>线程</code>、<code>并发</code>的相关的概念。这些概念间有着细微且模糊的差别，所以在学习GCD前请简略地熟悉一下这些概念。</p><br><h4>连续性 VS 并发性</h4><br><p>这些术语用来描述一些被执行的任务彼此间的关系。<code>连续性</code>执行任务代表着同一时间内只执行一个任务，而<code>并发性</code>执行任务则代表着同一时间内可能会执行多个任务。</p><br><h4>任务</h4><br><p>在这篇教程中你可以把每个任务看成是一个<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94" target="_blank">闭包</a>。 事实上，你也可以通过函数指针来使用GCD，但在大多数情况下这明显有些麻烦。所以，闭包用起来更简单。</p><br><p>不知道什么是Swift中的<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94" target="_blank">闭包</a>？闭包是可被储存并传值的可调用代码块，当它被调用时可以像函数那样包含参数并返回值。</p><br><p>Swift中的闭包和Objective-C的块很相近，它们彼此间是可以相互交替的。这个过程中有一点你不能做的是：用Objective-C的<code>块</code>代码去交互具有Swift独有属性属性的闭包，比如说具有<code>元组</code>属性的闭包。但是从Swift端交互Objective-C端的代码则是毫无障碍的，所以无论何时你在文档中看到到的Objective-C的块代码都是可用Swift的闭包代替的。</p><br><h4>同步 VS 异步</h4><br><p>这些术语用来描述当一个函数的控制权返回给调用者时已完成的工作的数量。</p><br><p><code>同步</code>函数只有在其命令的任务完成时才会返回值。</p><br><p><code>异步</code>函数则不会等待其命令的任务完成，即会立即返回值。所以，异步函数不会锁住当前线程使其不能向队列中的<code>下一位函数</code>执行。</p><br><p>值得注意的是—-当你看到一个同步函数<code>锁住（block）</code>了当前进程，或者一个函数是<code>锁函数（blocking function）</code>或是<code>锁运算（block operation）</code>时别认混了。这里的<code>锁（blocks）</code>是用来形容其对于自己线程的影响，它跟Objective-C中的<code>块（block）</code>是不一样的。再有一点要记住的就是在任何GCD文档中涉及到Objective-C的块代码都是可以用Swift的闭包来替换的。</p><br><h4>临界区</h4><br><p>这是一段不能被在两个线程中同时执行的代码。这是因为这段代码负责管理像变量这种若被并发进程使用便会更改的可共享资源。</p><br><h4>资源竞争</h4><br><p>这是一种软件系统在一种不被控制的模式下依靠于特定队列或者基于事件执行时间进行运行的情况，比如说程序当前多个任务执行的具体顺序。资源竞争可以产生一些不会在代码排错中立即找到的错误。</p><br><h4>死锁</h4><br><p>两个或两个以上的进程因等待彼此完成任务或因执行其他任务而停止当前进程运行的情况被称作为死锁。举个例子，进程A因等待进程B完成任务而停止运行，但进程B也在等待进程A完成任务而停止运行的僵持状态就是死锁。</p><br><h4>线程安全性</h4><br><p>具有线程安全性的代码可以在不产生任何问题（比如数据篡改、崩溃等）的情况下在多线程间或是并发任务间被安全的调用。不具有线程安全性的代码的正常运行只有在<code>单一</code>的环境下才可被保证。举个具有线性安全性的代码示例<code>let a = [“thread-safe”]</code>。你可以在多线程间，不产生任何bug的情况下调用这个具有只读性的数组。相反，通过<code>var a = [“thread-unsafe”]</code>声明的数组是可变可修改的。这就意味着这个数组在多线层间可被修改从而产生一些不可预测的问题，对于那些可变的变量与数据结构最好不要同时在多个线程间使用。</p><br><h4>上下文切换</h4><br><p>上下文切换是当你在一个进程中的多个不同线程间进行切换时的一种进程进行储存与恢复的状态。这种进程在写多任务App时相当常见，但这通常会产生额外的系统开销。</p><br><h4>并发 VS 并行</h4><br><p>并发和并行总是被同时提及，所以有必要解释一下两者间的区别。</p><br><p>并发代码中各个单独部分可以被”同时”执行。不管怎样，这都由系统决定以何种方式执行。具有多核处理器的设备通过并行的方式在同一时间内实现多线程间的工作；但是单核处理器设备只能在同一时间内运行在单一线程上，并利用<code>上下文切换</code>的方式切换至其他线程以达到跟并行相同的工作效果。如下图所示，单核处理器设备运行速度快到形成了一种<code>并行</code>的假象。</p><br><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/579323-1d630555ba627aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="并发 VS 并行" data-original-src="http://upload-images.jianshu.io/upload_images/579323-1d630555ba627aaa.png"><br><div class="image-caption">并发 VS 并行</div><br></div><br><p>尽管你会在GCD下写出使用多线程的代码，但这仍由GCD来决定是否会使用并发机制。并行机制包含着并发机制，但并发机制却不一定能保证并行机制的运行。</p><br><h1>队列</h1><br><p>GCD通过<code>队列分配</code>的方式来处理待执行的任务。这些队列管理着你提供给GCD待处理的任务并以FIFO的顺序进行处理。这就得以保证第一个加进队列的任务会被首个处理，第二个加进队列的任务则被其次处理，其后则以此类推。</p><br><h4>连续队列</h4><br><p><code>连续队列</code>中的任务每次执行只一个，一个任务只有在其前面的任务执行完毕后才可开始运行。如下图所示，你不会知道前一个任务结束到下一个任务开始时的时间间隔。</p><br><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/579323-9715edc5ebe0db56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="连续队列" data-original-src="http://upload-images.jianshu.io/upload_images/579323-9715edc5ebe0db56.png"><br><div class="image-caption">连续队列</div><br></div><br><p>每一个任务的执行时间都是由GCD控制的；唯一一件你可以确保的事便是GCD会在同一时间内按照任务加进队列的顺序执行一个任务。</p><br><p>因为在连续队列中不允许多个任务同时运行，这就减少了同时访问临界区的风险；这种机制在多任务的资源竞争的过程中保护了临界区。假如分配任务至分发队列是访问临界区的唯一方式，那这就保证了的临界区的安全。</p><br><h4>并发队列</h4><br><p><code>并发队列</code>中的任务依旧以FIFO顺序开始执行。。。但你能知道的也就这么多了！任务间可以以任何顺序结束，你不会知道下一个任务开始的时间也不会知道一段时间内正在运行任务的数量。因为，这一切都是由GCD控制的。</p><br><p>如下图所示，在GCD控制下的四个并发任务：</p><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/579323-2d33bd89576e02c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="并发队列" data-original-src="http://upload-images.jianshu.io/upload_images/579323-2d33bd89576e02c8.png"><br><div class="image-caption">并发队列</div><br></div><br><p>需要注意的是，在任务0开始执行后花了一段时间后任务1才开始执行，但任务1、2、3便一个接一个地快速运行起来。再有，即便任务3在任务2开始执行后才开始执行，但任务3却更早地结束执行。</p><br><p>任务的开始执行的时间完全由GCD决定。假如一个任务与另一个任务的执行时间相互重叠，便由GCD决定(在多核非繁忙可用的情况下)是否利用不同的处理器运行或是利用上下文切换的方式运行不同的任务。</p><br><p>为了用起来有趣一些，GCD提供了至少五种特别的队列来对应不同情况。</p><br><h1>队列种类</h1><br><p>首先，系统提供了一个名为<code>主队列(main queue)</code>的特殊连续队列。像其他连续队列一样，这个队列在同一间内只能执行一个任务。不管怎样，这保证了所有任务都将被这个唯一被允许刷新UI的线程所执行。它也是唯一一个用作向<code>UIView</code>对象发送信息或推送监听(Notification)。</p><br><p>GCD也提供了其他几个并发队列。这几个队列都与自己的<code>QoS (Quality of Service)</code>类所关联。Qos代表着待处理任务的执行意图，GCD会根据待处理任务的执行意图来决定最优化的执行优先权。</p><br><ul><br><li><br><p>QOS<em>CLASS_USER_INTERACTIVE: <code>user interactive</code>类代表着为了提供良好的用户体验而需要被立即执行的任务。它经常用来刷新UI、处理一些要求低延迟的加载工作。在App运行的期间，这个类中的工作完成总量应该很小。</em></p><br></li><br><li><br><p>QOS_CLASS_USER_INITIATED:<code>user initiated</code>类代表着从UI端初始化并可异步运行的任务。它在用户等待及时反馈时和涉及继续运行用户交互的任务时被使用。</p><br></li><br><li><br><p>QOS_CLASS_UTILITY:<code>utility</code>类代表着长时间运行的任务，尤其是那种用户可见的进度条。它经常用来处理计算、I/O、网络通信、持续数据反馈及相似的任务。这个类被设计得具有高效率处理能力。</p><br></li><br><li><br><p>QOS_CLASS_BACKBROUND:<code>background</code>类代表着那些用户并不需要立即知晓的任务。它经常用来完成预处理、维护及一些不需要用户交互的、对完成时间并无太高要求的任务。</p><br></li><br></ul><br><p>要知道苹果的API也会使用这些全局分配队列，所以你分派的任务不会是队列中的唯一一个。</p><br><p>最后，你也可以自己写一个连续队列或是并发队列。算起来你起码最少会有五个队列：主队列、四个全局队列再加上你自己的队列。</p><br><p>以上便是分配队列的全体成员。</p><br><p>GCD的关键在于选择正确的分发函数以此把你的任务分发至队列。理解这些东西的最好办法就是完善下面的Sample Project。</p><br><h1>Sample Project</h1><br><p>既然这篇教程的目的在于通过使用GCD在不同的线程间安全地调用代码，那么接下来的任务便是完成这个名为<code>GooglyPuff</code>的半成品。</p><br><p>GooglyPuff是一款通过CoreImage脸部识别API在照片中人脸的双眼的位置上贴上咕噜式的大眼睛且线程不安全的App。你既可以从Photo Library中选择照片，也可以通过网络从事先设置好的地址下载照片。</p><br><p><a href="http://cdn4.raywenderlich.com/wp-content/uploads/2015/01/GooglyPuff_Swift_Start_1_Xcode63.zip" target="_blank">GooglyPuff Swift Start 1</a></p><br><p>将工程下载至本地后用Xcode打开并编译运行。它看起来是这样的:</p><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/579323-95402f1e021e70ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GooglyPuff" data-original-src="http://upload-images.jianshu.io/upload_images/579323-95402f1e021e70ce.png"><br><div class="image-caption">GooglyPuff</div><br></div><br><p>在工程中共有四个类文件：</p><br><ul><br><li><br><p><code>PhotoCollectionViewController</code>：这是App运行后显示的首个界面。它将显示所有被选照片的缩略图。</p><br></li><br><li><br><p><code>PhotoDetailViewController</code>：它将处理将咕噜眼添加至照片的工作并将处理完毕的照片显示在<code>UIScrollView</code>中。</p><br></li><br><li><br><p><code>Photo</code>：一个包含着照片基本属性的协议，其中有<code>image</code>(未处理照片)、<code>thumbnail</code>(裁减后的照片)及<code>status</code>(照片可否使用状态)；两个用来实现协议的类，<code>DownloadPhoto</code>将从一个<code>NSURL</code>实例中实例化照片，而<code>AssetPhoto</code>则从一个<code>ALAsset</code>实例中实例化照片。</p><br></li><br><li><br><p><code>PhotoManager</code>：这个类将管理所有<code>Photo</code>类型对象。</p><br></li><br></ul><br><h1>使用dispatch_async处理后台任务</h1><br><p>回到刚才运行的App后，通过自己的Photo Library添加照片或是使用<code>Le internet</code>下载一些照片。</p><br><p>需要注意的是当你点击<code>PhotoCollectionViewController</code>中的一个<code>UICollectionViewCell</code>后，界面切换至一个新的<code>PhotoDetailViewController</code>所用的时间；对于那些处理速度较慢的设备来说，处理一张较大的照片会产生一个非常明显的延迟。</p><br><p>这种情况下很容易使<code>UIViewController</code>的<code>viewDidLoad</code>因处理过于混杂的工作而负载；这么做的结果便在<code>view controller</code>出现前产生较长的延迟。假如可能的话，我们最好将某些工作放置后台处理。</p><br><p>这听起来<code>dispatch_async</code>该上场了。</p><br><p>打开<code>PhotoDetailViewController</code>后将<code>viewDidLoad</code>函数替换成下述代码：</p><br><pre><code>override func viewDidLoad() {<br>super.viewDidLoad()<br>assert(image != nil, “Image not set; required to use view  controller”)<br>photoImageView.image = image<br><br>// Resize if neccessary to ensure it’s not pixelated<br>if image.size.height &lt;= photoImageView.bounds.size.height &amp;&amp;<br> image.size.width &lt;= photoImageView.bounds.size.width {<br>photoImageView.contentMode = .Center<br>}<br><br>dispatch_async(dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)) { // 1<br>let overlayImage = self.faceOverlayImageFromImage(self.image)<br>dispatch_async(dispatch_get_main_queue()) { // 2<br>self.fadeInNewImage(overlayImage) // 3<br>  }<br> }<br>}</code></pre><br><p>在这里解释一下上面修改的代码：</p><br><ol><br><li><br><p>你首先将照片处理工作从主线程（main thread）移至一个全局队列（global queue）。因为这是一个<code>异步派发（dispatch_async</code>的调用，闭包以异步的形式进行传输意味着调用的线程将会被继续执行。这样一来便会使<code>viewDidLoad</code>更早的在主线程上结束执行并使得整个加载过程更加流畅。与此同时，脸部识别的过程已经开始并在一段时间后结束。</p><br></li><br><li><br><p>这时脸部识别的过程已经结束并生成了一张新照片。当你想用这张新照片来刷新你的<code>UIImageView</code>时，你可以向主线程添加一个新的闭包。需要注意的是－－主线程只能用来访问<code>UIKit</code>。</p><br></li><br><li><br><p>最后，你便用这张有着咕噜眼的<code>fadeInNewImage</code>照片来刷新UI。</p><br></li><br></ol><br><p>有没有注意到你已经用了Swift的<code>尾随闭包语法(trailing closure syntax)</code>,就是以在包含着特定分配队列参数的括号后书写表达式的形式了向<code>dispatch_async</code>传递闭包。假如把闭包写出函数括号的话，语法会看起来更加简洁。</p><br><p>运行并编译App；选一张照片后你会发现<code>view controller</code>加载得很快，咕噜眼会在很短的延迟后出现。现在的运行效果看起来比之前的好多了。当你尝试加载一张大得离谱的照片时，App并不会在<code>view controller</code>加载时而延迟，这种机制便会使App表现得更加良好。</p><br><p>综上所述，<code>dispatch_async</code>将任务以闭包的形式添加至队列后立即返回。这个任务在之后的某个时间段由GCD所执行。当你要在不影响当前线程工作的前提下将基于网络或高密度CPU处理的任务移至后台处理时，<code>dispatch_asnyc</code>便派上用场了。</p><br><p>接下来是一个关于在使用<code>dispatch_asnyc</code>的前提下，如何使用以及何时使用不同类型队列的简洁指南：</p><br><ul><br><li><br><p><code>自定义连续队列（Custom Serial Queue）</code>: 在当你想将任务移至后台继续工作并且时刻监测它的情况下，这是一个不错的选择。需要注意的是当你想从一个方法中调用数据时，你必须再添加一个闭包来回调数据或者考虑使用<code>dispatch_sync</code>。</p><br></li><br><li><br><p><code>主队列（Main Queue[Serial]）</code>：这是一个当并发队列中的任务完成工作时来刷新UI的普遍选择。为此你得在一个闭包中写入另一个闭包。当然，假如你已经在主线程并调用一个面向主线程的<code>dispatch_async</code>的话，你需要保证这个新任务在当前函数运行结束后的某个时间点开始执行。</p><br></li><br><li><br><p><code>并发队列（Concurrent Queue）</code>：对于要运行后台的非UI工作是个普遍的选择。</p><br></li><br></ul><br><h1>获取全局队列的简洁化变量</h1><br><p>你也许注意到了<code>dispatch_get_global_queue</code>函数里的QoS类的参数写起来有些麻烦。这是因为<code>qos_class_t</code>被定义成一个值类型为<code>UInt32</code>且最后还要被转型为<code>Int</code>的结构体。我们可以在<code>Utils.swift</code>中的URL变量下面添加一些全局的简洁化变量，以此使得调用全局队列更加简便。</p><br><pre><code>var GlobalMainQueue: dispatch_queue_t {<br>return dispatch_get_main_queue()<br>}<br><br>var GlobalUserInteractiveQueue: dispatch_queue_t {<br>return dispatch_get_global_queue(Int(QOS_CLASS_USER_INTERACTIVE.value), 0)<br>}<br><br>var GlobalUserInitiatedQueue: dispatch_queue_t {<br>return dispatch_get_global_queue(Int(QOS_CLASS_USER_INITIATED.value), 0)<br>}<br><br>var GlobalUtilityQueue: dispatch_queue_t {<br>return dispatch_get_global_queue(Int(QOS_CLASS_UTILITY.value), 0)<br>}<br><br>var GlobalBackgroundQueue: dispatch_queue_t {<br>return dispatch_get_global_queue(Int(QOS_CLASS_BACKGROUND.value), 0)<br>}</code></pre><br><p>回到<code>PhotoDetailViewController</code>中<code>viewDidLoad</code>函数中，用简洁变量代替<code>dispatch_get_global_queue</code>和<code>dispatch_get_main_queue</code>。</p><br><pre><code>dispatch_async(GlobalUserInitiatedQueue) {<br>   let overlayImage = self.faceOverlayImageFromImage(self.image)<br>   dispatch_async(GlobalMainQueue) {<br>     self.fadeInNewImage(overlayImage)<br>   }<br> }</code></pre><br><p>这样就使得派发队列的调用的代码更加具有可读性并很轻松地得知哪个队列正在被使用。</p><br><h1>利用dispatch_after实现延迟</h1><br><p>考虑一下你App的UX。你的App有没有使得用户在第一次打开App的时候不知道该干些什么而感到不知所措呢？: ]</p><br><p>假如在<code>PhotoManager</code>中没有任何一张照片的时候便向用户发出提醒应该是一个不错的主意。不管怎样，你还是要考虑一下用户在App主页面上的注意力：假如你的提醒显示得过快的话，用户没准在因为看着其他地方而错过它。</p><br><p>当用户第一次使用App的时候，在提醒显示前执行一秒钟的延迟应该足以吸引住用户的注意力。</p><br><p>在<code>PhotoCollectionViewController.swift</code>底部的<code>showOrHideBarPrompt</code>函数中添加如下代码：</p><br><pre><code>func showOrHideNavPrompt() {<br>   let delayInSeconds = 1.0<br>   let popTime = dispatch_time(DISPATCH_TIME_NOW,<br>                          Int64(delayInSeconds * Double(NSEC_PER_SEC))) // 1<br>   dispatch_after(popTime, GlobalMainQueue) { // 2<br>   let count = PhotoManager.sharedManager.photos.count<br>   if count &gt; 0 {<br>    self.navigationItem.prompt = nil<br>   } else {<br>    self.navigationItem.prompt = “Add photos with faces to Googlyify them!”<br>   }<br>  }<br> }</code></pre><br><p>当你的<code>UICollectionView</code>重载的时候，<code>viewDidLoad</code>函数中的<code>showOrHideNavPrompt</code>将被执行。解释如下：</p><br><ol><br><li>你声明了一个代表具体延迟时间的变量。</li><br></ol><br><ol><br><li>你将等待<code>delayInSeconds</code>变量中设定的时间然后向主队列异步添加闭包。</li><br></ol><br><p>编译并运行App。你会看到一个在很大程度上吸引用户注意力并告知他们该做些什么的细微延迟。</p><br><p><code>dispatch_after</code>就像一个延迟的<code>dispatch_async</code>。你仍旧在实时运行的时候毫无操控权并且一旦<code>dispatch_after</code>返回后你也无法取消整个延迟任务。</p><br><p>还在思考如何适当的使用<code>dispatch_after</code>?</p><br><ul><br><li><br><p><code>自定义连续队列（Custom Serial Queue）</code>：当你在自定义连续队列上使用<code>dispatch_after</code>时一定要当心，此时最好不要放到主队列上执行。</p><br></li><br><li><br><p><code>主队列（Main Queue[Serial]）</code>：这对于<code>dispatch_after</code>是个很好的选择；Xcode对此有一个不错的自动执行至完成的样板。</p><br></li><br><li><br><p><code>并发队列（Concurrent Queue）</code>：在自定义并发队列上使用<code>dispatch_after</code>时同样要当心，即便你很少这么做。此时最好放到主队列上执行。</p><br></li><br></ul><br><h1>单例和线程安全</h1><br><p>单例，不管你love it还是hate it，他们对于iOS都是非常重要的。: ]</p><br><p>一提到单例（Singleton）人们便觉得他们是线程不安全的。这么想的话也不是没有道理：单例的实例经常在同一时间内被多线程所访问。<code>PhotoManager</code>类便是一个单例，所以你要思考一下上面提到的问题。</p><br><p>两个需要考虑的情况，单例实例初始化时和实例读写时的线程安全性。</p><br><p>先考虑第一种情况。因为在swift是在全局范围内初始化变量，所以这种情况较为简单。在Swift中，当全局变量被首次访问调用时便被初始化，并且整个初始化过程具有&lt;a href=”<a href="http://baike.baidu.com/link?url=G044fnsYVX8Y3qvEATLMi_5KqXrzDpr6bibpxo-q2ejly5NT2PZtfkXAXTFnQo2-LohhcM_CVfsLDyizjlF6E" target="_blank" rel="external">http://baike.baidu.com/link?url=G044fnsYVX8Y3qvEATLMi_5KqXrzDpr6bibpxo-q2ejly5NT2PZtfkXAXTFnQo2-LohhcM_CVfsLDyizjlF6E</a>“ target=”_blank”&gt;原子操作性。由此，代码的初始化过程便成为一个临界区并且在其他线程访问调用全局变量前完成初始化。Swift到底是怎么做到的？其实在整个过程中，Swift通过<code>dispatch_once</code>函数使用了GCD。若想了解得更多的话请看这篇<a href="https://developer.apple.com/swift/blog/?id=7" target="_blank">Swift官方Blog</a>。</p><br><p>在线程安全的模式下<code>dispatch_once</code>只会执行闭包一次。当一个在临界区执行的线程－－向<code>dispatch_once</code>传入一个任务－－在它结束运行前其它的线程都会被限制住。一旦执行完成，它和其他线程便不会再次在此区域执行。通过<code>let</code>把单例定义为全局定量的话，我们就可以保证这个变量的值在初始化后不会被修改。总之，Swift声明的所有全局定量都是通过线程安全的初始化得到的单例。</p><br><p>但我们还是要考虑读写问题。尽管Swift通过使用<code>dispatch_once</code>确保我们在线程安全的模式下初始化单例，但这并不能代表单例的数据类型同样具有线程安全性。举个例子，假如一个全局变量是一个类的实例，你仍可以在类内的临界区操控内部数据，这将需要利用其他的方式来保证线程安全性。</p><br><h1>处理读取与写入问题</h1><br><p>保证线程安全性的实例化不是我们处理单例时的唯一问题。假如一个单例属性代表着一个可变的对象，比如像<code>PhotoManager</code> 中的<code>photos</code>数组，那么你就需要考虑那个对象是否就有线程安全性。</p><br><p>在Swift中任何用<code>let</code>声明的变量都是一个只可读并线程安全的常量。但是用<code>var</code>声明的变量都是值可变且并线程不安全的。比如Swift中像<code>Array</code>和<code>Dictionary</code>这样的集合类型若被声明为值可变的话，它们就是线程不安全的。那Foundation中的<code>NSArray</code>线程是否安全呢？不一定！苹果还专门为那些线程非安全的Foundation类列了一个<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html" target="_blank">清单</a>。</p><br><p>尽管多线程可以在不出现问题的情况下同时读取一个<code>Array</code>的可变实例，但当一个线程试图修改实例的时候另一个线程又试图读取实例，这样的话安全性可就不能被保证了。</p><br><p>在下面<code>PhotoManager.swift</code>中的<code>addPhoto</code>函数中找一找错误：</p><br><pre><code>func addPhoto(photo: Photo) {<br>  _photos.append(photo)<br>  dispatch_async(dispatch_get_main_queue()) {<br>    self.postContentAddedNotification()<br>  }<br>}</code></pre><br><p>这个<code>写取</code>方法修改了可变数组的对象。</p><br><p>再来看一看<code>photos</code>的<code>property</code>：</p><br><pre><code>private var _photos: [Photo] = []<br>var photos: [Photo] {<br>  return _photos<br>}</code></pre><br><p>当<code>property</code>的getter读取可变数组的时候它就是一个<code>读取</code>函数。调用者得到一份数组的copy并阻止原数组被不当修改，但这不能在一个线程调用<code>addPhoto</code>方法的同时阻止另一个线程回调<code>photo</code>的<code>property</code>的getter。</p><br><blockquote><br><p>提醒：在上述代码中，调用者为什么不直接得到一份<code>photos</code>的copy呢？这是因为在Swift中，所有的参数和函数的返回值都是通过推测（Reference）或值传输的。通过推测进行传输和Objective-C中传输指针是一样的，这就代表着你可以访问调用原始对象，并且对于同一对象的推测后其任何改变都可以被显示出来。在对象的copy中通过值结果传值且对于copy的更改都不对原是对象造成影响。Swift默认以推测机制或结构体的值来传输类的实例。</p><br><p>Swift中的<code>Array</code>和<code>Dictionary</code>都是通过结构体来实现的，当你向前或向后传输这些实例的时候，你的代码将会执行很多次的copy。这时不要当心内存使用问题，因为这些Swift的集合类型（如Array、Dictionary）的执行过程都已被优化，只有在必要的时候才会进行copy。对于来一个通过值传输的Array实例来说，只有在被传输后才会进行其第一次修改。</p><br></blockquote><br><p>这是一个常见的软件开发环境下的<a href="http://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem" target="_blank">读写问题</a>。GCD通过使用<code>dispatch barriers</code>提供了一个具有读/写锁的完美解决方案。</p><br><p>在使用并发队列时，dispatch barriers便是一组像连续性路障的函数。使用GCD的barrier API保证了被传输的闭包是在特定时间内、在特定队列上执行的唯一任务。这就意味着在派发的barrier前传输的任务必须在特定闭包开始执行前完成运行。</p><br><p>当闭包到达后，barrier便开始执行闭包并保证此段时间内队列不会再执行任何其他的闭包。特定闭包一旦完成执行，队列便会返回其默认的执行状态。GCD同样提供了具有同步与异步功能的barrier函数。</p><br><p>下面的图式描述了在多个异步任务中的barrier函数的运行效果：</p><br><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/579323-14ce06cc766991bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch barrier" data-original-src="http://upload-images.jianshu.io/upload_images/579323-14ce06cc766991bc.png"><br><div class="image-caption">dispatch barrier</div><br></div><br><p>需要注意的是在barrier执行前程序是以并发队列的形式运行，但当barrier一旦开始运行后，程序便以连续队列的形式运行。没错，barrier是这段特定时间内唯一被执行的任务。当barrier执行结束后，程序再次回到了普通的并发队列运行状态。</p><br><p>对于barrier函数我们做一些必要的说明：</p><br><ul><br><li><br><p><code>自定义连续队列（Custom Serial Queue）</code>：在这种情况下不是特别建议使用barrier，因为barrier在连续队列执行期间不会起到任何帮助。</p><br></li><br><li><br><p><code>全局并发队列（Global Concurrent Queue）</code>：谨慎使用；当其他系统也在使用队列的时候，你应该不想把所有的队列都垄为自己所用。</p><br></li><br><li><br><p><code>自定义并发队列（Custom Concurrent Queue）</code>：适用于涉及临界区及原子性的代码。在任何你想要保正设定（setting）或初始化具有线程安全性的情况下，barrier都是一个不错的选择。</p><br></li><br></ul><br><p>从上面对于自定义并发序列解释可以得出结论，你得写一个自己的barrier函数并将读取函数和写入函数彼此分开。并发序列将允许多个读取过程同步运行。</p><br><p>打开<code>PhotoManager.swift</code>，在<code>photos</code>属性下给类文件添加如下的私有属性：</p><br><pre><code>private let concurrentPhotoQueue = dispatch_queue_create(<br>    “com.raywenderlich.GooglyPuff.photoQueue”, DISPATCH_QUEUE_CONCURRENT)</code></pre><br><p>通过<code>dispatch_queue_create</code>函数初始化了一个名为<code>concurrentPhotoQueue</code>的并发队列。第一个参数是一个逆DNS风格的命名方式；其描述在debugging时会非常有用。第二个参数设定了你的队列是连续性的还是并发性的。</p><br><blockquote><p>很多网上的实例代码中都喜欢给<code>dispatch_queue_create</code>的第二个参数设定为<code>0</code>或<code>NULL</code>。其实这是一种过时的声明连续分派队列的方法。你最好用你自己的参数设定它。</p></blockquote><br><p>找到<code>addPhoto</code>函数并代替为以下代码：</p><br><pre><code>func addPhoto(photo: Photo) {<br>  dispatch_barrier_async(concurrentPhotoQueue) { // 1<br>    self._photos.append(photo) // 2<br>    dispatch_async(GlobalMainQueue) { // 3<br>      self.postContentAddedNotification()<br>    }<br>  }<br>}</code></pre><br><p>你的新函数是这样工作的：</p><br><ol><br><li><br><p>通过使用你自己的自定义队列添加写入过程，在不久后临界区执行的时候这将是你的队列中唯一执行的任务。</p><br></li><br><li><br><p>向数组中添加对象。只要这是一个barrier属性的闭包，那么它在<code>concurrentPhotoQueue</code>队列中绝不会和其他闭包同时运行。</p><br></li><br><li><br><p>最后你推送了一个照片添加完毕的消息。这个消息应该从主线程推送因为它将处理一些涉及UI的工作，所以你为这个消息以异步的形式向主线程派发了任务。</p><br></li><br></ol><br><p>以上便处理好了写入方法的问题，但是你还要处理一下<code>photos</code>的读取方法。</p><br><p>为了保证写入方面的线程安全行，你需要在<code>concurrentPhotoQueue</code>队列中运行读取方法。因为你需要从函数获取返回值并且在读取任务返回前不会运行任何其他的任务，所以你不能向队列异步派发任务。</p><br><p>在这种情况下，<code>dispatch_sync</code>是一个不错的选择。</p><br><p><code>dispatch_sync</code>可以同步传输任务并在其返回前等待其完成。使用<code>dispatch_sync</code>跟踪含有派发barrier的任务，或者在当你需要使用闭包中的数据时而要等待运行结束的时候使用<code>dispatch_sync</code>。</p><br><p>谨慎也是必要的。想象一下，当你对一个马上要运行的队列调用<code>dispatch_sync</code>时，这将造成死锁。因为调用要等到闭包B执行后才能开始运行，但是这个闭包B只有等到当前运行的且不可能结束的闭包A执行结束后才有可能结束。<br>这将迫使你时刻注意自己调用的的或是传入的队列。</p><br><p>来看一下<code>dispatch_sync</code>的使用说明：</p><br><ul><br><li><br><p><code>自定义连续队列（Custome Serial Queue）</code>：这种情况下一定要非常小心；假如一个队列中正在执行任务并且你将这个队列传入<code>dispatch_sync</code>中使用，这毫无疑问会造成死锁。</p><br></li><br><li><br><p><code>主队列（Main Queue[Serial]）</code>：同样需要小心发生死锁。</p><br></li><br><li><br><p><code>并发队列（Concurrent Queue）</code>：在对派发barrier执行同步工作或等待一个任务的执行结束后需要进行下一步处理的情况下，<code>dispatch_sync</code>是一个不错的选择。</p><br></li><br></ul><br><p>依旧在<code>PhotoManager.swift</code>文件中，用以下代码替换原有的<code>photos</code>属性：</p><br><pre><code>var photos: [Photo] {<br>  var photosCopy: [Photo]!<br>  dispatch_sync(concurrentPhotoQueue) { // 1<br>    photosCopy = self._photos // 2<br>  }<br>  return photosCopy<br>}</code></pre><br><p>分布解释一下：</p><br><ol><br><li><br><p>同步派发<code>concurrentPhotoQueue</code>使其执行读取功能。</p><br></li><br><li><br><p>储存照片数组至<code>photosCopy</code>并返回。</p><br></li><br></ol><br><p>恭喜－－你的<code>PhotoManager</code>单例现在线程安全了。不管现在是执行读取还是写入功能，你都可以保证整个单例在安全模式下运行。</p><br><h1>队列可视化</h1><br><p>还不能完全理解GCD的基础知识？接下来我们将在一个简单的示例中使用断点和<code>NSLog</code>功能确保你进一步理解GCD函数运行原理。</p><br><p>我将使用两个动态的GIF帮助你理解<code>dispatch_async</code>和<code>dispatch_sync</code>。在GIF的每步切换下，注意代码断点与图式的关系。</p><br><h4>dispatch_sync重览</h4><br><pre><code>override func viewDidLoad() {<br>  super.viewDidLoad()<br><br>  dispatch_sync(dispatch_get_global_queue(<br>      Int(QOS_CLASS_USER_INTERACTIVE.value), 0)) {<br><br>    NSLog(“First Log”)<br><br>  }<br><br>  NSLog(“Second Log”)<br>}</code></pre><br><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/579323-6eaf4a7e9fb6bebd.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch_sync" data-original-src="http://upload-images.jianshu.io/upload_images/579323-6eaf4a7e9fb6bebd.gif"><br><div class="image-caption">dispatch_sync</div><br></div><br><p>分布解释：</p><br><ol><br><li><br><p>主队列按顺序执行任务，下一个将要被执行的任务便是实例化包含<code>viewDidLoad</code>的<code>UIViewController</code>。</p><br></li><br><li><br><p>主队列开始执行<code>viewDidLoad</code>。</p><br></li><br><li><br><p><code>dispatch_sync</code>闭包添加至全局队列并在稍后被执行。在此闭包完成执行前主队列上的工作将被暂停。回调的闭包可以被并发执行并以FIFO的顺序添加至一个全局队列。这个全局队列还包含添加<code>dispatch_sync</code>闭包前的多个任务。</p><br></li><br><li><br><p>终于轮到<code>dispatch_sync</code>闭包执行了。</p><br></li><br><li><br><p>闭包执行结束后主队列开始恢复工作。</p><br></li><br><li><br><p><code>viewDidLoad</code>函数执行结束，主队列开始处理其他任务。</p><br></li><br></ol><br><p><code>dispatch_sync</code>函数向队列添加了一个任务并等待任务完成。 其实<code>dispatch_async</code>也差不多，只不过它不会等待任务完成便会返回线程。</p><br><h4>dispatch_async重览</h4><br><pre><code>override func viewDidLoad() {<br>  super.viewDidLoad()<br><br>  dispatch_async(dispatch_get_global_queue(<br>      Int(QOS_CLASS_USER_INTERACTIVE.value), 0)) {<br><br>    NSLog(“First Log”)<br><br>  }<br><br>  NSLog(“Second Log”)<br>}</code></pre><br><div class="image-package"><br><img src="http://upload-images.jianshu.io/upload_images/579323-f2a023f3ae2039f9.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch_async" data-original-src="http://upload-images.jianshu.io/upload_images/579323-f2a023f3ae2039f9.gif"><br><div class="image-caption">dispatch_async</div><br></div><br><ol><br><li><br><p>主队列按顺序执行任务，下一个将要被执行的任务便是实例化包含<code>viewDidLoad</code>的`UIViewControl。</p><br></li><br><li><br><p>主队列开始执行<code>viewDidLoad</code>。</p><br></li><br><li><br><p><code>dispatch_async</code>闭包添加至全局队列并在稍后被执行。</p><br></li><br><li><br><p>向全局队列添加<code>dispatch_async</code>闭包后<code>viewDidLoad</code>函数继续运行，主线程继续其剩余的任务。与此同时全局队列是并发性的处理它的任务的。可被并发执行的闭包将以FIFO的顺序添加至全局队列。</p><br></li><br><li><br><p>通过<code>dispatch_async</code>添加的闭包开始执行。</p><br></li><br><li><br><p><code>dispatch_async</code>闭包执行结束，并且所有的<code>NSLog</code>语句都已被显示在控制台上。</p><br></li><br></ol><br><p>在这个例子中，第二个<code>NSLog</code>语句执行后第一个<code>NSLog</code>语句才执行。这种情况并不是每次都会发生的－－这取决于硬件在给定的时间内所处理的工作，并且你对于哪个语句会先被执行一无所知且毫无控制权。没准“第一个”<code>NSLog</code>就会作为第一个log出现。</p><br><h1>Where to Go From Here?</h1><br><p>在这篇教程中，你学会了如何让你的代码具有线程安全性和如何在CPU高密度处理多个任务的时候获取主线程的响应。</p><br><p>你可以从这里下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2015/01/GooglyPuff_Swift_End_1_Xcode63.zip" target="_blank">GooglyPuff</a>的完整代码，在下一节教程中你将会继续在这个工程中进行修改。</p><br><p>假如你打算优化你的App，我觉得你真的该使用<code>Instruments</code>中的<code>Time Profile</code>. 具体教程请查看这篇<a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode" target="_blank">How To Use Instruments</a>。</p><br><p>在<a href="http://www.raywenderlich.com/79150/grand-central-dispatch-tutorial-swift-part-2" target="_blank">下一节教程</a>中，你将会利用更深层次的GCD的API去做些更Cool的东西。</p><br></div>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/swift/">swift</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/swift/">swift</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/10/Grand-Central-Dispatch-基础教程：Part-1-2/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/10/Grand-Central-Dispatch-基础教程：Part-1-2/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/10/OBJC和DYNAMIC/" title="@OBJC和DYNAMIC" itemprop="url">@OBJC和DYNAMIC</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-06-10T02:44:45.000Z" itemprop="datePublished"> 发表于 2015-06-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><div class="post-content clearfix"><br>        <p>虽然说 Swift 语言的初衷是希望能摆脱 Objective-C 的沉重的历史包袱和约束，但是不可否认的是经过了二十多年的洗礼，Cocoa 框架早就烙上了不可磨灭的 Objective-C 的印记。无数的第三方库是用 Objective-C 写成的，这些积累无论是谁都不能小觑。因此，在最初的版本中，Swift 不得不考虑与 Objective-C 的兼容。</p></div></p>
<p>Apple 采取的做法是允许我们在同一个项目中同时使用 Swift 和 Objective-C 来进行开发。其实一个项目中的 Objective-C 文件和 Swift 文件是处于两个不同世界中的，为了让它们能相互联通，我们需要添加一些桥梁。</p><br><p>首先通过添加 <code>{product-module-name}-Bridging-Header.h</code> 文件，并在其中填写想要使用的头文件名称，我们就可以很容易地在 Swift 中使用 Objective-C 代码了。Xcode 为了简化这个设定，甚至在 Swift 项目中第一次导入 Objective-C 文件时会主动弹框进行询问是否要自动创建这个文件，可以说是非常方便。</p><br><p>但是如果想要在 Objective-C 中使用 Swift 的类型的时候，事情就复杂一些。如果是来自外部的框架，那么这个框架与 Objective-C 项目肯定不是处在同一个 target 中的，我们需要对外部的 Swift module 进行导入。这个其实和使用 Objective-C 的原来的 Framework 是一样的，对于一个项目来说，外界框架是由 Swift 写的还是 Objective-C 写的，两者并没有太大区别。我们通过使用 2013 年新引入的 <code>@import</code> 来引入 module：</p><br><pre><code>@import MySwiftKit;<br></code></pre><br><p>之后就可以正常使用这个 Swift 写的框架了。</p><br><p>如果想要在 Objective-C 里使用的是同一个项目中的 Swift 的源文件的话，可以直接导入自动生成的头文件 <code>{product-module-name}-Swift.h</code> 来完成。比如项目的 target 叫做 <code>MyApp</code> 的话，我们就需要在 Objective-C 文件中写</p><br><pre><code>#import “MyApp-Swift.h”<br></code></pre><br><p>但这只是故事的开始。Objective-C 和 Swift 在底层使用的是两套完全不同的机制，Cocoa 中的 Objective-C 对象是基于运行时的，它从骨子里遵循了 KVC (Key-Value Coding，通过类似字典的方式存储对象信息) 以及动态派发 (Dynamic Dispatch，在运行调用时再决定实际调用的具体实现)。而 Swift 为了追求性能，如果没有特殊需要的话，是不会在运行时再来决定这些的。也就是说，Swift 类型的成员或者方法在编译时就已经决定，而运行时便不再需要经过一次查找，而可以直接使用。</p><br><p>显而易见，这带来的问题是如果我们要使用 Objective-C 的代码或者特性来调用纯 Swift 的类型时候，我们会因为找不到所需要的这些运行时信息，而导致失败。解决起来也很简单，在 Swift 类型文件中，我们可以将需要暴露给 Objective-C 使用的任何地方 (包括类，属性和方法等) 的声明前面加上 <code>@objc</code> 修饰符。注意这个步骤只需要对那些不是继承自 <code>NSObject</code> 的类型进行，如果你用 Swift 写的 class 是继承自 <code>NSObject</code> 的话，Swift 会默认自动为所有的非 private 的类和成员加上 <code>@objc</code>。这就是说，对一个 <code>NSObject</code> 的子类，你只需要导入相应的头文件就可以在 Objective-C 里使用这个类了。</p><br><p><code>@objc</code> 修饰符的另一个作用是为 Objective-C 侧重新声明方法或者变量的名字。虽然绝大部分时候自动转换的方法名已经足够好用 (比如会将 Swift 中类似 <code>init(name: String)</code> 的方法转换成 <code>-initWithName:(NSString *)name</code> 这样)，但是有时候我们还是期望 Objective-C 里使用和 Swift 中不一样的方法名或者类的名字，比如 Swift 里这样的一个类：</p><br><pre><code>class 我的类 {<br>    func 打招呼(名字: String) {<br>        println(“哈喽，(名字)”)<br>    }<br>}<br>我的类().打招呼(“小明”)<br></code></pre><br><p>Objective-C 的话是无法使用中文来进行调用的，因此我们<strong>必须</strong>使用 <code>@objc</code> 将其转为 ASCII 才能在 Objective-C 里访问：</p>

<p><pre><code>@objc(MyClass)<br>class 我的类 {<br>    @objc(greeting:)<br>    func 打招呼(名字: String) {<br>        println(“哈喽，(名字)”)<br>    }<br>}<br></code></pre></p>
<p></p><p>这样，我们在 Objective-C 里就能调用 <code>[[MyClass new] greeting:@”XiaoMing”]</code> 这样的代码了 (虽然比起原来一点都不好玩了)。另外，正如上面所说的以及在 <a href="http://swifter.tips/selector/" target="_blank" rel="external">Selector</a> 一节中所提到的，即使是 <code>NSObject</code> 的子类，Swift 也不会在被标记为 <code>private</code> 的方法或成员上自动加 <code>@objc</code>。如果我们需要使用这些内容的动态特性的话，我们需要手动给它们加上 <code>@objc</code> 修饰。</p><p></p>
<p></p><p>添加 <code>@objc</code> 修饰符并不意味着这个方法或者属性会变成动态派发，Swift 依然可能会将其优化为静态调用。如果你需要和 Objective-C 里动态调用时相同的运行时特性的话，你需要使用的修饰符是 <code>dynamic</code>。一般情况下在做 app 开发时应该用不上，但是在施展一些像动态替换方法或者运行时再决定实现这样的 “黑魔法” 的时候，我们就需要用到 <code>dynamic</code> 修饰符了。在之后的 KVO 一节中，我们还会提到一个关于使用 <code>dynamic</code> 的实例。</p><br>    <br>作者王巍 <a href="http://swifter.tips/" target="_blank" rel="external">(@onevcat)</a> 原文地址 <a href="http://swifter.tips/objc-dynamic/" target="_blank" rel="external">http://swifter.tips/objc-dynamic/</a><p></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/swift/">swift</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/swift/">swift</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/10/OBJC和DYNAMIC/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/10/OBJC和DYNAMIC/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/09/iOS学习参考/" title="iOS学习参考" itemprop="url">iOS学习参考</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-06-09T01:10:54.000Z" itemprop="datePublished"> 发表于 2015-06-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="社区博客">社区博客</h1><p><a href="http://www.cocoachina.com/" target="_blank" rel="external">CocoaChina</a></p>
<p>苹果开发中文站 - 最热的iPhone开发社区，最热的苹果开发社区，最热的iPad开发社区。</p>
<p><a href="http://www.code4app.com/" target="_blank" rel="external">Code4App</a></p>
<p>Code4App是一个移动平台的代码库，是iOS开发好帮手。Code4App为移动开发程序员提供大量的开源代码，iOS代码实例搜索，iOS特效示例，iOS代码例子下载。所有的开源代码都经过严格测试，并且配有效果图和演示视频。你可以搜索并下载你需要的任意代码，当然，你也可以浏览这些效果图或者视频，来找找你的UI设计灵感。同时网站内的火花社区供开发者进行求职招聘、技术交流、分享设计创意、展示作品等方面的交流。</p>
<p><a href="http://ios.jobbole.com" target="_blank" rel="external">伯乐在线</a></p>
<p>分享iOS开发资讯和文章</p>
<p><a href="http://www.oschina.net/ios/home" target="_blank" rel="external">开源中国</a></p>
<p>iOS开发社区 - 开源中国社区</p>
<h1 id="个人博客">个人博客</h1><p><a href="http://blog.devtang.com/" target="_blank" rel="external">唐巧</a></p>
<p>InfoQ编辑, 《iOS开发进阶》作者, 在猿题库创业。Java开发工程师，曾开发网易微博后台。 iOS开发工程师，曾开发有道云笔记、猿题库。 </p>
<p><a href="http://www.onevcat.com/" target="_blank" rel="external">王巍</a></p>
<p>一名来自中国的 iOS / Unity 开发者。现居日本，就职于 LINE。正在修行，探求创意之源。</p>
<p><a href="http://beyondvincent.com/" target="_blank" rel="external">破船之家</a></p>
<p>我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的烟火…</p>
<p><a href="http://www.cnblogs.com/chijianqiang/" target="_blank" rel="external">池建强</a></p>
<p>70后程序员。先后从事互联网和企业级应用开发。目前就职瑞友科技（原用友软件工程）IT应用研究院，任职副院长。技术创新控，坚持年轻时的理想，倒霉的乐观者，关注互联网技术、应用平台研发、领域驱动，OSGi，动态语言应用 、云计算、Mac OS相关技术。喜欢的一句话：虽万千人，吾往矣</p>
<p><a href="http://casatwy.com" target="_blank" rel="external">田伟宇</a></p>
<p>Currently working at Alibaba.inc as an iOS engineer for food.</p>
<h1 id="其他推荐">其他推荐</h1><p><a href="http://objccn.io" target="_blank" rel="external">objc中国</a></p>
<p>为中国 Objective-C 社区带来最佳实践和先进技术</p>
<p><a href="http://tech.glowing.com" target="_blank" rel="external">Glow技术团队博客</a></p>
<p>Thoughts, stories and ideas.</p>
<p><a href="https://github.com/Aufree/trip-to-iOS" target="_blank" rel="external">iOS 学习资料整理</a></p>
<p>这份学习资料是为 iOS 初学者所准备的, 旨在帮助 iOS 初学者们快速找到适合自己的学习资料, 节省他们搜索资料的时间, 使他们更好的规划好自己的 iOS 学习路线, 更快的入门, 更准确的定位的目前所处的位置.</p>
<p><a href="https://github.com/tangqiaoboy/iOSBlogCN" target="_blank" rel="external">推荐博客列表</a></p>
<p>中文 iOS/Mac 开发博客列表</p>
<h1 id="写在最后">写在最后</h1><p>在长的路，一步步也能走完；在短的路，不迈开双脚也无法到达！</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/09/iOS学习参考/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/09/iOS学习参考/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/31/iOS应用数据存储的常用方式/" title="iOS应用数据存储的常用方式" itemprop="url">iOS应用数据存储的常用方式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-05-31T02:40:39.000Z" itemprop="datePublished"> 发表于 2015-05-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>这里开始使用markdown格式输入你的正文。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/数据存储/">数据存储</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/31/iOS应用数据存储的常用方式/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/31/iOS应用数据存储的常用方式/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/27/The-Internet-Communications-Ice-简介/" title="The Internet Communications (ice)" itemprop="url">The Internet Communications (ice)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-05-27T09:26:50.000Z" itemprop="datePublished"> 发表于 2015-05-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="简介">简介</h1><p>The Internet Communications Engine (ice) is a modern object-oriented toolkit that enables you to build distributed applications with minimal effort. Ice allows you to focus your efforts on your application logic, and it takes care of all interactions with low-level network programming interfaces. With Ice, there is no need to worry about details such as opening network connections, serializing and deserializing data for network transmission, or retrying failed connection attempts (to name but a few of dozens of such low-level details).</p>
<h1 id="开发环境搭建">开发环境搭建</h1><p>ICE安装文件：<a href="https://zeroc.com/icetouch/download.html" target="_blank" rel="external">https://zeroc.com/icetouch/download.html</a><br>ICE编译插件：<a href="https://github.com/zeroc-ice/ice-builder-xcode" target="_blank" rel="external">https://github.com/zeroc-ice/ice-builder-xcode</a></p>
<h1 id="相关文档">相关文档</h1><p>ICE官网：<a href="http://www.zeroc.com/ice.html" target="_blank" rel="external">http://www.zeroc.com/ice.html</a><br>官网文档：<a href="http://doc.zeroc.com/display/Doc/Home" target="_blank" rel="external">http://doc.zeroc.com/display/Doc/Home</a><br>性能评测：<a href="http://zeroc.com/articles/IcePerformanceWhitePaper.pdf" target="_blank" rel="external">http://zeroc.com/articles/IcePerformanceWhitePaper.pdf</a></p>
<h1 id="ICE通讯框架基本原理">ICE通讯框架基本原理</h1><p>ICE的思路是，用一个中间语言，建立数据结构规范和接口规范，然后再用一个IDE编译插件，将中间语言数据结构规范和接口规范编译为当前的语言，譬如OC的.h/.m文件，接下来，你在客户端和服务端实现中间语言定义号的接口，再做一些其它处理，就可以实现一个分布式程序了。这个思路确实很Nice，值得我们借鉴。</p>
<h1 id="通讯方式选择">通讯方式选择</h1><p>P2P（设备直连）</p>
<p>通过服务器中转</p>
<h1 id="网络连接方式">网络连接方式</h1><p>基于TCP的长连接</p>
<p>基于HTTP短连接PULL的方式</p>
<h1 id="协议选择">协议选择</h1><p>XMPP</p>
<p>SIP</p>
<p>MQTT</p>
<p>私有协议（二进制协议）</p>
<h1 id="其他">其他</h1><p>p2p视频聊天的过程：音视频数据采集—&gt;编码—&gt;发送—&gt;接收—&gt;解码—&gt;播放</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/ice/">ice</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/05/27/The-Internet-Communications-Ice-简介/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/05/27/The-Internet-Communications-Ice-简介/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/swift/" title="swift">swift<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS/" title="iOS">iOS<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/swift/" title="swift">swift<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/数据存储/" title="数据存储">数据存储<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ice/" title="ice">ice<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://casatwy.com" target="_blank" title="App架构相关文章">田伟宇</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="hexo相关学习">Jark&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://tool.lu/favicon" target="_blank" title="icon制作在线工具">Icon制作</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> “Hello ,I&#39;m ZhuLi in Chinasofti.” <br/>
			“This is my blog,believe it or not.”</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/zhuli8" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/zhuli8com" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="https://www.zhihu.com/people/zhu-li-68-76" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:zhuli1228@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="朱利">朱利</a>
		
		
		</p>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','TqhyGfTT5KJKMHcgZnBF','2.0.0');
</script>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"zhuli8"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_3725936'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D3725936' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
