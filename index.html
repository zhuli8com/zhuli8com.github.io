
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>zhuli8’blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="朱利">
    

    
    <meta name="description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">
<meta property="og:type" content="website">
<meta property="og:title" content="zhuli8’blog">
<meta property="og:url" content="http://www.zhuli8.com/index.html">
<meta property="og:site_name" content="zhuli8’blog">
<meta property="og:description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhuli8’blog">
<meta name="twitter:description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">

    
    <link rel="alternative" href="/atom.xml" title="zhuli8’blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="zhuli8’blog" title="zhuli8’blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="zhuli8’blog">zhuli8’blog</a></h1>
				<h2 class="blog-motto">Talk is cheap, show me the code.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
    <input type="text" id="st-search-input" maxlength="20" placeholder="搜索" />
    </form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/01/iOS中提取app的图片/" title="iOS中提取app的图片" itemprop="url">iOS中提取app的图片</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2017-10-01T02:05:41.000Z" itemprop="datePublished"> 发表于 2017-10-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="iTunes"><a href="#iTunes" class="headerlink" title="iTunes"></a>iTunes</h2><p>下载 <a href="https://link.jianshu.com/?t=https://secure-appldnld.apple.com/itunes12/091-33628-20170922-EF8F0FE4-9FEF-11E7-B113-91CF9A97A551/iTunes12.6.3.dmg" target="_blank" rel="external">iTunes 12.6.3</a> 支持 iPhone 8，iPhone X和iOS 11,获取AppStore应用的IPA包。</p>
<p>强制删除其他版本的iTunes：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">rm</span> -rf /Applications/iTunes.<span class="keyword">app</span></span><br></pre></td></tr></table></figure>
<h2 id="iOS-Images-Extractor"><a href="#iOS-Images-Extractor" class="headerlink" title="iOS-Images-Extractor"></a>iOS-Images-Extractor</h2><p><a href="https://github.com/devcxm/iOS-Images-Extractor" target="_blank" rel="external">iOS-Images-Extractor</a></p>
<p>打开软件后，拖拽ipa、car文件、png、jpg或者整个文件夹到软件窗口，点击Start按钮即可开始提取图片资源文件。</p>
<p>图片默认输出到/User/用户名/Downloads/iOSImagesExtractor文件夹，可直接点击Output Dir按钮快速跳转到输出文件夹。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.jianshu.com/p/43acc44f1d2b" target="_blank" rel="external">解决 iTunes 12.7 无法下载 AppStore应用的IPA包问题</a></p>
<p><a href="http://www.jianshu.com/p/8152e1828aec" target="_blank" rel="external">iOS中如何找到一款app的所有图片</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/10/01/iOS中提取app的图片/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/10/01/iOS中提取app的图片/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/09/29/xcode9/" title="xcode9" itemprop="url">xcode9</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2017-09-29T02:05:41.000Z" itemprop="datePublished"> 发表于 2017-09-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="在全屏模式下使用xcode模拟器"><a href="#在全屏模式下使用xcode模拟器" class="headerlink" title="在全屏模式下使用xcode模拟器"></a>在全屏模式下使用xcode模拟器</h1><ul>
<li>开启模拟器Internal菜单</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /AppleInternal</span><br><span class="line"></span><br><span class="line">OSX10.<span class="number">11</span>的一个新特性 Rootless,也叫System Integrity Protection（SIP）和SELinux差不多，都是限制root用户的权限。其实可以在RecoveryMode关闭这个特性，这样就直接可以读写/usr/bin了，不过不建议。（关闭方法：开机的时候按住option出现选择磁盘的界面按<span class="built_in">command</span> + R进入RecoveryMode，选择实用工具终端，输入csrutil <span class="built_in">disable</span>回车搞定）</span><br></pre></td></tr></table></figure>
<ul>
<li>设置模拟器允许全屏模式</li>
</ul>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">Xcode9模拟器</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">Internal</span><span class="literal">-</span><span class="literal">-</span>&gt;<span class="comment">Allow</span> <span class="comment">Fullscreen</span> <span class="comment">Mode</span></span><br></pre></td></tr></table></figure>
<ul>
<li>mac添加桌面（快捷键：四指向上调出）–&gt;添加Xcode9 –&gt;添加模拟器</li>
</ul>
<p><img src="../photos/xcode9.png" alt="xcode9"></p>
<ul>
<li>参考链接</li>
</ul>
<p> <a href="https://www.appcoda.com.tw/ios-simulator-tips-tricks/" target="_blank" rel="external">提升 iOS 開發效率！ Xcode 9 內置模擬器的新功能與技巧</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/09/29/xcode9/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/09/29/xcode9/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/31/http-server/" title="http-server" itemprop="url">http-server</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2017-05-31T03:10:27.000Z" itemprop="datePublished"> 发表于 2017-05-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>最近调试iOS移动端H5遇到两个问题，一个是访问本地站点文件，一个是使用Chrome调试。</p>
<h1 id="http-server快速创建node-js-静态服务器"><a href="#http-server快速创建node-js-静态服务器" class="headerlink" title="http-server快速创建node.js 静态服务器"></a>http-server快速创建node.js 静态服务器</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局安装http-server</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> <span class="keyword">http</span>-<span class="keyword">server</span></span></span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>进入自己的文件目录，运行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http-server -a <span class="number">192.168</span><span class="number">.91</span><span class="number">.218</span> -p <span class="number">8080</span></span><br></pre></td></tr></table></figure>
<p>启动node.js静态服务器，监听8080端口，静态目录就是当前运行命令所在的目录。</p>
<h1 id="Chrome-DevTool调试iOS设备的webView"><a href="#Chrome-DevTool调试iOS设备的webView" class="headerlink" title="Chrome DevTool调试iOS设备的webView"></a>Chrome DevTool调试iOS设备的webView</h1><p><a href="https://github.com/google/ios-webkit-debug-proxy" target="_blank" rel="external">iOS WebKit Debug Proxy</a></p>
<h2 id="启动proxy"><a href="#启动proxy" class="headerlink" title="启动proxy"></a>启动proxy</h2><p>终端执行</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios_webkit_debug_proxy -f chrome-<span class="string">devtools:</span><span class="comment">//devtools/bundled/inspector.html</span></span><br></pre></td></tr></table></figure>
<p>返回结果为</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Listing devices on :9221</span><br><span class="line">Connected :9222 to “lizhu”的 iPhone (f<span class="number">008f6196</span>e<span class="number">655d8d30</span>aa00ab<span class="number">943508a72</span><span class="number">6f1f562</span>)</span><br></pre></td></tr></table></figure>
<p>在chrome中打开 localhost:9221 ，可以看到当前已连接的设备列表才算成功。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/19c18c924f91" target="_blank" rel="external">使用Chrome DevTool调试iOS设备的webView</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/开发利器/">开发利器</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/开发利器/">开发利器</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2017/05/31/http-server/#comments" class="ds-thread-count comments-count-link" data-thread-key="2017/05/31/http-server/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/05/31/关于Xcode的Other_Linker_Flags/" title="关于Xcode的Other Linker Flags" itemprop="url">关于Xcode的Other Linker Flags</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2016-05-31T03:10:27.000Z" itemprop="datePublished"> 发表于 2016-05-31</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在ios开发过程中，有时候会用到第三方的静态库(.a文件)，然后导入后发现编译正常但运行时会出现<strong>selector not recognized</strong>的错误，从而导致app闪退。接着仔细阅读库文件的说明文档，你可能会在文档中发现诸如在<strong>Other Linker Flags</strong>中加入<strong>-ObjC</strong>或者<strong>-all_load</strong>这样的解决方法。</p>
<p>那么，<strong>Other Linker Flags</strong>到底是用来干什么的呢？还有<strong>-ObjC</strong>和<strong>-all_load</strong>到底发挥了什么作用呢？</p>
<h1 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h1><p>首先，要说明一下<strong>Other Linker Flags</strong>到底是用来干嘛的。说白了，就是<strong>ld</strong>命令除了默认参数外的其他参数。<strong>ld</strong>命令实现的是链接器的工作，详细说明可以在终端<strong>man ld</strong>查看。</p>
<p>如果有人不清楚链接器是什么东西的话，我可以作个简单的说明。</p>
<p>一个程序从简单易读的代码到可执行文件往往要经历以下步骤：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源代码 &gt; 预处理器 &gt; 编译器 &gt; 汇编器 &gt; 机器码 &gt; 链接器 &gt; 可执行文件</span><br></pre></td></tr></table></figure>
<p>源文件经过一系列处理以后，会生成对应的.obj文件，然后一个项目必然会有许多.obj文件，并且这些文件之间会有各种各样的联系，例如函数调用。链接器做的事就是把这些目标文件和所用的一些库链接在一起形成一个完整的可执行文件。</p>
<h1 id="为什么会闪退"><a href="#为什么会闪退" class="headerlink" title="为什么会闪退"></a>为什么会闪退</h1><p>苹果官方Q&amp;A上有这么一段话：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The <span class="string">"selector not recognized"</span> runtime exception occurs due <span class="keyword">to</span> an issue between the implementation <span class="keyword">of</span> standard UNIX <span class="keyword">static</span> libraries, the linker <span class="keyword">and</span> the dynamic nature <span class="keyword">of</span> Objective-C. Objective-C does <span class="keyword">not</span> define linker symbols <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">function</span> (<span class="keyword">or</span> method, <span class="keyword">in</span> Objective-C) - instead, linker symbols are only generated <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">class</span>. <span class="keyword">If</span> you extend a pre-existing <span class="keyword">class</span> <span class="keyword">with</span> categories, the linker does <span class="keyword">not</span> know <span class="keyword">to</span> associate the <span class="built_in">object</span> code <span class="keyword">of</span> the core <span class="keyword">class</span> implementation <span class="keyword">and</span> the category implementation. This prevents objects created <span class="keyword">in</span> the resulting application <span class="keyword">from</span> responding <span class="keyword">to</span> a selector that <span class="keyword">is</span> defined <span class="keyword">in</span> the category.</span><br></pre></td></tr></table></figure>
<p>翻译过来，大概意思就是Objective-C的链接器并不会为每个方法建立符号表，而是仅仅为类建立了符号表。这样的话，如果静态库中定义了已存在的一个类的分类，链接器就会以为这个类已经存在，不会把分类和核心类的代码合起来。这样的话，在最后的可执行文件中，就会缺少分类里的代码，这样函数调用就失败了。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>解决方法在背景那块我就提到了，就是在Other Linker Flags里加上所需的参数，用到的参数一般有以下3个：</p>
<blockquote>
<p>-ObjC</p>
<p>-all_load</p>
<p>-force_load</p>
</blockquote>
<p>下面来说说每个参数存在的意义和具体做的事情。</p>
<p>首先是-ObjC，一般这个参数足够解决前面提到的问题，苹果官方说明如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This flag causes the linker to <span class="operator"><span class="keyword">load</span> every <span class="keyword">object</span> <span class="keyword">file</span> <span class="keyword">in</span> the <span class="keyword">library</span> that defines an Objective-<span class="keyword">C</span> <span class="keyword">class</span> <span class="keyword">or</span> <span class="keyword">category</span>. <span class="keyword">While</span> this <span class="keyword">option</span> will typically <span class="keyword">result</span> <span class="keyword">in</span> a larger executable (due <span class="keyword">to</span> additional <span class="keyword">object</span> code loaded <span class="keyword">into</span> the application), it will <span class="keyword">allow</span> the successful <span class="keyword">creation</span> <span class="keyword">of</span> effective Objective-<span class="keyword">C</span> <span class="keyword">static</span> libraries that contain categories <span class="keyword">on</span> existing classes.</span></span><br></pre></td></tr></table></figure>
<p>简单说来，加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中，虽然这样可能会因为加载了很多不必要的文件而导致可执行文件变大，但是这个参数很好地解决了我们所遇到的问题。但是事实真的是这样的吗？</p>
<p>如果-ObjC参数真的这么有效，那么事情就会简单多了。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Important: For <span class="number">64</span>-bit <span class="keyword">and</span> iPhone OS applications, there <span class="keyword">is</span> a linker bug <span class="keyword">that</span> prevents -ObjC <span class="keyword">from</span> loading objects files <span class="keyword">from</span> static libraries <span class="keyword">that</span> <span class="keyword">contain</span> only categories <span class="keyword">and</span> no classes. The workaround <span class="keyword">is</span> <span class="keyword">to</span> use <span class="keyword">the</span> -allload <span class="keyword">or</span> -forceload flags.</span><br></pre></td></tr></table></figure>
<p>当静态库中只有分类而没有类的时候，-ObjC参数就会失效了。这时候，就需要使用-all_load或者-force_load了。</p>
<p>-all_load会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到-ObjC失效的情况下使用-force_load参数。</p>
<p>-force_load所做的事情跟-all_load其实是一样的，但是-force_load需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Objective-C/">Objective-C</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Objective-C/">Objective-C</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/05/31/关于Xcode的Other_Linker_Flags/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/05/31/关于Xcode的Other_Linker_Flags/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/01/02/3D-Touch-实践/" title="3D Touch 实践" itemprop="url">3D Touch 实践</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2016-01-02T10:05:45.000Z" itemprop="datePublished"> 发表于 2016-01-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>iphone6s的一个显著卖点应该是3D Touch，其原理是增加了一个压力感触，通过区分轻按和重按来进行不同的用户交互。</p>
<p>我们可以通过3D手势，在主屏幕上的应用Icon处，直接进入应用的响应功能模块。用户可以通过3D Touch手势在view上来预览一些预加载信息，这样的设计可以使app更加简洁大方，交互性也更强，也是对app的一个优化。</p>
<h1 id="Home-Screen-Quick-Actions"><a href="#Home-Screen-Quick-Actions" class="headerlink" title="Home Screen Quick Actions"></a>Home Screen Quick Actions</h1><p>通过主屏幕的应用Icon，我们可以用3D Touch呼出一个菜单，进行快速定位应用功能模块相关功能的开发。</p>
<h2 id="静态标签"><a href="#静态标签" class="headerlink" title="静态标签"></a>静态标签</h2><p>静态标签是我们在项目的配置plist文件中配置的标签，在用户安装程序后就可以使用，并且排序会在动态标签的前面。</p>
<p>在Info.plist文件中添加UIApplicationShortcutItems数组，在改数组下建立一个包括UIApplicationShortcutItemTitle、UIApplicationShortcutSubtitle、UIApplicationShortcutItemIconFile、UIApplicationShortcutType键值对的字典即可,系统并没有提示，只能手打上去。</p>
<h2 id="动态标签"><a href="#动态标签" class="headerlink" title="动态标签"></a>动态标签</h2><p>动态标签是我们在程序中，通过代码添加的，与之相关的类，主要有三个：UIApplicationShortcutItem、UIMutableApplicationShortcutItem、UIApplicationShortcutIcon。</p>
<p>在appDelegate的-application:didFinishLaunchingWithOptions:方法中添加如下代码：</p>
<p>1.图标<br>UIApplicationShortcutIcon *icon1=[UIApplicationShortcutIcon iconWithTemplateImageName:@”iCon1”];</p>
<p>系统自带图标:[UIApplicationShortcutIcon iconWithType:UIApplicationShortcutIconTypeSearch]</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIApplicationShortcutIconType</span>) &#123;</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeCompose</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypePlay</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypePause</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeAdd</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeLocation</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeSearch</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeShare</span>,</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeProhibit</span>       <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeContact</span>        <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeHome</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeMarkLocation</span>   <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeFavorite</span>       <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeLove</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeCloud</span>          <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeInvitation</span>     <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeConfirmation</span>   <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeMail</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeMessage</span>        <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeDate</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeTime</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeCapturePhoto</span>   <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeCaptureVideo</span>   <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeTask</span>           <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeTaskCompleted</span>  <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeAlarm</span>          <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeBookmark</span>       <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeShuffle</span>        <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeAudio</span>          <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1),</span><br><span class="line">    <span class="built_in">UIApplicationShortcutIconTypeUpdate</span>         <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_1)</span><br><span class="line">&#125; <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_0) __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure>
<p>2.创建shortcut item<br>UIMutableApplicationShortcutItem *item1=[[UIMutableApplicationShortcutItem alloc] initWithType:@”com.zhuli8.dynamic” localizedTitle:@”Dynamic Shortcut” localizedSubtitle:@”available after first lauch” icon:icon1 userInfo:nil];</p>
<p>3.获取已经存在的shortcut item，例如静态的shortcut item<br>NSArray *existingItems=[UIApplication sharedApplication].shortcutItems;</p>
<p>4.当前所有的shortcut item赋值给当前应用程序<br>NSArray *updateItems=[existingItems arrayByAddingObjectsFromArray:@[item1]];<br>[UIApplication sharedApplication].shortcutItems=updateItems;</p>
<p>到此动态创建3d touch已经基本完成。如果要响应标签的行为，需要实现appDelegate中的一个方法-application:willFinishLaunchingWithOptions: </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span>))completionHandler&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([shortcutItem<span class="variable">.type</span> isEqualToString:<span class="string">@"com.zhuli8.deep1"</span>]) &#123;</span><br><span class="line">        ZLSecondeViewController *secondVC=[[ZLSecondeViewController alloc] init];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span>=secondVC;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="peep-pop"><a href="#peep-pop" class="headerlink" title="peep/pop"></a>peep/pop</h1><p>这个功能是一套全新的用户交互机制，在使用3D Touch时，ViewController中会有如下三个交互阶段：</p>
<ol>
<li>提示用户这里有3D Touch的交互，会使交互控件周围模糊</li>
<li>继续深按，会出现预览视图</li>
<li>通过视图上的交互控件进行进一步交互</li>
</ol>
<p>在控制器的-viewWillAppear:方法中判断设备是否有3d touch特性，根据返回值决定是否设置代理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.traitCollection</span><span class="variable">.forceTouchCapability</span>==<span class="built_in">UIForceTouchCapabilityAvailable</span>) &#123;</span><br><span class="line">    [<span class="keyword">self</span> registerForPreviewingWithDelegate:<span class="keyword">self</span> sourceView:<span class="keyword">self</span><span class="variable">.view</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现UIViewControllerPreviewingDelegate的两个代理方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable <span class="built_in">UIViewController</span> *)previewingContext:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext viewControllerForLocation:(<span class="built_in">CGPoint</span>)location <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</span><br><span class="line">- (<span class="keyword">void</span>)previewingContext:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext commitViewController:(<span class="built_in">UIViewController</span> *)viewControllerToCommit <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0);</span><br></pre></td></tr></table></figure>
<p>具体实例代码如下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIViewController</span> *)previewingContext:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext viewControllerForLocation:(<span class="built_in">CGPoint</span>)location&#123;</span><br><span class="line">    <span class="comment">//check if we're not already displaying a preview controller</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.presentedViewController</span> isKindOfClass:[ZLPreviewViewController class]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ZLPreviewViewController *previewVC=[[ZLPreviewViewController alloc] init];</span><br><span class="line">    <span class="keyword">return</span> previewVC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)previewingContext:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerPreviewing</span>&gt;)previewingContext commitViewController:(<span class="built_in">UIViewController</span> *)viewControllerToCommit&#123;</span><br><span class="line">    <span class="comment">//deep press:bring up the commit view controller(pop)</span></span><br><span class="line">    ZLCommitViewController *commitVC=[[ZLCommitViewController alloc] init];</span><br><span class="line">    [<span class="keyword">self</span> showViewController:commitVC sender:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写父类的previewActionItems方法配置preview菜单</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;<span class="built_in">UIPreviewActionItem</span>&gt;&gt; *)previewActionItems&#123;</span><br><span class="line">    <span class="built_in">UIPreviewAction</span> *action1=[<span class="built_in">UIPreviewAction</span> actionWithTitle:<span class="string">@"action 1"</span> style:<span class="built_in">UIPreviewActionStyleDefault</span> handler:^(<span class="built_in">UIPreviewAction</span> * _Nonnull action, <span class="built_in">UIViewController</span> * _Nonnull previewViewController) &#123;</span><br><span class="line">        ZLLogDebug(<span class="string">@"UIPreviewActionStyleDefault trggered"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIPreviewAction</span> *action2=[<span class="built_in">UIPreviewAction</span> actionWithTitle:<span class="string">@"destructive action"</span> style:<span class="built_in">UIPreviewActionStyleDestructive</span> handler:^(<span class="built_in">UIPreviewAction</span> * _Nonnull action, <span class="built_in">UIViewController</span> * _Nonnull previewViewController) &#123;</span><br><span class="line">        ZLLogDebug(<span class="string">@"UIPreviewActionStyleDestructive trggered"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIPreviewAction</span> *action3=[<span class="built_in">UIPreviewAction</span> actionWithTitle:<span class="string">@"selected action"</span> style:<span class="built_in">UIPreviewActionStyleSelected</span> handler:^(<span class="built_in">UIPreviewAction</span> * _Nonnull action, <span class="built_in">UIViewController</span> * _Nonnull previewViewController) &#123;</span><br><span class="line">        ZLLogDebug(<span class="string">@"UIPreviewActionStyleSelected trggered"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIPreviewActionGroup</span> *group1=[<span class="built_in">UIPreviewActionGroup</span> actionGroupWithTitle:<span class="string">@"action group"</span> style:<span class="built_in">UIPreviewActionStyleDefault</span> actions:@[action1,action2,action3]];<span class="comment">//可以返回组</span></span><br><span class="line">    <span class="keyword">return</span> @[action1,action2,action3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Force-Properties"><a href="#Force-Properties" class="headerlink" title="Force Properties"></a>Force Properties</h1><p>iOS9为我们提供了一个新的交互参数:力度。我们可以检测某一交互的力度值，来做相应的交互处理。例如，我们可以通过力度来控制快进的快慢，音量增加的快慢等。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/01/02/3D-Touch-实践/#comments" class="ds-thread-count comments-count-link" data-thread-key="2016/01/02/3D-Touch-实践/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/25/项目中用到的工具和技术/" title="项目中用到的工具和技术" itemprop="url">项目中用到的工具和技术</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-10-25T07:58:16.000Z" itemprop="datePublished"> 发表于 2015-10-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>总结一下项目中用到的工具和技术，以便以后的查看。</p>
<h1 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h1><p><a href="http://devhelpers.com/app/icon/resizer/" target="_blank" rel="external">在线通过1024 * 1024图片生成iPhone 1倍、2倍、3倍图片</a></p>
<h1 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h1><p><a href="http://blog.csdn.net/wzzvictory/article/details/18737437" target="_blank" rel="external">CocoaPods详解之—-使用篇</a></p>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/19178709" target="_blank" rel="external">CocoaPods详解之—-进阶篇</a></p>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/20067595" target="_blank" rel="external">CocoaPods详解之—-制作篇</a></p>
<p><a href="http://www.cocoachina.com/swift/20150630/12305.html" target="_blank" rel="external">怎样在Swift中使用CocoaPods</a></p>
<p><a href="http://www.cocoachina.com/swift/20150806/12831.html" target="_blank" rel="external">怎样在swift中创建一个CocoaPods</a></p>
<p><a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/" target="_blank" rel="external">使用Cocoapods创建私有podspec</a></p>
<h1 id="线程方案"><a href="#线程方案" class="headerlink" title="线程方案"></a>线程方案</h1><p>在iOS开发中其实有4套多线程方案，他们分别是：</p>
<p><strong> pthreads </strong></p>
<blockquote>
<p>POSIX线程（POSIX threads），简称pthreads，是线程的POSIX标准。该标准定义了创建和操作线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中都使用pthreads作为操作系统的线程。</p>
</blockquote>
<p><strong> NSThread </strong></p>
<p><strong> GCD</strong></p>
<p><strong> NSOperation&amp;NSOperationQueue </strong></p>
<p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<p><a href="http://blog.xcodev.com/archives/operation-queue-intro/" target="_blank" rel="external">并发编程之Operation Queue</a></p>
<p><a href="http://www.jianshu.com/p/0b0d9b1f1f19#" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></p>
<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><p><a href="http://www.jianshu.com/p/b35793b3749d" target="_blank" rel="external">RunLoop的简单介绍</a></p>
<h1 id="iOS8适配"><a href="#iOS8适配" class="headerlink" title="iOS8适配"></a>iOS8适配</h1><p><a href="http://www.jianshu.com/p/86f933850df8" target="_blank" rel="external">在iOS 8中使用UIAlertController</a></p>
<p><a href="http://www.cocoachina.com/industry/20140729/9269.html" target="_blank" rel="external">WWDC 2014 Session笔记 - iOS界面开发的大一统</a></p>
<p><a href="http://www.jianshu.com/p/f1208b5e42d9" target="_blank" rel="external">Alamofire网络库基础教程</a></p>
<h1 id="iOS9适配"><a href="#iOS9适配" class="headerlink" title="iOS9适配"></a>iOS9适配</h1><p><a href="http://www.liuchungui.com/blog/2015/10/11/ios9zhi-gua-pei-ats/" target="_blank" rel="external">iOS9之适配ATS</a></p>
<p><a href="http://www.cocoachina.com/ios/20150821/13140.html" target="_blank" rel="external">如何使用ATS提高应用的安全性</a></p>
<p><a href="http://www.cocoachina.com/ios/20150717/12650.html" target="_blank" rel="external">苹果新『应用通信安全』的理解和使用</a></p>
<p><a href="http://www.cocoachina.com/ios/20150820/13118.html" target="_blank" rel="external">UIStackView如何让你的开发更简单</a></p>
<p><a href="http://www.cnblogs.com/dsxniubility/p/4821184.html" target="_blank" rel="external">整理iOS9适配中出现的坑（图文）</a></p>
<h1 id="iOS性能调优"><a href="#iOS性能调优" class="headerlink" title="iOS性能调优"></a>iOS性能调优</h1><h2 id="Analyze静态分析"><a href="#Analyze静态分析" class="headerlink" title="Analyze静态分析"></a>Analyze静态分析</h2><p>逻辑错误、声明错误、api调用错误基本在编译时都会有警告，Analyze的主要的优势在于静态分析内存泄露及代码逻辑错误。</p>
<ol>
<li>逻辑错误：访问空指针或未初始化的变量等。</li>
<li>内存管理错误：如内存泄露等。</li>
<li>声明错误：从未使用过的变量。</li>
<li>api调用错误：未包含使用的库和框架。</li>
</ol>
<h2 id="Leaks内存泄露"><a href="#Leaks内存泄露" class="headerlink" title="Leaks内存泄露"></a>Leaks内存泄露</h2><p>把Snapshot Interval 间隔时间设置为10秒，勾选Automatic Snapshotting，Leaks会自动进行内存捕捉分析。在你怀疑有内存泄露的操作前和操作后点击Snapshot Now进行手动捕捉。</p>
<p>Leaked Object的表格中显示了内存泄露的类型、数量及内存空间。</p>
<p>点击具体的某个内存泄露对象，在右侧Detail窗口中会出现导致泄露可能的位置，其中黑色部分代表了最可能的位置。双击即可进入代码。</p>
<p><strong>开启了ARC并不是就不会存在内存问题，苹果有句名言：ARC is only for NSObject。</strong></p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>1、正常编译没问题，在Profile 中就编译通不过。</p>
<p>选择Profile，将Build Configuration设置为Debug,这样在.pch文件中，#ifdef DEBUG 编译条件下定义的宏才生效。</p>
<p>2、Symbol Name 列的友好显示。</p>
<p>BuildOpthions–&gt;DebugInfomationFormat=DWARF with dSYM File</p>
<p>Xcode编译项目后，我们会看到一个同名的 dSYM 文件，dSYM 是保存 16 进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文件中，并且每次编译项目的时候都会生成一个新的 dSYM 文件。</p>
<h2 id="Allocation内存使用"><a href="#Allocation内存使用" class="headerlink" title="Allocation内存使用"></a>Allocation内存使用</h2><ol>
<li>在进入一个视图前或操作前，我们在Allocation面板左侧点击Mark Generation，这时候会产生Generation A节点，显示内存当前的情况。</li>
<li>在进入视图后再点一次Mark Generation。</li>
<li>在视图退出后再点一次Mark</li>
</ol>
<p>这样三次产生的 Generation分别记录了进入前、进入后、关闭后，在最后一个Generation应该内存被合理释放，否则就代表了在这个视图或操作中有泄漏或不合理的地方。</p>
<h2 id="Zombies僵尸对象（EXC-BAD-ACCESS）"><a href="#Zombies僵尸对象（EXC-BAD-ACCESS）" class="headerlink" title="Zombies僵尸对象（EXC_BAD_ACCESS）"></a>Zombies僵尸对象（EXC_BAD_ACCESS）</h2><p>用于查找那些被过度释放的僵尸对象（overreleased objects）。</p>
<ol>
<li>启动Instruments，选择Zombies。</li>
<li>对之前产生EXC_BAD_ACCESS的测试用例重新运行，直到程序崩溃，如果发生EXC_BAD_ACCESS错误，会出现对应界面。</li>
<li>通过滑动箭头来查看错误细节，例如可以看到该对象的内存操作过程，如malloc、autorelease、retain、release等操作。</li>
<li>查看底部的详细历史，选择相应的行可以定位到相应的代码，找出产生错误的代码</li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://yyny.me/ios/一次TableView性能优化经历/" target="_blank" rel="external">一次TableView性能优化经历</a></p>
<p><a href="http://www.cnblogs.com/ym123/category/668845.html" target="_blank" rel="external">iOS性能调优系列</a></p>
<h1 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h1><p>deliver用于上传应用的二进制代码、应用截屏和原数据到应用商店</p>
<p>snapshot可以自动化iOS应用在每个设备上的本地化截屏过程</p>
<p>frameit用于在应用截屏外添加设备框架</p>
<p>PEM可以自动化地生成和更新应用推送通知描述文件</p>
<p>sigh可以生成并下载开发者的应用商店配置文件</p>
<p><a href="http://www.infoq.com/cn/news/2015/01/fastlane-ios-continuous-deploy" target="_blank" rel="external">Fastlane为iOS带来持续部署</a></p>
<p><a href="http://www.jianshu.com/users/384f80cdc57b/latest_articles" target="_blank" rel="external">马建成系列</a></p>
<h1 id="stackoverflow"><a href="#stackoverflow" class="headerlink" title="stackoverflow"></a>stackoverflow</h1><p>stackoverflow在中国被墙了，不能登陆进行答题和收藏，所以在此记录工作中有所帮助的问题！根据链家基本上就能看出大概的问题了，以此来纪念那些被解决的问题！</p>
<p><a href="http://stackoverflow.com/questions/26865132/strings-in-switch-statements-string-does-not-conform-to-protocol-intervaltyp#" target="_blank" rel="external">http://stackoverflow.com/questions/26865132/strings-in-switch-statements-string-does-not-conform-to-protocol-intervaltyp#</a></p>
<p><a href="http://stackoverflow.com/questions/25951195/swift-print-vs-println-vs-nslog#" target="_blank" rel="external">http://stackoverflow.com/questions/25951195/swift-print-vs-println-vs-nslog#</a></p>
<p><a href="http://stackoverflow.com/questions/28427458/ios-webrtc-library-supporting-both-armv7-arm64" target="_blank" rel="external">http://stackoverflow.com/questions/28427458/ios-webrtc-library-supporting-both-armv7-arm64</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="http://www.jianshu.com/p/802f52c5f13a" target="_blank" rel="external">如何利用搜索框</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_4caf02490102vr4s.html" target="_blank" rel="external">Xcode各版本官方下载及百度云盘下载, Mac和IOS及Xcode版本历史.</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/25/项目中用到的工具和技术/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/10/25/项目中用到的工具和技术/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/09/06/iOS网络相关总结/" title="iOS网络相关总结" itemprop="url">iOS网络相关总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-09-06T05:49:17.000Z" itemprop="datePublished"> 发表于 2015-09-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="HTTP通信过程"><a href="#HTTP通信过程" class="headerlink" title="HTTP通信过程"></a>HTTP通信过程</h1><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>HTTP协议规定，一个完整的由 <strong>客户端</strong> 发给 <strong>服务器</strong> 的HTTP请求中包含以下内容。</p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>包含了 <code>请求方法</code>、<code>请求资源路径</code>、<code>HTTP协议版本</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /ZLServer/resources/images/<span class="number">1.</span>jpg HTTP/<span class="number">1.1</span></span><br></pre></td></tr></table></figure>
<h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>包含了<code>对客户端的环境描述</code>、<code>客户端请求的主机地址</code>等信息，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Host:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.105</span>:<span class="number">8080</span> 	<span class="comment">// 客户端想访问的服务器主机地址</span></span><br><span class="line">User-<span class="string">Agent:</span> Mozilla<span class="regexp">/5.0 (Macintosh; Intel Mac OS X 10.9) Firefox/</span><span class="number">30.0</span> </span><br><span class="line">							<span class="comment">// 客户端的类型，客户端的软件环境</span></span><br><span class="line"><span class="string">Accept:</span> text<span class="regexp">/html, */</span>* 		<span class="comment">// 客户端所能接收的数据类型</span></span><br><span class="line">Accept-<span class="string">Language:</span> zh-cn 		<span class="comment">// 客户端的语言环境</span></span><br><span class="line">Accept-<span class="string">Encoding:</span> gzip 		<span class="comment">// 客户端支持的数据压缩格式</span></span><br></pre></td></tr></table></figure>
<h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p>客户端发给服务器的具体数据，比如文件数据。</p>
<h3 id="创建GET请求"><a href="#创建GET请求" class="headerlink" title="创建GET请求"></a>创建GET请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *urlStr = [<span class="string">@"http://192.168.1.102:8080/MJServer/login?username=123&amp;pwd=123"</span> stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlStr];</span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br></pre></td></tr></table></figure>
<h3 id="创建POST请求"><a href="#创建POST请求" class="headerlink" title="创建POST请求"></a>创建POST请求</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *urlStr = @<span class="string">"http://192.168.1.102:8080/MJServer/login"</span>;</span><br><span class="line">NSURL *url = <span class="string">[NSURL URLWithString:urlStr]</span>;</span><br><span class="line">NSMutableURLRequest *request = <span class="string">[NSMutableURLRequest requestWithURL:url]</span>;</span><br><span class="line">request.HTTPMethod = @<span class="string">"<span class="keyword">POST</span>"</span>;</span><br><span class="line">// 请求体</span><br><span class="line">NSString *bodyStr = @<span class="string">"username=123&amp;pwd=123"</span>;</span><br><span class="line">request.HTTPBody = <span class="string">[bodyStr dataUsingEncoding:NSUTF8StringEncoding]</span>;</span><br></pre></td></tr></table></figure>
<h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><p><strong>客户端</strong> 向 <strong>服务器</strong> 发送请求，<strong>服务器 </strong>应当做出响应，即返回数据给 <strong>客户端</strong>。</p>
<p>HTTP协议规定，一个完整的HTTP响应中包含以下内容：</p>
<h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>包含了<code>HTTP协议版本</code>、<code>状态码</code>、<code>状态英文名称</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure>
<h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><p>包含了<code>对服务器的描述</code>、<code>对返回数据的描述</code>，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache-Coyote/<span class="number">1.1</span> 		    <span class="comment">// 服务器的类型</span></span><br><span class="line">Content-Type: image/jpeg 		    <span class="comment">// 返回数据的类型</span></span><br><span class="line">Content-Length: <span class="number">56811</span> 		        <span class="comment">// 返回数据的长度</span></span><br><span class="line">Date: Mon, <span class="number">23</span> Jun <span class="number">2014</span> <span class="number">12</span>:<span class="number">54</span>:<span class="number">52</span> GMT	<span class="comment">// 响应的时间</span></span><br></pre></td></tr></table></figure>
<h3 id="实体内容"><a href="#实体内容" class="headerlink" title="实体内容"></a>实体内容</h3><p><strong>服务器</strong> 返回给 <strong>客户端</strong> 的具体数据，比如文件数据。</p>
<h1 id="HTTP请求方案"><a href="#HTTP请求方案" class="headerlink" title="HTTP请求方案"></a>HTTP请求方案</h1><p>在iOS中，常见的发送HTTP请求方案有苹果原生和第三方框架。</p>
<h2 id="苹果原生（自带）"><a href="#苹果原生（自带）" class="headerlink" title="苹果原生（自带）"></a>苹果原生（自带）</h2><h3 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h3><p>用法简单，最古老最经典最直接的一种方案。</p>
<p>负责发送请求，建立客户端和服务器的连接。发送NSURLRequest到数据给服务器，并收集来自服务器的响应数据。</p>
<h4 id="NSURL"><a href="#NSURL" class="headerlink" title="NSURL"></a>NSURL</h4><p>请求地址。</p>
<h4 id="NSURLRequest"><a href="#NSURLRequest" class="headerlink" title="NSURLRequest"></a>NSURLRequest</h4><p>一个NSURLRequest对象就代表一个请求，它包含的信息有：</p>
<pre><code>一个NSURL对象
请求方法、请求头、请求体
请求超时
... ...
</code></pre><h4 id="NSMutableURLRequest"><a href="#NSMutableURLRequest" class="headerlink" title="NSMutableURLRequest"></a>NSMutableURLRequest</h4><p>NSURLRequest的子类。</p>
<p><strong>常用方法</strong></p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">设置请求超时等待时间（超过这个时间就算超时，请求失败）</span><br><span class="line">- (<span class="type">void</span>)setTimeoutInterval:(<span class="type">NSTimeInterval</span>)seconds;</span><br><span class="line"></span><br><span class="line">设置请求方法（比如<span class="type">GET</span>和<span class="type">POST</span>）</span><br><span class="line">- (<span class="type">void</span>)setHTTPMethod:(<span class="type">NSString</span> *)<span class="keyword">method</span>;</span><br><span class="line"></span><br><span class="line">设置请求体</span><br><span class="line">- (<span class="type">void</span>)setHTTPBody:(<span class="type">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line">设置请求头</span><br><span class="line">- (<span class="type">void</span>)setValue:(<span class="type">NSString</span> *)value forHTTPHeaderField:(<span class="type">NSString</span> *)field;</span><br></pre></td></tr></table></figure>
<h4 id="NSURLConnection的使用步骤"><a href="#NSURLConnection的使用步骤" class="headerlink" title="NSURLConnection的使用步骤"></a>NSURLConnection的使用步骤</h4><p>使用NSURLConnection发送请求到步骤很简单，创建一个NSURL对象，设置请求路径；传入NSURL创建一个NSURLRequest对象，设置请求头和请求体；使用NSURLConnection发送NSURLRequest。</p>
<p>NSURLConnection常见的发送请求方法有以下几种：</p>
<h5 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (NSData <span class="keyword">*</span>)sendSynchronousRequest:(NSURLRequest <span class="keyword">*</span>)request returningResponse:(NSURLResponse <span class="keyword">*</span><span class="keyword">*</span>)response error:(NSError <span class="keyword">*</span><span class="keyword">*</span>)error;</span><br></pre></td></tr></table></figure>
<h5 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h5><p>根据对服务器返回数据的处理方式掉不同，又可以分为2种：</p>
<p><strong>block回调</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span>*) request queue:(<span class="built_in">NSOperationQueue</span>*) queue completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>* response, <span class="built_in">NSData</span>* data, <span class="built_in">NSError</span>* connectionError)) handler;</span><br></pre></td></tr></table></figure>
<p><strong>代理</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request delegate:(<span class="keyword">id</span>)delegate;</span><br><span class="line">+ (<span class="built_in">NSURLConnection</span>*)connectionWithRequest:(<span class="built_in">NSURLRequest</span> *)request delegate:(<span class="keyword">id</span>)delegate;</span><br><span class="line">- (<span class="keyword">id</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request delegate:(<span class="keyword">id</span>)delegate startImmediately:(<span class="built_in">BOOL</span>)startImmediately;<span class="comment">//在startImmediately = NO的情况下，需要调用start方法开始发送请求</span></span><br><span class="line">- (<span class="keyword">void</span>)start;</span><br></pre></td></tr></table></figure>
<pre><code>成为NSURLConnection的代理，最好遵守NSURLConnectionDataDelegate协议
</code></pre><h5 id="NSURLConnectionDataDelegate协议中的代理方法"><a href="#NSURLConnectionDataDelegate协议中的代理方法" class="headerlink" title="NSURLConnectionDataDelegate协议中的代理方法"></a>NSURLConnectionDataDelegate协议中的代理方法</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">开始接收到服务器的响应时调用</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connection</span>:<span class="value">(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response</span></span>;</span><br><span class="line"></span><br><span class="line">接收到服务器返回的数据时调用（服务器返回的数据比较大时会调用多次）</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connection</span>:<span class="value">(NSURLConnection *)connection didReceiveData:(NSData *)data</span></span>;</span><br><span class="line"></span><br><span class="line">服务器返回的数据完全接收完毕后调用</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connectionDidFinishLoading</span>:<span class="value">(NSURLConnection *)connection</span></span>;</span><br><span class="line"></span><br><span class="line">请求出错时调用（比如请求超时）</span><br><span class="line"><span class="tag">-</span> (<span class="tag">void</span>)<span class="rule"><span class="attribute">connection</span>:<span class="value">(NSURLConnection *)connection didFailWithError:(NSError *)error</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h3><p>iOS7新出的技术，功能比NSURLConnection更加强大。</p>
<h3 id="CFNetwork"><a href="#CFNetwork" class="headerlink" title="CFNetwork"></a>CFNetwork</h3><p>NSURLConnection和NSURLSession的底层，纯C语言。</p>
<h2 id="第三方框架"><a href="#第三方框架" class="headerlink" title="第三方框架"></a>第三方框架</h2><h3 id="ASIHttpRequest"><a href="#ASIHttpRequest" class="headerlink" title="ASIHttpRequest"></a>ASIHttpRequest</h3><p>外号“HTTP终结者”，功能极其强大，可惜早已停止更新。</p>
<h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><p>简单易用，提供了基本够用的常用功能，维护和使用者多。</p>
<h3 id="MKNetworkKit"><a href="#MKNetworkKit" class="headerlink" title="MKNetworkKit"></a>MKNetworkKit</h3><p>简单易用，维护和使用者少。</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON是一种轻量级的数据格式，一般用于数据交互。服务器返回给客户端的数据，一般都是JSON格式或者XML格式（文件下载除外）。</p>
<h2 id="JSON解析方案"><a href="#JSON解析方案" class="headerlink" title="JSON解析方案"></a>JSON解析方案</h2><p>在iOS中，JSON的常见解析方案有4种</p>
<p>第三方框架：<code>JSONKit</code>、<code>SBJson</code>、<code>TouchJSON</code>（性能从左到右越差）</p>
<p>苹果原生（自带）：<code>NSJSONSerialization</code>（性能最好）</p>
<h3 id="NSJSONSerialization的常见方法"><a href="#NSJSONSerialization的常见方法" class="headerlink" title="NSJSONSerialization的常见方法"></a>NSJSONSerialization的常见方法</h3><p><strong>JSON数据 –&gt; OC对象</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (id)<span class="type">JSONObjectWithData</span>:(<span class="type">NSData</span> *)<span class="typedef"><span class="keyword">data</span> options:<span class="container">(<span class="type">NSJSONReadingOptions</span>)</span>opt error:<span class="container">(<span class="type">NSError</span> **)</span>error;</span></span><br></pre></td></tr></table></figure>
<p><strong>OC对象 –&gt; JSON数据</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSData</span> *)dataWithJSONObject:(<span class="keyword">id</span>)obj options:(<span class="built_in">NSJSONWritingOptions</span>)opt error:(<span class="built_in">NSError</span> **)error;</span><br></pre></td></tr></table></figure>
<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>全称是Extensible Markup Language，译作“可扩展标记语言”，跟JSON一样，也是常用的一种用于交互的数据格式，一般也叫XML文档（XML Document）。</p>
<h2 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h2><p>一个常见的XML文档一般由<code>文档声明</code>、<code>元素（Element）</code>、<code>属性（Attribute）</code>三部分组成。</p>
<h3 id="文档声明"><a href="#文档声明" class="headerlink" title="文档声明"></a>文档声明</h3><p>在XML文档的最前面，必须编写一个文档声明，用来声明XML文档的类型。</p>
<p><strong>最简单的声明</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" ?&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>用encoding属性说明文档的字符编码</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="元素（Element）"><a href="#元素（Element）" class="headerlink" title="元素（Element）"></a>元素（Element）</h3><p>一个元素包括了开始标签和结束标签，规范的XML文档最多只有1个根元素，其他元素都是根元素的子孙元素。</p>
<p>XML中的所有空格和换行，都会当做具体内容处理。</p>
<h3 id="属性（Attribute）"><a href="#属性（Attribute）" class="headerlink" title="属性（Attribute）"></a>属性（Attribute）</h3><p>一个元素可以拥有多个属性，属性值必须用 双引号”” 或者 单引号’’ 括住。</p>
<p>实际上，属性表示的信息也可以用子元素来表示。</p>
<h2 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h2><p>XML的解析方式有2种：</p>
<pre><code>DOM：一次性将整个XML文档加载进内存，比较适合解析小文件
SAX：从根元素开始，按顺序一个元素一个元素往下解析，比较适合解析大文件
</code></pre><p>在iOS中，解析XML的手段有很多种。</p>
<h3 id="苹果原生"><a href="#苹果原生" class="headerlink" title="苹果原生"></a>苹果原生</h3><p>NSXMLParse：SAX方式解析，使用简单。</p>
<p>NSXMLParser采取的是SAX方式解析，特点是事件驱动，下面情况都会通知代理</p>
<pre><code>当扫描到文档（Document）的开始与结束
当扫描到元素（Element）的开始与结束
</code></pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用步骤</span><br><span class="line"><span class="comment">// 传入XML数据，创建解析器</span></span><br><span class="line"><span class="built_in">NSXMLParser</span> *parser = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:data];</span><br><span class="line"><span class="comment">// 设置代理，监听解析过程</span></span><br><span class="line">parser<span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">// 开始解析</span></span><br><span class="line">[parser parse];</span><br></pre></td></tr></table></figure>
<p><strong>NSXMLParserDelegate</strong></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">当扫描到文档的开始时调用（开始解析）</span><br><span class="line"><span class="pp">- <span class="params">(void)</span>parserDidStartDocument:<span class="params">(<span class="variable">NSXMLParser</span> *)</span>parser</span><br><span class="line"></span><br><span class="line">当扫描到文档的结束时调用（解析完毕）</span><br><span class="line">- <span class="params">(void)</span>parserDidEndDocument:<span class="params">(<span class="variable">NSXMLParser</span> *)</span>parser</span><br><span class="line"></span><br><span class="line">当扫描到元素的开始时调用（attributeDict存放着元素的属性）</span><br><span class="line">- <span class="params">(void)</span>parser:<span class="params">(<span class="variable">NSXMLParser</span> *)</span>parser didStartElement:<span class="params">(<span class="variable">NSString</span> *)</span>elementName namespaceURI:<span class="params">(<span class="variable">NSString</span> *)</span>namespaceURI qualifiedName:<span class="params">(<span class="variable">NSString</span> *)</span>qName attributes:<span class="params">(<span class="variable">NSDictionary</span> *)</span>attributeDict</span><br><span class="line"></span><br><span class="line">当扫描到元素的结束时调用</span><br><span class="line">- <span class="params">(void)</span>parser:<span class="params">(<span class="variable">NSXMLParser</span> *)</span>parser didEndElement:<span class="params">(<span class="variable">NSString</span> *)</span>elementName namespaceURI:<span class="params">(<span class="variable">NSString</span> *)</span>namespaceURI qualifiedName:<span class="params">(<span class="variable">NSString</span> *)</span>qName</span></span><br></pre></td></tr></table></figure>
<h3 id="第三方框架-1"><a href="#第三方框架-1" class="headerlink" title="第三方框架"></a>第三方框架</h3><p>libxml2：纯C语言，默认包含在iOS SDK中，同时支持DOM和SAX方式解析</p>
<p>GDataXML：DOM方式解析，由Google开发，基于libxml2</p>
<p><strong>GDataXML中常用的类</strong></p>
<pre><code>GDataXMLDocument：代表整个XML文档
GDataXMLElement：代表文档中的每个元素
使用attributeForName:方法可以获得属性值
</code></pre><p><strong>XML解析方式的选择建议</strong></p>
<pre><code>大文件：NSXMLParser、libxml2
小文件：GDataXML
</code></pre><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><p><a href="http://objccn.io/issue-5-4/" target="_blank" rel="external">从 NSURLConnection 到 NSURLSession</a></p>
<p><a href="http://blog.shiqichan.com/using-afnetworking-sdwebimage-and-ohhttpstubs/" target="_blank" rel="external">使用AFNetworking, SDWebimage和OHHTTPStubs</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/09/06/iOS网络相关总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/09/06/iOS网络相关总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/30/设计模式总结/" title="设计模式总结" itemprop="url">设计模式总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-08-30T06:08:47.000Z" itemprop="datePublished"> 发表于 2015-08-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>开始前请先看<a href="https://github.com/zhuli8com/DesignPattern.git" target="_blank" rel="external">源码Demo</a>。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在软件设计领域，设计模式是对通用问题的可复用的解决方案。设计模式是一系列帮你写出更可理解和复用代码的模板，设计模式帮你创建松耦合的代码以便你不需要费多大力就可以改变或者替换代码中的组件。</p>
<p>创建型：单利（单态）和 抽象工厂</p>
<p>结构型：模型-视图-控制器、装饰器、适配器、外观（门面)和组合模式</p>
<p>行为型：观察者、备忘录、责任链和命令模式</p>
<h1 id="MVC（模型-视图-控制器）"><a href="#MVC（模型-视图-控制器）" class="headerlink" title="MVC（模型-视图-控制器）"></a>MVC（模型-视图-控制器）</h1><p>模型-视图-控制器（MVC) 是Cocoa的构建块之一，毫无疑问它是使用最频繁的设计模式。它根据通用的角色去划分类，这样就使得类的职责可以根据角色清晰的划分开来。</p>
<blockquote>
<p>Model:模型保存应用程序的数据，定义了怎么去操作它。例如在本应用中模型就是Album类。</p>
<p>View:  视图是模型的可视化表示以及用户交互的控件；基本上来说，所有的UIView对象以及它的子类都属于视图。在本应用中AlbumView代表了视图。</p>
<p>Controller:控制器是一个协调所有工作的中介者（Mediator）。它访问模型中的数据并在视图中展示它们，同时它们还监听事件和根据需要操作数据。例如在本应用中ViewController。</p>
</blockquote>
<p>模型会把任何数据的变更通知控制器，然后控制器更新视图数据。视图对象通知控制器用户的操作，控制器要么根据需要来更新模型，要么检索任何被请求的数据。</p>
<p>你可能在想为什么不能仅仅使用控制器，在一个类中实现视图和模型，这样貌似更加容易? </p>
<p>所有的这些都归结于代码关注点分离以及复用。在理想的状态下，视图应该和模型完全的分离。如果视图不依赖某个实际的模型，那么视图就可以被复用来展示不同模型的数据。</p>
<p>举个例子来说，如果将来你打算加入电影或者书籍到你的资料库中，你仍然可以使用同样的AlbumView去显示电影和书籍数据。更进一步来说，如果你想创建一个新的与专辑有关联的工程，你可以很简单的复用Album类，因为它不依赖任何视图。这就是MVC的强大之处。</p>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例设计模式确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点。它通常采用懒加载的方式在第一次用到实例的时候再去创建它。</p>
<p>苹果大量使用了此模式。例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[NSUserDefaults standardUserDefaults]</span><br><span class="line">[UIApplication sharedApplication]</span><br><span class="line">[UIScreen mainScreen]</span><br><span class="line">[NSFileManager defaultManager]</span><br></pre></td></tr></table></figure>
<p>有一些情况下，只有一个实例显得非常合理。举例来说，你不需要有多个Logger的实例，除非你想去写多个日志文件。或者一个全局的配置处理类：实现线程安全的方式访问共享实例是容易的，比如一个配置文件，有好多个类同时修改这个文件。</p>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观模式针对复杂的子系统提供了单一的接口，不需要暴漏一系列的类和API给用户，你仅仅暴漏一个简单统一的API。这个API的使用者完全不需要关心背后的复杂性。这个模式非常适合有一大堆很难使用或者理解的类的情况。外观模式解耦了使用系统的代码和需要隐藏的接口和实现类。它也降低了外部代码对内部子系统的依赖性。当隐藏在外观之后的类很容易发生变化的时候，此模式就很有用了，因为当背后的类发生变化的时候，外观类始终保持了同样的API。</p>
<p>本应用中用PersistencyManager本地保存专辑数据，使用HTTPClient处理远程连接，工程中的其它类暂时与本次实现的逻辑无关。</p>
<p>为了实现这个模式，只有LibraryAPI应该保存PersistencyManager和HTTPClient的实例，然后LibraryAPI将暴漏一个简单的API去访问这些服务。LibraryAPI将暴漏给其它代码，但是它隐藏了HTTPClient和PersistencyManager的复杂性。</p>
<h1 id="装饰器（Decorator）模式"><a href="#装饰器（Decorator）模式" class="headerlink" title="装饰器（Decorator）模式"></a>装饰器（Decorator）模式</h1><p>装饰器模式在不修改原来代码的情况下动态的给对象增加新的行为和职责，它通过一个对象包装被装饰对象的方法来修改类的行为，这种方法可以做为子类化的一种替代方法。<br>在Objective-C中，存在两种非常常见的实现:Category(类别）和Delegation（委托）。</p>
<h2 id="Category-类别"><a href="#Category-类别" class="headerlink" title="Category(类别)"></a>Category(类别)</h2><p>Category(类别)是一种不需要子类化就可以让你能动态的给已经存在的类增加方法的强有力的机制。新增的方法是在编译期增加的，这些方法执行的时候和被扩展的类的其它方法是一样的。它可能与装饰器设计模式的定义稍微有点不同，因为Category(类别)不会保存被扩展类的引用。</p>
<p>除了可以扩展你自己的类以外，还可以给Cocoa自己的类增加方法。</p>
<p>本应用中需要让Album(专辑)对象显示在一个表格视图（TableView）中：专辑的标题从何而来？因为专辑是模型对象，它本身不需要关心你如何显示它的数据。你需要增加一些代码去扩展专辑类的行为，但是不需要直接修改专辑类。创建一个专辑类扩展的类别，定义一个新的方法，这个方法会返回能很容易和UITableViews使用的数据结构。 </p>
<h2 id="Delegation-委托"><a href="#Delegation-委托" class="headerlink" title="Delegation(委托)"></a>Delegation(委托)</h2><p>当你使用UITableView的时候，你必须要实现tableView:numberOfRowsInSection:方法。<br>你不可能让UITableView知道它需要在每个区域显示多少行，因为这些是应用特定的数据。因此计算每个区域需要显示多少行的职责就给了UITableView的委托。这就让UITableView类独立于它要显示的数据。</p>
<p>UITableView的职责就是显示一个表格视图。然而最终它需要一些它自身没有的信息。那么它就求助于它的委托，通过发送消息给委托来获取信息。在Objective-C实现委托模式的时候，一个类可以通过协议（Protocol）来声明可选以及必要的方法。</p>
<p>这个是一个重要的模式。苹果在UIKit类中大量使用了它：UITableView, UITextView, UITextField, UIWebView, UIAlert, UIActionSheet, UICollectionView, UIPickerView,UIGestureRecognizer, UIScrollView等等等。</p>
<h1 id="适配器（Adapter）模式"><a href="#适配器（Adapter）模式" class="headerlink" title="适配器（Adapter）模式"></a>适配器（Adapter）模式</h1><p>适配器可以让一些接口不兼容的类一起工作。它包装一个对象然后暴漏一个标准的交互接口。</p>
<p>苹果通过一个稍微不同的方式来实现它-苹果使用了协议的方式来实现。你可能已经熟悉UITableViewDelegate, UIScrollViewDelegate, NSCoding 和 NSCopying协议。举个例子，使用NSCopying协议，任何类都可以提供一个标准的copy方法。</p>
<h1 id="观察者（Observer）模式"><a href="#观察者（Observer）模式" class="headerlink" title="观察者（Observer）模式"></a>观察者（Observer）模式</h1><p>在观察者模式中，一个对象任何状态的变更都会通知另外的对改变感兴趣的对象。这些对象之间不需要知道彼此的存在，这其实是一种松耦合的设计。当某个属性变化的时候，我们通常使用这个模式去通知其它对象。</p>
<p>此模式的通用实现中，观察者注册自己感兴趣的其它对象的状态变更事件。当状态发生变化的时候，所有的观察者都会得到通知。苹果的推送通知（Push Notification）就是一个此模式的例子。</p>
<p>如果你要遵从MVC模式的概念，你需要让模型对象和视图对象在不相互直接引用的情况下通信。这正是观察者模式的用武之地。</p>
<p>Cocoa通过通知（Notifications）和Key-Value Observing(KVO)来实现观察者模式。</p>
<h2 id="通知（Notifications）"><a href="#通知（Notifications）" class="headerlink" title="通知（Notifications）"></a>通知（Notifications）</h2><p>不要和远程推送以及本地通知所混淆，通知是一种基于订阅-发布模式的模型，它让发布者可以给订阅者发送消息，并且发布者不需要对订阅者有任何的了解。</p>
<p>通知在苹果官方被大量的使用。举例来说，当键盘弹出或者隐藏的时候，系统会独立发送UIKeyboardWillShowNotification/UIKeyboardWillHideNotification通知。当你的应用进入后台运行的时候，系统会发送一个UIApplicationDidEnterBackgroundNotification通知。</p>
<h2 id="Key-Value-Observing-KVO-模式"><a href="#Key-Value-Observing-KVO-模式" class="headerlink" title="Key-Value Observing(KVO)模式"></a>Key-Value Observing(KVO)模式</h2><p>在KVO中，一个对象可以要求在它自身或者其它对象的属性发送变化的时候得到通知。</p>
<p>KVO机制让对象可以感知到属性的变化。在本例中，你可以使用KVO去观察UIImageView的image属性的变化。</p>
<h1 id="备忘录（Memento）模式"><a href="#备忘录（Memento）模式" class="headerlink" title="备忘录（Memento）模式"></a>备忘录（Memento）模式</h1><p>备忘录模式快照对象的内部状态并将其保存到外部。换句话说，它将状态保存到某处，过会你可以不破坏封装的情况下恢复对象的状态，也就是说原来对象中的私有数据仍然是私有的。</p>
<h2 id="归档（Archiving）"><a href="#归档（Archiving）" class="headerlink" title="归档（Archiving）"></a>归档（Archiving）</h2><p>归档是苹果对于备忘录模式的特定实现之一。这种机制可以转换一个对象到一个可保存的数据流中，过会可以在不暴漏私有属性给外部的情况下重建它们。</p>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>命令模式将一个请求封装为一个对象。封装以后的请求会比原生的请求更加灵活，因为这些封装后的请求可以在多个对象之间传递，存储以便以后使用，还可以动态的修改，或者放进一个队列中。苹果通过Target-Action机制和Invocation实现命令模式。</p>
<p>你可以通过苹果的官方在线文档阅读更多关于Target-Action的内容，至于Invocation，它采用了NSInvocation类，这个类包含了一个目标对象，方法选择器，以及一些参数。这个对象可以动态的修改并且可以按需执行。实践中它是一个命令模式很好的例子。它解耦了发送对象和接受对象，并且可以保存一个或者多个请求。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://xmuzyq.iteye.com/blog/1942376" target="_blank" rel="external">IOS设计模式之一（MVC模式，单例模式）</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/设计模式/">设计模式</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/30/设计模式总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/30/设计模式总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/23/Shell编程实践/" title="Shell编程实践" itemprop="url">Shell编程实践</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-08-23T08:15:35.000Z" itemprop="datePublished"> 发表于 2015-08-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>简单的说Shell就是一个包含若干行Shell或者Linux命令的文件。对于一次编写，多次使用的大量命令，就可以使用单独的文件保存下来，以便日后使用。</p>
<p>通常Shell脚本以.sh为后缀。如果要执行该脚本，必须先使其可执行</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chmod</span> +<span class="keyword">x</span> filename</span><br></pre></td></tr></table></figure>
<p>此后在该脚本所在目录下，输入./filename即可执行该脚本。</p>
<p>还有一种更简单的方法就是直接在终端用 <strong>sh</strong> 指令来执行。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sh</span> filename</span><br></pre></td></tr></table></figure>
<p>最近打包webRTC库时重复的工作和容易出错的机会让我想到了Shell脚本。基本需求就是把C++工程师那边的arm64、armv7、i386三个架构的zip包（webRTC静态库包的压缩文件）打成一个.a静态库。</p>
<p>下面就是这个过程中解决的两个版本。</p>
<h1 id="第一个版本"><a href="#第一个版本" class="headerlink" title="第一个版本"></a>第一个版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/usr/sh</span></span><br><span class="line"><span class="comment"># arm64包的名称</span></span><br><span class="line">arm64=Release-iphoneos</span><br><span class="line"><span class="comment"># armv7包的名称</span></span><br><span class="line">armv7=Release-iphoneos</span><br><span class="line"><span class="comment"># i386包的名称</span></span><br><span class="line">i386=Debug-iphonesimulator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩该目录下的$arm64.zip文件到该目录下的$arm64文件夹下,不提示的情况下覆盖文件</span></span><br><span class="line">unzip -o <span class="operator">-d</span> arm64/<span class="variable">$arm64</span>  arm64/<span class="variable">$arm64</span></span><br><span class="line"><span class="comment"># 解压缩该目录下的$armv7.zip文件到该目录下的$armv7文件夹下,不提示的情况下覆盖文件</span></span><br><span class="line">unzip -o <span class="operator">-d</span> armv7/<span class="variable">$armv7</span>  armv7/<span class="variable">$armv7</span></span><br><span class="line"><span class="comment"># 解压缩该目录下的$i386.zip文件到该目录下的$i386文件夹下,不提示的情况下覆盖文件</span></span><br><span class="line">unzip -o <span class="operator">-d</span> i386/<span class="variable">$i386</span>  i386/<span class="variable">$i386</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"解压缩成功"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上面的两个静态库移到其上一个目录</span></span><br><span class="line">mv arm64/<span class="variable">$arm64</span>/<span class="variable">$arm64</span>/<span class="variable">$capture</span> arm64/<span class="variable">$arm64</span>/<span class="variable">$arm64</span>/<span class="variable">$render</span> arm64/<span class="variable">$arm64</span>/</span><br><span class="line">mv armv7/<span class="variable">$armv7</span>/<span class="variable">$armv7</span>/<span class="variable">$capture</span> armv7/<span class="variable">$armv7</span>/<span class="variable">$armv7</span>/<span class="variable">$render</span> armv7/<span class="variable">$armv7</span>/</span><br><span class="line">mv i386/<span class="variable">$i386</span>/<span class="variable">$i386</span>/<span class="variable">$capture</span> i386/<span class="variable">$i386</span>/<span class="variable">$i386</span>/<span class="variable">$render</span> i386/<span class="variable">$i386</span>/</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"成功移动两个特殊的静态库"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并arm64/$arm64/$arm64/下所有*.a构建arm64为libWebRTC-arm64.a</span></span><br><span class="line">libtool -static -o arm64/<span class="variable">$arm64</span>/libWebRTC-arm64.a arm64/<span class="variable">$arm64</span>/<span class="variable">$arm64</span>/*.a</span><br><span class="line"><span class="comment"># 合并armv7/$armv7/$armv7/下所有*.a构建armv7为libWebRTC-armv7.a</span></span><br><span class="line">libtool -static -o armv7/<span class="variable">$armv7</span>/libWebRTC-armv7.a armv7/<span class="variable">$armv7</span>/<span class="variable">$armv7</span>/*.a</span><br><span class="line"><span class="comment"># 合并i386/$i386/$i386/下所有*.a构建i386为libWebRTC-i386.a</span></span><br><span class="line">libtool -static -o i386/<span class="variable">$i386</span>/libWebRTC-i386.a i386/<span class="variable">$i386</span>/<span class="variable">$i386</span>/*.a</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"成功构建libWebRTC-arm64.a、libWebRTC-armv7.a、libWebRTC-i386.a"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"正在执行最后的合成操作，请稍后..."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建支持arm64、armv7、i386的libWebRTC</span></span><br><span class="line">lipo -create arm64/<span class="variable">$arm64</span>/<span class="variable">$capture</span> armv7/<span class="variable">$armv7</span>/<span class="variable">$capture</span> i386/<span class="variable">$i386</span>/<span class="variable">$capture</span> -output libVideoCapture.a</span><br><span class="line">lipo -create arm64/<span class="variable">$arm64</span>/<span class="variable">$render</span> armv7/<span class="variable">$armv7</span>/<span class="variable">$render</span> i386/<span class="variable">$i386</span>/<span class="variable">$render</span> -output libVideoRender.a</span><br><span class="line">lipo -create arm64/<span class="variable">$arm64</span>/libWebRTC-arm64.a armv7/<span class="variable">$armv7</span>/libWebRTC-armv7.a i386/<span class="variable">$i386</span>/libWebRTC-i386.a -output libWebRTC.a</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"成功创建支持arm64、armv7、i386的libWebRTC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理中间垃圾文件(把子目录及子目录中所有档案删除,并且不用一一确认)</span></span><br><span class="line">rm -rf arm64/<span class="variable">$arm64</span></span><br><span class="line">rm -rf armv7/<span class="variable">$armv7</span></span><br><span class="line">rm -rf i386/<span class="variable">$i386</span></span><br></pre></td></tr></table></figure>
<h1 id="第二个版本"><a href="#第二个版本" class="headerlink" title="第二个版本"></a>第二个版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arm64包的名称</span></span><br><span class="line">arm64=Release-iphoneos</span><br><span class="line"><span class="comment"># armv7包的名称</span></span><br><span class="line">armv7=Release-iphoneos</span><br><span class="line"><span class="comment"># i386包的名称</span></span><br><span class="line">i386=Debug-iphonesimulator</span><br><span class="line"></span><br><span class="line">tempArm64Path=arm64/<span class="variable">$arm64</span></span><br><span class="line">tempArmv7Path=armv7/<span class="variable">$armv7</span></span><br><span class="line">tempI386Path=i386/<span class="variable">$i386</span></span><br><span class="line"><span class="comment"># 定义需要移动的两个静态库的别名</span></span><br><span class="line">capture=libvideo_capture_module_internal_impl.a</span><br><span class="line">render=libvideo_render_module_internal_impl.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩第一个参数下的zip文件到该目录下，不提示的情况覆盖文件</span></span><br><span class="line"><span class="function"><span class="title">funUnzip</span></span>()&#123;</span><br><span class="line">    unzip -o <span class="operator">-d</span> <span class="variable">$&#123;1&#125;</span> <span class="variable">$&#123;1&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"解压缩<span class="variable">$&#123;1&#125;</span>成功"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上面的两个静态库移到其上一个目录</span></span><br><span class="line"><span class="function"><span class="title">funMoveStatic</span></span>()&#123;</span><br><span class="line">    funUnzip <span class="variable">$&#123;1&#125;</span></span><br><span class="line"></span><br><span class="line">    mv <span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>/<span class="variable">$capture</span> <span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>/<span class="variable">$render</span> <span class="variable">$&#123;1&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"成功移动<span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>中两个特殊的静态库"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并arm64/$arm64/$arm64/下所有*.a构建arm64为libWebRTC-arm64.a这种情况</span></span><br><span class="line"><span class="function"><span class="title">funMergeStatic</span></span>()&#123;</span><br><span class="line">    funMoveStatic <span class="variable">$&#123;1&#125;</span> <span class="variable">$&#123;2&#125;</span></span><br><span class="line"></span><br><span class="line">    libtool -static -o <span class="variable">$&#123;1&#125;</span>/libWebRTC-<span class="variable">$&#123;3&#125;</span>.a <span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>/*.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"成功构建libWebRTC-<span class="variable">$&#123;3&#125;</span>.a"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">funBuildWebRTC</span></span>()&#123;</span><br><span class="line">    funMergeStatic <span class="variable">$&#123;tempArm64Path&#125;</span> <span class="variable">$&#123;arm64&#125;</span> <span class="string">"arm64"</span></span><br><span class="line">    funMergeStatic <span class="variable">$&#123;tempArmv7Path&#125;</span> <span class="variable">$&#123;armv7&#125;</span> <span class="string">"armv7"</span></span><br><span class="line">    funMergeStatic <span class="variable">$&#123;tempI386Path&#125;</span> <span class="variable">$&#123;i386&#125;</span> <span class="string">"i386"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"正在执行最后的合成操作，请稍后..."</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建支持arm64、armv7、i386的libWebRTC</span></span><br><span class="line">    lipo -create <span class="variable">$&#123;tempArm64Path&#125;</span>/<span class="variable">$capture</span> <span class="variable">$&#123;tempArmv7Path&#125;</span>/<span class="variable">$capture</span> <span class="variable">$&#123;tempI386Path&#125;</span>/<span class="variable">$capture</span> -output libVideoCapture.a</span><br><span class="line">    lipo -create <span class="variable">$&#123;tempArm64Path&#125;</span>/<span class="variable">$render</span> <span class="variable">$&#123;tempArmv7Path&#125;</span>/<span class="variable">$render</span> <span class="variable">$&#123;tempI386Path&#125;</span>/<span class="variable">$render</span> -output libVideoRender.a</span><br><span class="line">    lipo -create <span class="variable">$&#123;tempArm64Path&#125;</span>/libWebRTC-arm64.a <span class="variable">$&#123;tempArmv7Path&#125;</span>/libWebRTC-armv7.a <span class="variable">$&#123;tempI386Path&#125;</span>/libWebRTC-i386.a -output libWebRTC.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"成功创建支持arm64、armv7、i386的libWebRTC"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清理中间垃圾文件(把子目录及子目录中所有档案删除,并且不用一一确认)</span></span><br><span class="line">    rm -rf <span class="variable">$&#123;tempArm64Path&#125;</span></span><br><span class="line">    rm -rf <span class="variable">$&#123;tempArmv7Path&#125;</span></span><br><span class="line">    rm -rf <span class="variable">$&#123;tempI386Path&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">funBuildWebRTC</span><br></pre></td></tr></table></figure>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.lampweb.org/linux/1/" target="_blank" rel="external">shell 命令</a></p>
<p><a href="http://c.biancheng.net/cpp/shell/" target="_blank" rel="external">Linux Shell脚本教程：30分钟玩转Shell脚本编程</a></p>
<p><a href="http://segmentfault.com/a/1190000002924882#articleHeader16" target="_blank" rel="external">Shell常用招式大全之入门篇</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/开发利器/">开发利器</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/23/Shell编程实践/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/23/Shell编程实践/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/Runtime/" title="Runtime" itemprop="url">Runtime</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T03:12:52.000Z" itemprop="datePublished"> 发表于 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Objective-C是基于C语言加入了 <strong>面向对象特性</strong> 和 <strong>消息转发机制</strong> 的动态语言，这意味着它不仅需要一个编译器，还需要 <strong>Runtime系统</strong> 来动态创建类和对象，进行消息发送和转发。</p>
<p>Runtime即运行时，是系统在运行的时候的一些机制，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据 <strong>函数的名称</strong> 找到对应的函数来调用。</p>
<blockquote>
<p>事实证明，在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。而C语言在这种情况下，编译阶段就会报错。对于C语言，函数的调用在编译的时候就会决定调用哪个函数，编译完成之后直接顺序执行，无任何二议性。</p>
</blockquote>
<p><a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">RunTime源码</a>，它是一套比较底层的纯C语言API，属于一个C语言库，包含了很多底层的C语言API。平时编写的OC代码，在程序运行过程中，其实最终都是转成了Runtime的C语言代码，Runtime算是OC的幕后工作者。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>SEL其主要作用是快速的通过方法名字查找到对应方法的函数指针，然后调用其函数。SEL其本身是一个Int类型的一个地址，地址中存放着方法的名字。对于一个类中每一个方法对应着一个SEL,所以iOS类中不能存在2个名称相同的方法，即使参数类型不同，因为SEL是根据方法名字生成的，相同的方法名称只能对应一个SEL。</p>
<p>可以通过Objc编译器命令@selector()或者Runtime系统的sel_registerName函数来获取一个SEL类型的方法选择器。如果你知道selector对应的方法名是什么，可以通过NSString* NSStringFromSelector(SEL aSelector)方法将SEL转化为字符串，再用NSLog打印。</p>
<h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>id是通用类型指针，能够表示任何对象。id其实就是一个指向objc_object结构体指针，它包含一个Class isa成员，根据isa指针就可以顺藤摸瓜找到对象所属的类。</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> </span>&#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">详见官方文档</a>。</p>
</blockquote>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">  Class isa; <span class="comment">// 指向metaclass</span></span><br><span class="line">   </span><br><span class="line">  Class super_class ; <span class="comment">// 指向其父类</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">char</span> *name ; <span class="comment">// 类名</span></span><br><span class="line">  <span class="built_in">long</span> <span class="keyword">version</span> ; <span class="comment">// 类的版本信息，初始化默认为0，可以通过runtime函数class_setVersion和class_getVersion进行修改、读取</span></span><br><span class="line">  <span class="built_in">long</span> info; <span class="comment">// 一些标识信息,如CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含对象方法和成员变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;</span></span><br><span class="line">  <span class="built_in">long</span> instance_size ; <span class="comment">// 该类的实例变量大小(包括从父类继承下来的实例变量);</span></span><br><span class="line">  <span class="keyword">struct</span> objc_ivar_list *ivars; <span class="comment">// 用于存储每个成员变量的地址</span></span><br><span class="line">  <span class="keyword">struct</span> objc_method_list **methodLists ; <span class="comment">// 与 info 的一些标志位有关,如CLS_CLASS (0x1L),则存储对象方法，如CLS_META (0x2L)，则存储类方法;</span></span><br><span class="line">  <span class="keyword">struct</span> objc_cache *cache; <span class="comment">// 指向最近使用的方法的指针，用于提升效率；</span></span><br><span class="line">  <span class="keyword">struct</span> objc_protocol_list *protocols; <span class="comment">// 存储该类遵守的协议</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。</p>
<p>在objc_class结构体中：ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。也就是说可以动态修改*methodLists的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。关于二级指针，可以参考<a href="http://www.fenesky.com/blog/2014/07/03/pointers-to-pointers.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line">struct objc_method <span class="comment">&#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span>                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>Method表示类中的某个方法，是一个指向objc_method结构体指针，它存储了方法名(method_name)、方法类型(method_types)和方法实现(method_imp)等信息。</p>
<h2 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id <span class="list">(<span class="keyword">*IMP</span>)</span><span class="list">(<span class="keyword">id</span>, SEL, ...)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>IMP指向的方法与objc_msgSend函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的SEL对应的方法实现肯定是唯一的，通过一组id和SEL参数就能确定唯一的方法实现地址；反之亦然。它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。</p>
<h2 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an instance variable.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ivar表示类中的实例变量，是一个指向objc_ivar结构体指针，它包含了变量名(ivar_name)、变量类型(ivar_type)等信息。</p>
<p>##Property<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *Property;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *<span class="keyword">objc_property_t</span>;<span class="comment">//这个更常用</span></span><br></pre></td></tr></table></figure></p>
<p>Property代表类中的属性，它是一个指向objc_property结构体的指针。可以通过class_copyPropertyList 和 protocol_copyPropertyList方法来获取类和协议中的属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">objc_property_t</span> *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="keyword">objc_property_t</span> *protocol_copyPropertyList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br></pre></td></tr></table></figure>
<p>返回类型为指向指针的指针，因为属性列表是个数组，每个元素内容都是一个objc_property_t指针，而这两个函数返回的值是指向这个数组的指针。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache</span><br></pre></td></tr></table></figure>
<p>Cache为方法调用的性能进行优化，通俗地讲，每当实例对象接收到一个消息时，它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在Cache中查找。Runtime 系统会把被调用的方法存到Cache中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。这根计算机组成原理中学过的 CPU 绕过主存先访问Cache的道理挺像。</p>
<h1 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h1><p>Objc 中发送消息是用中括号（[]）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。下面详细叙述下消息发送步骤：</p>
<ol>
<li>检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。</li>
<li>检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>
<li>如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。</li>
<li>如果 cache 找不到就找Class中的方法列表。</li>
<li>如果Class中的方法列表找不到就到超类的Class中的方法列表去找，一直找，直到找到NSObject类为止。</li>
<li>如果还找不到就要开始进入动态方法解析了。</li>
</ol>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>Runtime是属于OC的底层，可以进行一下非常底层的操作：</p>
<ol>
<li>在程序运行过程中动态地创建一个类（比如KVO底层的实现）。</li>
<li>在程序运行过程中动态地为某个类添加属性、方法，修改属性值和方法。</li>
<li>遍历一个类的所有成员变量、属性、方法。如：字典转模型利用Runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值设置到模型的属性上。</li>
</ol>
<p>相关的头文件：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;objc/runtime.h&gt;</span></span><br><span class="line"><span class="tag">&lt;objc/message.h&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://chun.tips" target="_blank" rel="external">刨根问底Objective－C Runtime</a></p>
<p><a href="http://www.jianshu.com/p/25a319aee33d#" target="_blank" rel="external">Objective-C特性：Runtime</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/开发利器/">开发利器</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/Runtime/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/Runtime/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/IM/" title="IM">IM<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Objective-C/" title="Objective-C">Objective-C<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>16</sup></a></li>
		  
		
		  
			<li><a href="/categories/swift/" title="swift">swift<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开发利器/vim/" title="vim">vim<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/开发利器/" title="开发利器">开发利器<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS/" title="iOS">iOS<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/开发利器/" title="开发利器">开发利器<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/IM/" title="IM">IM<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/swift/" title="swift">swift<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/设计模式/" title="设计模式">设计模式<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Objective-C/" title="Objective-C">Objective-C<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/调试/" title="调试">调试<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webRTC/" title="webRTC">webRTC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/图像处理/" title="图像处理">图像处理<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/代码管理/" title="代码管理">代码管理<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ice/" title="ice">ice<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GCD/" title="GCD">GCD<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/数据存储/" title="数据存储">数据存储<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://casatwy.com" target="_blank" title="App架构相关文章">田伟宇</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="hexo相关学习">Jark&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://tool.lu/favicon" target="_blank" title="icon制作在线工具">Icon制作</a>
            
          </li>
        
          <li>
            
            	<a href="http://yulingtianxia.com" target="_blank" title="杨萧玉目前在支付宝实习，负责移动开发">玉令天下的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.callmewhy.com" target="_blank" title="汪海，全名汪海洋">Why’s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> “Hello ,I&#39;m ZhuLi in Chinasofti.” <br/>
			“This is my blog,believe it or not.”</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/zhuli8" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/zhuli8com" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="https://www.zhihu.com/people/zhu-li-68-76" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:zhuli1228@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="朱利">朱利</a>
		
		
		</p>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','TqhyGfTT5KJKMHcgZnBF','2.0.0');
</script>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"zhuli8"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_3725936'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D3725936' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
