
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>zhuli8’blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="朱利">
    

    
    <meta name="description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">
<meta property="og:type" content="website">
<meta property="og:title" content="zhuli8’blog">
<meta property="og:url" content="http://www.zhuli8.com/index.html">
<meta property="og:site_name" content="zhuli8’blog">
<meta property="og:description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhuli8’blog">
<meta name="twitter:description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">

    
    <link rel="alternative" href="/atom.xml" title="zhuli8’blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="zhuli8’blog" title="zhuli8’blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="zhuli8’blog">zhuli8’blog</a></h1>
				<h2 class="blog-motto">Talk is cheap, show me the code.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
    <input type="text" id="st-search-input" maxlength="20" placeholder="搜索" />
    </form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/09/大话-property/" title="大话@property" itemprop="url">大话@property</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-08-09T06:29:16.000Z" itemprop="datePublished"> 发表于 2015-08-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="@property">@property</h1><p>在普通的OC对象中，@property就是编译器自动帮我们生成一个私有的成员变量和getter、setter方法的声明及实现。为了研究编译器是如何实现@property的，我们需要使用clang。clang提供一个命令，可以将OC的源码改写成c++的，借此可以研究@property具体的源码实现方式。该命令是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">clang</span> <span class="tag">-rewrite-objc</span> <span class="tag">xxx</span><span class="class">.m</span></span><br></pre></td></tr></table></figure>
<p>除此之外我们还可以通过苹果开源的runtime进行研究，源码地址。<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">源码</a></p>
<h2 id="线程安全">线程安全</h2><h3 id="atomic、nonatomic">atomic、nonatomic</h3><p>atomic为原子性，会对set方法的实现进行加锁，多线程下可以一个线程写多个线程读，主要用在mac开发；nonatomic为非原子性，set方法的实现不加锁（比atomic性能高）。因为mac开发早于iOS开发，所以默认值为atomic。（A joke!）在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备nonatomic特质，则不使用同步锁。</p>
<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。因此，在iOS开发中，你会发现，几乎所有属性都声明为nonatomic；但是在开发Mac OS X程序时，使用 atomic属性通常都不会有性能瓶颈。</p>
<p>问题来了：</p>
<blockquote>
<p>@property (strong) NSMutableArray *array; 有什么问题？</p>
</blockquote>
<p>线程安全特性默认为atomic，该属性使用了同步锁，会在创建属性时生成一些额外的代码用于帮助写多线程程序，这会带来性能问题，通过显示声明nonatomic可以节省这些虽然很小但是不必要的额外开销。</p>
<h2 id="访问权限">访问权限</h2><h3 id="readonly、readwrite">readonly、readwrite</h3><p>readonly只生成get方法的声明和实现； readwrite同时生成get方法和set方法的声明和实现。</p>
<h2 id="内存管理">内存管理</h2><p>每个对象都有一个引用计数器，每个新对象的计数器默认是1，当对象的计数器减为0时就会被销毁；通过retain可以让对象的计数器加1、release可以让对象的计数器减1，还可以通过 <strong>autorelease pool</strong> 管理内存；只要调用了alloc、copy、new、retain方法产生的新对象，都必须在最后调用一次release或者autorelease；如果使用ARC，编译器会自动生成管理内存的代码。</p>
<h3 id="assign">assign</h3><p>set方法的实现是直接赋值，用于基本数据类型的简单赋值操作，用于非OC对象。</p>
<h3 id="weak(ARC)">weak(ARC)</h3><p>weak表明该属性定义了一种“非拥有关系（nonowning relationship）”，set方法的实现既不release旧也不retain新值，同assign类似，然而当对象销毁的时候，指针会被自动设置为nil，weak必须用于OC对象。</p>
<p>使用场合：</p>
<blockquote>
<p>*在ARC中，出现循环引用的时候，必须要有一端使用weak，比如：delegate。</p>
<p>*自身已经对它进行一次强引用，没有必要在强引用一次，此时也会使用weak，比如@IBOutlet。</p>
</blockquote>
<h3 id="copy">copy</h3><p>set方法的实现是release旧值，copy新值，用于NSString、block等类型。<br>栗子来了：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(nonatomic, <span class="keyword">copy</span>) NSString *<span class="property">name</span>;</span><br><span class="line">- (void)setName:(NSString *)<span class="property">name</span>&#123;	<span class="keyword">if</span> (_name != <span class="property">name</span>) &#123;		[_name release];		_name = [<span class="property">name</span> <span class="keyword">copy</span>];	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>字符串使用copy是为了外部把字符串内容改了不影响该属性；block使用copy是在MRC遗留下来的，在MRC中方法内部的block是在栈区的，使用copy可以把它放到堆区。在ARC中对于block使用copy还是strong效果是一样的。</p>
<h3 id="Copy扩展">Copy扩展</h3><h4 id="前提">前提</h4><p>实现NSCopying或NSMutableCoping。</p>
<h4 id="作用">作用</h4><ol>
<li>改变原对象不影响拷贝对象。</li>
<li>改变拷贝对象不影响源对象。</li>
</ol>
<h4 id="浅复制和深复制">浅复制和深复制</h4><p>Copy产生的是不可变副本，MutableCopy产生的是可变副本。</p>
<p>只要源对象是不可变类型且产生的对象也是不可变类型的时的情况是浅复制，其他情况都是深复制。浅复制是源对象和拷贝对象指向同一对象，深复制是产生了不同的对象。</p>
<h4 id="@property和copy">@property和copy</h4><p>在set方法中release旧值copy新值，用于NSString和block，可以保证属性不会被外部变量（例如NSMutableString类型变量）的改变所影响。</p>
<p>问题来了：</p>
<blockquote>
<p>@property (nonatomic，copy) NSMutableArray *array;这个写法会出什么问题？</p>
</blockquote>
<p>copy产生的是不可变副本，在set方法中release旧值copy新值，所以运行时类型为NSArray，编译时类型为NSMutableArray，所以对array执行添加、删除、修改数组内的元素的时候程序会因为找不到对应的方法而崩溃。</p>
<p>栗子来了：</p>
<blockquote>
<p>当一个使用 <strong> initWithArray:</strong> 初始化方法创建的NSMutable对象赋值给array属性，那么之后array执行可变数组的方法，比如：<strong>removeObjectAtIndex:</strong> 时会出现”-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x100206cd0”的崩溃。原因在于array属性在被赋值（setter）的时候默认执行了copy方法后变为了不可变NSArray对象。</p>
</blockquote>
<h4 id="自定义对象">自定义对象</h4><ol>
<li>遵守NSCopying或NSMutableCopying协议。其实也可以在代码中不写协议类的遵守，只实现里面的方法，协议只是用来方便生成快捷方法的。</li>
<li>实现copyWithZone或mutableCopyWithZone。即用self实例化对象（[[[self class] allocWithZone: zone]init];）、属性赋值、返回对象。</li>
</ol>
<h4 id="特别注意">特别注意</h4><p>编译时类型和运行时类型，应以运行时类型为准。</p>
<h3 id="strong(ARC)、retain(MRC)">strong(ARC)、retain(MRC)</h3><p>set方法的实现是release旧值，retain新值，用于OC对象类型。</p>
<p>栗子来了：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(nonatomic, <span class="keyword">copy</span>) NSString *<span class="property">name</span>;</span><br><span class="line">- (void)setName:(NSString *)<span class="property">name</span>&#123;	<span class="keyword">if</span> (_name != <span class="property">name</span>) &#123;		[_name release];		_name = [<span class="property">name</span> retain];	&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指定方法名称">指定方法名称</h2><p>setter=</p>
<p>getter=</p>
<h2 id="@synthesize和@dynamic">@synthesize和@dynamic</h2><p>@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是:</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">@synthesize</span> <span class="reserved">var</span>=_var;</span><br></pre></td></tr></table></figure>
<h3 id="@synthesize">@synthesize</h3><p>@synthesize的语义就是，如果没有指定成员变量的名称会自动生成一个属性同名的成员变量，如果这个成员变量已经存在了就不再生成。</p>
<p>如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</p>
<p>在@property被增强之后其实已经很少使用@synthesize</p>
<h3 id="@dynamic">@dynamic</h3><p>@dynamic告诉编译器，属性的setter方法和getter方法由我自己实现不用自动生成（对于readonly的属性只需提供getter方法即可），如果你木有提供setter方法和getter方法，编译时是没问题，但是当程序运行时调用会由于缺少setter方法或gettr方法导致程序崩溃。</p>
<p>编译时是靠Xcode把关，运行时靠runtiime机制来执行相应的方法，这就是所谓的动态绑定。</p>
<h1 id="参考链接">参考链接</h1><p><a href="http://www.jianshu.com/p/4fea8fa60d75" target="_blank" rel="external">iOS面试题</a></p>
<p><a href="http://www.90159.com/2015/07/26/71/" target="_blank" rel="external">iOS面试题集锦</a></p>
<p><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md" target="_blank" rel="external">《招聘一个靠谱的iOS》面试题参考答案（上）</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/09/大话-property/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/09/大话-property/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/01/iOS开发、Mac使用中这些你造吗/" title="iOS开发、Mac使用中这些你造吗" itemprop="url">iOS开发、Mac使用中这些你造吗</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-08-01T02:02:14.000Z" itemprop="datePublished"> 发表于 2015-08-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>子曰：工欲善其事，必先利其器。居是邦也。事其大夫之贤者，友其士之仁者。</p>
<p>有志者事竟成，破釜沉舟，百二秦关终属楚； 苦心人天不负，卧薪尝胆，三千越甲可吞吴。 </p>
<p>由此产生此文！</p>
<h1 id="Mac常用快捷键">Mac常用快捷键</h1><h2 id="窗口操作">窗口操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+Q：退出程序</span><br></pre></td></tr></table></figure>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">W</span>：关闭程序的窗口，并没有真正退出程序</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command（长按）+<span class="keyword">Tab</span>：切换程序窗口</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command（长按）+空格：切换输入法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+⬆️：管理多个桌面</span><br></pre></td></tr></table></figure>
<h2 id="文件操作">文件操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击一下文件、文件夹+空格：快速预览内容，无需双击打开。</span><br></pre></td></tr></table></figure>
<h1 id="Xcode常用快捷键">Xcode常用快捷键</h1><h2 id="Xcode导航快捷键">Xcode导航快捷键</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+1：工程导航器</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+0：显示、隐藏导航器面板</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">Option</span>+<span class="number">0</span>：显示、隐藏实用工具面板</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在项目导航器中选中文件，执行<span class="keyword">Option</span>+左键点击操作：在辅助编辑器中打开文件</span><br></pre></td></tr></table></figure>
<h2 id="Xcode搜索快捷键">Xcode搜索快捷键</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">Shift</span>+F：搜索导航器(<span class="built_in">Find</span> Navigator，也就是搜索)</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Control</span>+<span class="number">6</span>（键入方法/变量名+<span class="keyword">Enter</span>跳转）：文件跳转栏</span><br></pre></td></tr></table></figure>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + O：快速打开</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Control</span> + Command + ⬆️：程序中(Objective-<span class="keyword">C</span>或<span class="keyword">C</span>++编写).h and .m文件间的快速切换</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">L</span>：输入行号进行快速查找</span><br></pre></td></tr></table></figure>
<h2 id="应用程序编译和清理">应用程序编译和清理</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + R：运行app</span><br></pre></td></tr></table></figure>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + K：清除工程</span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + B：构建应用程序</span><br></pre></td></tr></table></figure>
<h2 id="调试相关">调试相关</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + . ：方便地暂停运行iOS模拟器</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">K</span>：删除调试面板里的信息，相当于<span class="keyword">Debug</span> Workflow-&gt;<span class="keyword">Clear</span> Console</span><br></pre></td></tr></table></figure>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Command+<span class="keyword">Y</span>：继续执行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F6：跳过方法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F7：跳入方法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F8：跳出方法</span><br></pre></td></tr></table></figure>
<h2 id="文档和帮助">文档和帮助</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + <span class="number">0</span> (Zero)：文档和参考</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在类或者方法名上执行<span class="keyword">Option</span> + 左键点击操作：快速帮助</span><br></pre></td></tr></table></figure>
<h2 id="其他快捷键">其他快捷键</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + J：可展示当前你在工程导航器中打开的文件</span><br></pre></td></tr></table></figure>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + <span class="number">1</span>：可打开<span class="string">"Show Related Items’弹出菜单</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Option</span> + Shift + 左键点击操作：该组合键可展示一个小尺寸的弹出视图，你可以查看你想要打开它的地方，比如辅助编辑器、标签或者窗口等。</span><br></pre></td></tr></table></figure>
<h1 id="VIM编辑器相关">VIM编辑器相关</h1><h2 id="VIM的运行模式">VIM的运行模式</h2><pre><code>编辑模式：等待编辑命令输入

插入模式：编辑模式下，输入 “<span class="built_in">i</span>” 进行插入模式，插入文本信息

命令模式：在编辑模式下，输入 “:” 进行命令模式
</code></pre><h2 id="VIM使用的命令">VIM使用的命令</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:q</span>：直接退出</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:wq</span>：保存后退出</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pseudo">:q</span>!：强制退出</span><br></pre></td></tr></table></figure>
<h1 id="常见Unix指令">常见Unix指令</h1><p>因为Mac系统是基于UNIX系统的，因此可以在“终端”中输入一些UNIX指令来操作Mac系统。比如：新建文件（夹）、打开文件（夹）等。</p>
<h2 id="文件目录操作指令">文件目录操作指令</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span>：列出当前目录下的所有内容（文件、文件夹）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-l：列出文件的详细信息</p>
<p>-a：列出当前目录所有文件，包括隐藏文件</p>
</blockquote>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>：新建一个目录</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p：父目录不存在的情况下先生成父目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>：改变当前操作的目录</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch：新建一个文件（文件不存在才会新建）</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>（tac）：显示文本文件内容</span><br></pre></td></tr></table></figure>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span>：复制文件或目录</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rm</span>：删除文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-r：同时（递归）删除该目录下的所有文件</p>
<p>-f：强制删除文件或目录</p>
</blockquote>
<pre><code>mv：移动文件或目录
</code></pre><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>：在文件系统中查找指定的文件</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>：显示当前目录的名称</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span>：打开一个文件（夹）</span><br></pre></td></tr></table></figure>
<p><strong>注：按一下Tab键可以自动补齐指令名称、文件名、文件夹名等。</strong></p>
<h2 id="Unix指令中的特殊路径">Unix指令中的特殊路径</h2><p>Mac系统采用的是UNIX文件系统，所有的文件都放在根目录下（即“\”）,因此没有Windows中的C盘、D盘的概念，文件路径就不再有盘符。例如：</p>
<pre><code>Windows中：<span class="string">c:</span><span class="comment">//Users/你的用户名/Desktop</span>

Mac中：<span class="regexp">/Users/</span>你的用户名/Desktop
</code></pre><p>在使用Unix指令过程中，经常会涉及到目录（路径）操作，下面列出几个有特殊含义的路径：</p>
<pre><code>/：根路径
./：当前路径
../：上一级路径
</code></pre><h2 id="系统管理命令">系统管理命令</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who（w）：显示在线登陆用户</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami：显示用户自己的身份</span><br></pre></td></tr></table></figure>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hostname</span>：显示主机名称</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname：显示系统信息</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>：显示当前系统中耗费资源最多的进程</span><br></pre></td></tr></table></figure>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ps</span>：显示瞬间的进程状态</span><br></pre></td></tr></table></figure>
<pre><code><span class="title">ifconfig</span> en0：显示网络接口信息
</code></pre><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clear</span>：清屏</span><br></pre></td></tr></table></figure>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">man</span>：命令帮助信息查询</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export</span><br><span class="line"></span><br><span class="line">设置或显示环境变量，但是只在本次登陆中有效。在shell中执行程序时，shell会提供一组环境变量，export可新增、修改或删除环境变量，供后续执行的程序使用，效力仅及于此登陆操作。export设置环境变量是暂时的，只在本次登陆中有效。=前的<span class="constant">PATH变</span>量不加<span class="variable">$符</span>号，再增加的路径用<span class="symbol">:</span>追加。</span><br><span class="line"></span><br><span class="line">export <span class="constant">PATH=</span><span class="variable">$PATH</span><span class="symbol">:/Library/Developer/IceTouch-</span><span class="number">1.3</span>/<span class="constant">SDKs/Objc/</span>bin</span><br></pre></td></tr></table></figure>
<h1 id="iphone的一些操作">iphone的一些操作</h1><p>双击Shift开启大写</p>
<p>摇一摇撤销</p>
<p>计算器输入的时候手指右划可以删除输入的数字</p>
<p>按住键盘上的小地球切换输入法</p>
<p>拍照可以按声音键</p>
<p>点击状态栏回到顶部</p>
<p>导航侧滑</p>
<h1 id="写在最后">写在最后</h1><p>iOS开发和Mac使用中你还有哪些能提高开发效率的小技巧和快捷键以及黑科技，在评论中一起分享吧。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/开发利器/">开发利器</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/开发利器/">开发利器</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/01/iOS开发、Mac使用中这些你造吗/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/01/iOS开发、Mac使用中这些你造吗/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/26/信令、stun、turn/" title="信令、stun、turn、ice" itemprop="url">信令、stun、turn、ice</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-07-26T09:48:27.000Z" itemprop="datePublished"> 发表于 2015-07-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>webRTC支持点对点通讯，但是webRTC仍然需要服务端：</p>
<ul>
<li>协调通讯过程中客户端之间需要交换元数据，如一个客户端找到另一个客户端以及通知另一个客户端开始通讯。</li>
<li>需要处理NAT（网络地址转换）或防火墙，这是公网上通讯首要处理的问题。</li>
</ul>
<p>所以我们需要了解服务端相关的知识：信令、Stun、trun、ice。</p>
<h1 id="什么是信令">什么是信令</h1><p>信令就是协调通讯的过程，为了建立一个webRTC的通讯过程，客户端需要交换如下信息：</p>
<ul>
<li>会话控制信息，用来开始和结束通话，即开始视频、结束视频这些操作指令。</li>
<li>处理错误的消息。</li>
<li>元数据，如各自的音视频解码方式、带宽。</li>
<li>网络数据，对方的公网IP、端口、内网IP及端口。</li>
</ul>
<p>信令处理过程需要客户端能够来回传递消息，这个过程在webRTC里面是没有实现的，需要自己创建。一旦信令服务建立好了,两个客户端之间建立了连接,理论上他们就可以进行点对点通讯了,这样可以减轻信令服务的压力和消息传递的延迟。</p>
<p>因为信令是我们自己定义的,所以安全性问题跟webrtc无关,需要自己处理。一旦黑客掌握了你的信令,那他就是控制会话的开始、结束、重定向等等。最重要的因素在信令安全中还是要靠使用安全协议,如HTTPS,WSS(如TLS),他们能确保未加密的消息不能被截取。为确保信令安全,强烈推荐使用TLS。</p>
<h1 id="TURN和STUN">TURN和STUN</h1><p>元数据是通过信令服务器中转发给另一个客户端,但是对于流媒体数据,一旦会话建立,首先尝试使用点对点连接。简单一点说就是:每个客户端都有一个唯一的地址,他能用来和其他客户端进行通讯和数据交换。现实生活中客户端都位于一个或多个NAT之后,或者一些杀毒软件还阻止了某些端口和协议,或者在公司还有防火墙或代理等等,防火墙和NAT或许是同一个设备,如我们家里用的路由器。</p>
<p>webrtc就是通过 ICE 这套框架来处理复杂的网络环境的,如果想启用这个功能,你必须让你的应用程序传 ICE 服务器的URL：ICE试着找最好的路径来让客户端建立连接,他会尝试所有可能的选项,然后选择最合适的方案,ICE首先尝试P2P连接,如果失败就会通过Turn服务器进行转接。换一个说法就是:</p>
<p><strong> STUN服务器是用来取外网地址的。</strong></p>
<p><strong> TURN服务器是在P2P失败时进行转发的 </strong></p>
<p>stun和turn服务的作用主要处理打洞与转发，配合完成ICE协议。首先尝试使用P2P，如果失败将求助于TCP，使用turn转发两个端点的音视频数据，turn转发的是两个端点之间的音视频数据不是信令数据。因为turn服务器是在公网上，所以他能被各个客户端找到，另外turn服务器转发的是数据流，很占用带宽和资源。</p>
<h1 id="ICE技术">ICE技术</h1><p>基于IP的语音、数据、视频等业务在NGN（Next Generation Network）网络中所面临的一个实际困难就是如何有效地穿透各种NAT（Network Address Translator）/FW(Fire Wall)的问题。对此，SIP（会话初始化协议）以往的解决方法由ALGs（(Application Layer Gateway Service)）、STUN、TURN等方式。现在有一种新的媒体会话信令穿透NAT/FW的解决方案-交互式连通建立方式ICE。它通过综合利用现有协议，以一种更有效的方式来组织会话建立过程，使之在不增加任何延迟同时比STUN等单一协议更具有健壮性、灵活性。</p>
<p>多媒体会话信令协议是在准备建立媒体流传输的代理之间交互信息的协议，例如SIP、RTSP（real time streaming protocol）等。媒体流与信令流截然不同，它们所采用的网络通道也不一致。由于协议自身设计上的原因，使得媒体流无法直接穿透网络地址转换/防火墙(NAT/FW)。因为它们生存期的目标只是为了建立一个在信息中携带IP地址的分组流，这在遇到NAT/FW 时会带来许多问题。而且这些协议的目标是通过建立P2P(Peer to Peer)媒体流以减小时延，而协议本身很多方面却与NAT存在兼容性问题，这也是穿透 NAT/FW的困难所在。</p>
<h2 id="ICE简介">ICE简介</h2><p>交互式连通建立方式ICE(Interactive Connectivity Establishment)并非一种新的协议，它不需要对STUN、TURN或RSIP进行扩展就可适用于各种NAT。ICE是通过综合运用上面某几种协议，使之在最适合的情况下工作，以弥补单独使用其中任何一种所带来的固有缺陷。对于SIP来说，ICE只需要定义一些SDP(Session Description Protocol)附加属性即可，对于别的多媒体信令协议也需要制定一些相应的机制来实现。</p>
<h2 id="多媒体信令">多媒体信令</h2><p>媒体流穿透NAT的过程是独立于某种具体的信令协议的。通信发生在两个客户端－会话发起者和会话响应者。初始化信息(Initiate Message)包含了描述会话发起者媒体流的配置与特征，并经过信令调停者(也叫信令中继)，最后到达会话响应者。假设会话响应者同意通信，接受信息(Accept Message)将产生并反馈至会话初始者，媒体流建立成功。此外，信令协议还对媒体流参数修改以及会话终止消息等提供支持。对于SIP，会话发起者即UAC(User Agent Client)，会话响应者即UAS(User Agent Server)，初始化消息对应SDP请求里面的INVITE，接受消息对应于SDP应答里面的200 OK，终止消息对应于BYE。</p>
<h2 id="流程">流程</h2><h3 id="收集传输地址">收集传输地址</h3><p>会话发起者需要收集的对象包括本地传输地址(Local Transport Address)和来源传输地址(Derived Transport Address)。本地传输地址通常由主机上一个物理(或虚拟)接口绑定一个端口而获得。会话发起者还将访问提供UNSAF(Unilateral self-address fixing)的服务器，例如STUN、TURN或TEREDO。对于每一个本地传输地址，会话者都可以从服务器上获得一组来源传输地址。显然，实现物理或虚拟连通方式越多，ICE将工作得越好。但为了建立对等通信，ICE通常要求至少有一个来源地址由位于公网上的中继服务器(如TURN)所提供的，而且需要知道具体是哪一个来源传输地址。</p>
<h3 id="启动STUN">启动STUN</h3><p>会话发起者获得一组传输地址后，将在本地传输地址启动STUN服务器，这意味着发送到来源地址的STUN服务将是可达的。与传统的STUN不同，客户端不需要在任何其它IP或端口上提供STUN服务，也不必支持TLS， ICE用户名和密码已经通过信令协议进行交换。客户端将在每个本地传输地址上同时接受STUN请求包和媒体包，所以发起者需要消除STUN消息与媒体流协议之间的歧义。在RTP和RTCP中实现这个并不难，因为RTP与RTCP包总是以0b10(v=2)打头，而STUN是0b00。对于每个运行STUN服务器的本地传输地址，客户端都必须选择相应的用户名和密码。用户名要求必须是全局唯一的，用户名和密码将被包含在初始化消息里传至响应者，由响应者对STUN请求进行鉴别。</p>
<h3 id="确定传输地址的优先级">确定传输地址的优先级</h3><p>STUN服务器启动后，下一步就是确定传输地址的优先级。优先级反映了UA在该地址上接收媒体流的优先级别，取值范围在0到1之间，通常优先级按照被传输媒体流量来确定。流量小者优先，而且对于相同流量者的Ipv6地址比Ipv4地址具有更高优先级。因此物理接口产生的本地Ipv6传输地址具有最高的优先级，然后是本地Ipv4传输地址，然后是STUN、RSIP、TEREDO来源地址，最后是通过VPN接口获得的本地传输地址。</p>
<h3 id="构建初始化信息(Initiate_Message)">构建初始化信息(Initiate Message)</h3><p>初始化消息由一系列媒体流组成，每个媒体流都有一个缺省地址和候选地址列表。缺省地址通常被Initiate消息映射到SIP信令消息传递地址上，而候选地址列表用于提供一些额外的地址。对于每个媒体流来说，任意Peer之间实现最大连通可能性的传输地址是由公网上转发服务器(如TURN)提供的地址，通常这也是优先级最低的传输地址。客户端将可用的传输地址编成一个候选地址列表(包括一个缺省地址)，并且为每个候选元素分配一个会话中唯一的标识符。该标识符以及上述的优先级都被编码在候选元素的id属性中。一旦初始化信息生成后即可被发送。</p>
<h3 id="响应处理：连通性检查和地址收集">响应处理：连通性检查和地址收集</h3><p>会话应答方接收到初始化信息Initiate Message后，会同时做几个事情：首先，执行 <em>收集传输地址</em> 中描述的地址收集过程。这些地址可以在呼叫到达前预收集，这样可以避免增加呼叫建立的时间。当获得来源地址以后，应答方会发送STUN Bind请求，该请求要求必须包含Username属性和Password属性，属性值为从 “alt”中得到的用户名和密码。STUN Bind请求还应包括一个Message-Integrity属性，它是由Initiate Message中候选元素的用户名和密码计算得来的。此外，STUN Bind请求不应有Change-Request或Response-Address属性。当一个客户端收到Initiate Message时，它将通过其中缺省地址和端口发送媒体流。如果STUN Bind请求消息引起错误应答，则需要检查错误代码。如果是401，430，432或500，说明客户端应该重新发送请求。如果错误代码是400，431和600，那么客户端不必重试，直接按超时处理即可。</p>
<h3 id="生成接受信息(Accept_Message)">生成接受信息(Accept Message)</h3><p>应答者可以决定是接受或拒绝该通信，若拒绝则ICE过程终止，若接受则发送Accept消息。Accept消息的构造过程与Initiate Message类似。</p>
<h3 id="接受信息处理">接受信息处理</h3><p>接受过程有两种可能。如果Initiate Message的接受者不支持ICE，则Accept Message将只包含缺省的地址信息，这样发起方就知道它不用执行连通性检查了。然而如果本地配置信息要求发起者通过TURN服务器发包来进行连通性检查，这将意味着那些直接发给响应者的包会被对方防火墙丢弃。为解决这个问题，发起者需要重新分配一个TURN来源地址，然后使用Send命令。一旦Send命令被接受，发起者将发送所有的媒体包到TURN服务器，由服务器转发至响应者。如果Accept Message包含候选项，则发起方处理Accept Message的过程就与响应方处理Initiate Message很相似了。</p>
<h3 id="附加ICE过程">附加ICE过程</h3><p>Initiate或Accept消息交换过程结束后，双方可能仍将继续收集传输地址，这通常是由于某些STUN事务过长而未结束引起，另一种可能是由于Initiate/Accept消息交换时提供了新的地址。</p>
<h3 id="ICE到SIP的映射">ICE到SIP的映射</h3><p>使用ICE方式穿透NAT，必须映射ICE定义的参数到SIP消息格式中，同时对其SDP属性进行简单扩展—在SDP的Media块中定义一个新的属性“alt”来支持ICE。它包含一个候选IP地址和端口，SDP的接受端可以用该地址来替换m和c中的地址。Media块中可能会有多个alt属性，这时每个alt应该包括不重复的IP地址和端口。</p>
<h1 id="写在最后">写在最后</h1><p>ICE方式的优势是显而易见的，它消除了现有的UNSAF机制的许多脆弱性。例如传统的STUN有几个脆弱点，其中一个就是发现过程需要客户端自己去判断所在NAT类型，这实际上不是一个可取的做法。而应用ICE之后，这个发现过程已经不需要了。另一点脆弱性在于STUN、TURN等机制都完全依赖于一个附加的服务器，而ICE利用服务器分配单边地址的同时，还允许客户端直接相连，因此即使STUN或TRUN服务器中有任何一个失败了，ICE方式仍可让呼叫过程继续下去。此外，传统的STUN最大的缺陷在于它不能保证在所有网络拓扑结构中都正常工作，最典型的问题就是Symmetric NAT。对于TURN或类似转发方式工作的协议来说，由于服务器的负担过重，很容易出现丢包或者延迟情况。而ICE方式正好提供了一种负载均衡的解决方案，它将转发服务作为优先级最低的服务，从而在最大程度上保证了服务的可靠性和灵活性。此外，ICE的优势还在于对Ipv6的支持，目前Cisco等公司正在设计基于ICE方式的NAT/FW解决方案。由于广泛的适应能力以及对未来网络的支持，ICE作为一种综合的解决方案将有着非常广阔的应用前景。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/IM/">IM</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/IM/">IM</a><a href="/tags/webRTC/">webRTC</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/07/26/信令、stun、turn/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/07/26/信令、stun、turn/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/19/构建支持armv7和arm64的webRTC静态库/" title="构建支持armv7和arm64的webRTC静态库" itemprop="url">构建支持armv7和arm64的webRTC静态库</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-07-19T04:13:57.000Z" itemprop="datePublished"> 发表于 2015-07-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="概述">概述</h1><p>arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。需要注意的是iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。</p>
<p><strong>目前为止Apple移动设备默认指令集</strong></p>
<hr>
<p>armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch</p>
<p>armv7 设备：iPhone3GS, iPhone4, iPhone4S, iPad, iPad2, iPad3(The New iPad), iPad mini,<br>iPod Touch 3G, iPod Touch4</p>
<p>armv7s设备： iPhone5, iPhone5C, iPad4(iPad with Retina Display)</p>
<p>arm64 设备： iPhone5S, iPad Air, iPad mini2(iPad mini with Retina Display)</p>
<hr>
<p>现在苹果默认要求支持armv7&amp;arm64，知道了这些信息我们进入下一话题！</p>
<h1 id="构建支持armv7和arm64的webRTC静态库">构建支持armv7和arm64的webRTC静态库</h1><p>总体思路就是将webRTC中的armv7静态库合并优化成一个单一的静态库，arm64中的所有静态库合并优化成一个单一的静态库，最后利用lipo指令合并这两个静态库为一个最终的静态库。</p>
<h2 id="armv7">armv7</h2><p>合并所有的*.a构建armv7为libWebRTC-armv7.a并优化静态库</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libtool -<span class="keyword">static</span> -o src<span class="regexp">/armv7/</span>Release-iphoneos<span class="regexp">/libWebRTC-temp.a src/</span>armv7<span class="regexp">/Release-iphoneos/</span>*.a</span><br><span class="line"></span><br><span class="line">strip -S -x -o src<span class="regexp">/armv7/</span>Release-iphoneos<span class="regexp">/libWebRTC-armv7.a -r src/</span>armv7<span class="regexp">/Release-iphoneos/</span>libWebRTC-temp.a</span><br></pre></td></tr></table></figure>
<h2 id="arm64">arm64</h2><p>合并所有的*.a构建arm64为libWebRTC-arm64.a</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libtool -<span class="keyword">static</span> -o src<span class="regexp">/arm64/</span>Release-iphoneos<span class="regexp">/libWebRTC-temp.a src/</span>arm64<span class="regexp">/Release-iphoneos/</span>*.a</span><br><span class="line"></span><br><span class="line">strip -S -x -o src<span class="regexp">/arm64/</span>Release-iphoneos<span class="regexp">/libWebRTC-arm64.a -r src/</span>arm64<span class="regexp">/Release-iphoneos/</span>libWebRTC-temp.a</span><br></pre></td></tr></table></figure>
<p><strong>2015年7月27日更新</strong></p>
<p><strong>之前的指令用在音频没有问题，但是用在视频只有声音没有图像。最后检查发现没有使用strip优化之前的包可以使用，而且不能包括iOS生成的静态库。
</strong></p>
<h2 id="创建支持armv7&amp;arm64的libWebRTC">创建支持armv7&amp;arm64的libWebRTC</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -<span class="built_in">create</span> src/armv7/Release-iphoneos/libWebRTC-armv7.<span class="operator">a</span> src/arm64/Release-iphoneos/libWebRTC-arm64.<span class="operator">a</span> -output libWebRTC.<span class="operator">a</span></span><br></pre></td></tr></table></figure>
<p><strong>lipo -info libWebRTC.a，可以查看支持的架构信息</strong></p>
<h1 id="其他">其他</h1><p>libtool和lipo的相关指令选项参数可用通过man帮助进行查看，里面写的还是比较详细的。</p>
<h2 id="XCode中与指令集相关的选项（Build_Settings_面板下_Architectures）：">XCode中与指令集相关的选项（Build Settings 面板下 Architectures）：</h2><p>1.Architectures：      </p>
<p>指明选定Target要求被编译生成的二进制包所支持的指令集是通过编译生成对应的二进制数据包实现的，如果支持的指令集数目有多个，就会编译出包含多个指令集代码的数据包，从而会造成最终编译生成的包很大。</p>
<p>2.Valid Architectures：</p>
<p>指明可能支持的指令集并非Architectures列表中指明的指令集都会被支持，Valid Architectures限制可能被支持的指令集的范围，即Valid Architectures和Architectures列表的交集，才是XCode最终生成二进制包所支持的指令集。比如，将Architectures支持arm指令集设置为：armv7,armv7s，对应的Valid Architectures的支持的指令集设置为：armv7s,arm64，那么此时，XCode生成二进制包所支持的指令集只有armv7s 。</p>
<p>3.Build Active Architecture Only:</p>
<p>指明是否只编译当前连接设备所支持的指令集,该选项起作用的条件有两个，必须同时满足才会起作用：</p>
<ul>
<li>其值设置为YES</li>
<li>XCode成功连接调试设备</li>
</ul>
<p>当Build Active Architecture Only起作用时,连接的手机指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。<br>建议：通常Debug模式设置值为Yes，Release模式设置为No。</p>
<h2 id="WebRTC-framework的依赖"><a href="http://www.it165.net/pro/html/201503/35541.html" target="_blank" rel="external">WebRTC.framework的依赖</a></h2><p>如果项目使用了该框架,那么编译的时候需要在项目的Build Phases中添加如下库和框架:</p>
<blockquote>
<ul>
<li>libstdc++.6.dylib</li>
<li>libsqlite3.dylib</li>
<li>libc++.dylib</li>
<li>libicucore.dylib</li>
<li>Security.framework</li>
<li>CFNetwork.framework</li>
<li>GLKit.framework</li>
<li>AudioToolbox.framework</li>
<li>AVFoundation.framework</li>
<li>CoreAudio.framework</li>
<li>CoreMedia.framework</li>
<li>CoreVideo.framework</li>
<li>CoreGraphics.framework</li>
<li>OpenGLES.framework</li>
<li>QuartzCore.framework</li>
</ul>
</blockquote>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/IM/">IM</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/IM/">IM</a><a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/07/19/构建支持armv7和arm64的webRTC静态库/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/07/19/构建支持armv7和arm64的webRTC静态库/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/12/The-Internet-Communications-Ice-简介/" title="The Internet Communications (ice)" itemprop="url">The Internet Communications (ice)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-07-12T09:26:50.000Z" itemprop="datePublished"> 发表于 2015-07-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="简介">简介</h1><p>The Internet Communications Engine (ice) is a modern object-oriented toolkit that enables you to build distributed applications with minimal effort. Ice allows you to focus your efforts on your application logic, and it takes care of all interactions with low-level network programming interfaces. With Ice, there is no need to worry about details such as opening network connections, serializing and deserializing data for network transmission, or retrying failed connection attempts (to name but a few of dozens of such low-level details).</p>
<h1 id="开发环境搭建">开发环境搭建</h1><p>ICE安装文件：<a href="https://zeroc.com/icetouch/download.html" target="_blank" rel="external">https://zeroc.com/icetouch/download.html</a><br>ICE编译插件：<a href="https://github.com/zeroc-ice/ice-builder-xcode" target="_blank" rel="external">https://github.com/zeroc-ice/ice-builder-xcode</a></p>
<h1 id="相关文档">相关文档</h1><p>ICE官网：<a href="http://www.zeroc.com/ice.html" target="_blank" rel="external">http://www.zeroc.com/ice.html</a><br>官网文档：<a href="http://doc.zeroc.com/display/Doc/Home" target="_blank" rel="external">http://doc.zeroc.com/display/Doc/Home</a><br>性能评测：<a href="http://zeroc.com/articles/IcePerformanceWhitePaper.pdf" target="_blank" rel="external">http://zeroc.com/articles/IcePerformanceWhitePaper.pdf</a></p>
<h1 id="ICE通讯框架基本原理">ICE通讯框架基本原理</h1><p>ICE的思路是，用一个中间语言，建立数据结构规范和接口规范，然后再用一个IDE编译插件，将中间语言数据结构规范和接口规范编译为当前的语言，譬如OC的.h/.m文件，接下来，你在客户端和服务端实现中间语言定义号的接口，再做一些其它处理，就可以实现一个分布式程序了。这个思路确实很Nice，值得我们借鉴。</p>
<h1 id="通讯方式选择">通讯方式选择</h1><p>P2P（设备直连）</p>
<p>通过服务器中转</p>
<h1 id="网络连接方式">网络连接方式</h1><p>基于TCP的长连接</p>
<p>基于HTTP短连接PULL的方式</p>
<h1 id="协议选择">协议选择</h1><p>XMPP</p>
<p>SIP</p>
<p>MQTT</p>
<p>私有协议（二进制协议）</p>
<h1 id="其他">其他</h1><p>p2p视频聊天的过程：音视频数据采集—&gt;编码—&gt;发送—&gt;接收—&gt;解码—&gt;播放</p>
<p><a href="http://www.cnblogs.com/HouZhiHouJueBlogs/p/3864677.html" target="_blank" rel="external">The Internet Communications Engine (Ice) 跨平台异构通讯方案 第一弹-ICE简介</a></p>
<p><a href="http://www.cnblogs.com/HouZhiHouJueBlogs/p/3864737.html" target="_blank" rel="external">The Internet Communications Engine (Ice) 跨平台异构通讯方案 第二弹-Hello world！</a></p>
<p><a href="http://www.cnblogs.com/lingyunhu/category/626157.html" target="_blank" rel="external">webrtc</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/IM/">IM</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/IM/">IM</a><a href="/tags/ice/">ice</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/07/12/The-Internet-Communications-Ice-简介/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/07/12/The-Internet-Communications-Ice-简介/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/05/Grand-Central-Dispatch-gcd/" title="Grand Central Dispatch (gcd)" itemprop="url">Grand Central Dispatch (gcd)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-07-05T06:50:07.000Z" itemprop="datePublished"> 发表于 2015-07-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="简介">简介</h1><h2 id="什么是GCD">什么是GCD</h2><ul>
<li>全程是Grand Central Dispatch，可译为“大中央调度”</li>
<li>纯C语言，提供了非常多强大的函数库</li>
</ul>
<h2 id="GCD的优势">GCD的优势</h2><ul>
<li>GCD是苹果公司为<strong>多核</strong>的<strong>并行</strong>运算提出的解决方案</li>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码<h1 id="任务和队列">任务和队列</h1></li>
<li>GCD中有两个核心概念</li>
</ul>
<ol>
<li><strong>任务</strong>：执行什么操作</li>
<li><strong>队列</strong>：用来存放任务</li>
</ol>
<ul>
<li>GCD的使用步骤</li>
</ul>
<ol>
<li><strong>定制任务</strong>：确定想做的事情</li>
<li><strong>将任务添加到队列中</strong>：GCD会自动将<em>队列</em>中的<em>任务</em>取出，放到对应的<em>线程</em>中执行；<em>任务</em>的取出遵循<em>队列</em>的FIFO原则：先进先出，后进后出<h2 id="执行任务">执行任务</h2>GCD中有2个用来执行任务的函数</li>
</ol>
<ul>
<li>用<strong>同步</strong>的方式执行任务<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>queue：队列<br>  block：任务</p>
</blockquote>
<ul>
<li><p>用<strong>异步</strong>的方式执行任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block); </span><br></pre></td></tr></table></figure>
</li>
<li><p>同步和异步的区别</p>
<blockquote>
<p>同步：只能在<strong>当前</strong>线程中执行任务，<strong>不具备</strong>开启新线程的能力<br>异步：可以在<strong>新的</strong>线程中执行任务，<strong>具备</strong>开启新线程的能力</p>
</blockquote>
</li>
</ul>
<h2 id="队列的类型">队列的类型</h2><p>GCD的队列可以分为2大类型</p>
<ul>
<li><p><strong>并发</strong>队列（Concurrent Dispatch Queue）</p>
<blockquote>
<p>可以让多个任务<strong>并发（同时）</strong>执行（自动开启多个线程同时执行任务）<br><strong>并发</strong>功能只有在<strong>异步（dispatch_async）</strong>函数下才有效</p>
</blockquote>
</li>
<li><p><strong>串行</strong>队列（Serial Dispatch Queue）</p>
<blockquote>
<p>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</p>
</blockquote>
</li>
<li>容易混淆的术语 <blockquote>
<p>有4个术语比较容易混淆：同步、异步、并发、串行<br><strong>同步和异步主要影响：能不能开启新的线程</strong><br>同步：在当前线程中执行任务，不具备开启新线程的能力<br>异步：在新的线程中执行任务，具备开启新线程的能力<br><strong>并发和串行主要影响：任务的执行方式</strong><br>并发：多个任务并发（同时）执行<br>串行：一个任务执行完毕后，再执行下一个任务</p>
</blockquote>
</li>
</ul>
<h3 id="并发队列">并发队列</h3><ul>
<li>GCD默认已经提供了全局的并发队列，供整个应用使用，不需要手动创建<br><strong>使用dispatch_get_global_queue函数获得全局的并发队列</strong><blockquote>
<p>dispatch_queue_t dispatch_get_global_queue(<br>dispatch_queue_priority_t priority, // 队列的优先级<br>unsigned long flags); // 此参数暂时无用，用0即可</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>); <span class="comment">// 获得全局并发队列</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>全局并发队列的优先级<br><code>#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高</code><br><code>#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中</code>）<br><code>#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低</code><br><code>#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台</code></p>
</blockquote>
<h3 id="串行队列 ">串行队列 </h3><ul>
<li>GCD中获得串行有2种途径</li>
</ul>
<p><strong>使用dispatch_queue_create函数创建串行队列</strong></p>
<blockquote>
<p>dispatch_queue_t<br>dispatch_queue_create(const char *label, // 队列名称<br>dispatch_queue_attr_t attr); // 队列属性，一般用NULL即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"cn.itcast.queue"</span>, NULL); <span class="comment">// 创建</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>使用主队列（跟主线程相关联的队列）</strong><br>主队列是GCD自带的一种特殊的串行队列<br>放在主队列中的任务，都会放到主线程中执行<br>使用dispatch_get_main_queue()获得主队列<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure></p>
<pre><code>凡是函数名种带有<span class="operator"><span class="keyword">create</span>\copy\new\retain等字眼, 都应该在不需要使用这个数据的时候进行<span class="keyword">release</span>
GCD的数据类型在ARC环境下不需要再做<span class="keyword">release</span>
CF(Core Foundation)的数据类型在ARC环境下还是需要再做<span class="keyword">release</span></span>
</code></pre><h3 id="各种队列的执行效果">各种队列的执行效果</h3><p><img src="http://www.zhuli8.com/photos/gcd.png" alt=""></p>
<blockquote>
<p><strong>注意</strong><br>使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列</p>
</blockquote>
<h1 id="线程间通信示例 ">线程间通信示例 </h1><h2 id="从子线程回到主线程">从子线程回到主线程</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行耗时的异步操作...</span><br><span class="line">      dispatch_async<span class="list">(<span class="keyword">dispatch_get_main_queue</span><span class="list">()</span>, ^&#123;</span><br><span class="line">        // 回到主线程，执行UI刷新操作</span><br><span class="line">        &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="延时执行">延时执行</h2><p>iOS常见的延时执行有2种方式</p>
<h3 id="调用NSObject的方法">调用NSObject的方法</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> <span class="symbol">performSelector:</span><span class="variable">@selector</span>(run) <span class="symbol">withObject:</span><span class="keyword">nil</span> <span class="symbol">afterDelay:</span><span class="number">2.0</span>];<span class="regexp">//</span> <span class="number">2</span>秒后再调用<span class="keyword">self</span>的run方法</span><br></pre></td></tr></table></figure>
<h3 id="使用GCD函数">使用GCD函数</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after<span class="params">(dispatch_time<span class="params">(DISPATCH_TIME_NOW, <span class="params">(int64_t)</span><span class="params">(<span class="number">2.0</span> * NSEC_PER_SEC)</span>)</span>, dispatch_get_main_queue<span class="params">()</span>, ^&#123;</span><br><span class="line">    // <span class="number">2</span>秒后异步执行这里的代码...</span><br><span class="line">&#125;)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="一次性代码">一次性代码</h2><p>使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="队列组">队列组</h2><p>有这么1种需求<br>首先：分别异步执行2个耗时的操作<br>其次：等2个异步操作都执行完毕后，再回到主线程执行操作<br>如果想要快速高效地实现上述需求，可以考虑用队列组<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group =  dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行<span class="number">1</span>个耗时的异步操作</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行<span class="number">1</span>个耗时的异步操作</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    // 等前面的异步操作都执行完毕后，回到主线程...</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="单例模式">单例模式</h2><h3 id="单例模式的作用">单例模式的作用</h3><p>可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问，从而方便地控制了实例个数，并节约系统资源</p>
<h3 id="单例模式的使用场合">单例模式的使用场合</h3><ul>
<li>在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次）</li>
<li>单例模式在ARC\MRC环境下的写法有所不同，需要编写2套不同的代码<br>可以用宏判断是否为ARC环境<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __has_feature(objc_arc)</span></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ARC单例模式的实现">ARC单例模式的实现</h4><ul>
<li><p>在.m中保留一个全局的static的实例</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写allocWithZone:方法，在这里创建唯一的实例（注意线程安全）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_instance) &#123;</span><br><span class="line">            _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供1个类方法让外界访问唯一的实例</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedSoundTool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_instance) &#123;</span><br><span class="line">            _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现copyWithZone:方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="MRC">MRC</h4><p>非ARC中（MRC），单例模式的实现（比ARC多了几个步骤）<br><em>实现内存管理方法</em></p>
<pre><code>-<span class="ruby"> (id)retain { <span class="keyword">return</span> <span class="keyword">self</span>; }
</span>-<span class="ruby"> (<span class="constant">NSUInteger</span>)retainCount { <span class="keyword">return</span> <span class="number">1</span>; }
</span>-<span class="ruby"> (oneway void)release {}
</span>-<span class="ruby"> (id)autorelease { <span class="keyword">return</span> <span class="keyword">self</span>; }</span>
</code></pre><h1 id="推荐阅读">推荐阅读</h1><p><a href="http://www.jianshu.com/p/50c060bab0ff" target="_blank" rel="external">Ethan Joe：Grand Central Dispatch 基础教程：Part 1/2</a><br><a href="[Ethan Joe：Grand Central Dispatch 基础教程：Part 1/2](http://www.jianshu.com/p/50c060bab0ff">cocoachina：Grand Central Dispatch 基础教程：Part 2/2</a>)<br><a href="http://www.devtang.com/blog/2012/02/22/use-gcd/" target="_blank" rel="external">唐巧：使用GCD</a><br><a href="http://www.cocoachina.com/ios/20140428/8248.html" target="_blank" rel="external">GCD 深入理解（一）</a><br><a href="http://www.cocoachina.com/ios/20140515/8433.html" target="_blank" rel="external">GCD 深入理解（二）</a></p>
<h1 id="NSOperation&amp;NSOperationQueue">NSOperation&amp;NSOperationQueue</h1><p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<p><a href="http://blog.xcodev.com/archives/operation-queue-intro/" target="_blank" rel="external">并发编程之Operation Queue</a></p>
<p><a href="http://www.jianshu.com/p/0b0d9b1f1f19#" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/GCD/">GCD</a><a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/07/05/Grand-Central-Dispatch-gcd/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/07/05/Grand-Central-Dispatch-gcd/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/28/swift学习参考/" title="swift学习参考" itemprop="url">swift学习参考</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-06-28T04:41:20.000Z" itemprop="datePublished"> 发表于 2015-06-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="官方文档">官方文档</h1><p><a href="https://developer.apple.com/swift/" target="_blank" rel="external">苹果出品，必属精品！</a></p>
<p><a href="https://github.com/zhuli8com/Welcome-to-Swift" target="_blank" rel="external">Welcome-to-Swift</a>（中文版）</p>
<p><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/" target="_blank" rel="external">The Swift Programming Language</a></p>
<p><a href="http://www.cocoachina.com/ios/20150701/12328.html" target="_blank" rel="external">没机会参加 WWDC 2015，那你可以看看这10个视频</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="external">swift 2.0</a>(中文版)</p>
<h1 id="精彩博文">精彩博文</h1><p><a href="http://southpeak.github.io/blog/2015/06/30/ioszhi-shi-xiao-ji-di-san-qi-2015-dot-06-dot-30/" target="_blank" rel="external">Tint Color\Build Configurations in Swift\键盘事件</a></p>
<p><a href="http://www.cocoachina.com/swift/20150630/12305.html" target="_blank" rel="external">怎样在Swift中使用CocoaPods</a></p>
<p><a href="http://www.cocoachina.com/swift/20150806/12831.html" target="_blank" rel="external">怎样在swift中创建一个CocoaPods</a></p>
<p><a href="http://www.cocoachina.com/ios/20150629/12298.html" target="_blank" rel="external">使用Xcode HeaderDoc和Doxygen文档化你的Objective-C和Swift代码</a></p>
<p><a href="http://00red.com" target="_blank" rel="external">Swift项目兼容Objective-c问题汇总</a></p>
<p><a href="http://benbeng.leanote.com/post/On-Demand-Resources-Guide" target="_blank" rel="external">按需加载资源开发指南</a></p>
<p><a href="http://www.cocoachina.com/ios/20150617/12165.html" target="_blank" rel="external">10步成为专业iOS开发者——从零起步</a></p>
<p><a href="http://www.cocoachina.com/swift/" target="_blank" rel="external">cocoachina-swift集锦</a></p>
<p><a href="http://www.cocoachina.com/special/xcode/" target="_blank" rel="external">cocoachina-xcode集锦</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/swift/">swift</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/swift/">swift</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/28/swift学习参考/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/28/swift学习参考/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/21/代理模式-Proxy程序替你聊天/" title="swift版设计模式之代理模式-Proxy程序替你聊天" itemprop="url">swift版设计模式之代理模式-Proxy程序替你聊天</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-06-21T09:05:10.000Z" itemprop="datePublished"> 发表于 2015-06-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="代理模式比喻">代理模式比喻</h1><p>跟MM在网上聊天，她们一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>
<h1 id="代理模式意图">代理模式意图</h1><p>代理模式(Proxy)为其他对象提供一种代理以控制对这个对象的访问。</p>
<h1 id="代理模式类图">代理模式类图</h1><p><img src="http://www.zhuli8.com/photos/designpattern/proxy.gif" alt=""></p>
<h1 id="代理模式实现">代理模式实现</h1><p>定义RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Proxy所代表的真实实体</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span>: <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> mm:<span class="type">Girl</span></span><br><span class="line">    <span class="keyword">init</span>(mm:<span class="type">Girl</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.mm=mm</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">operation</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> mm.word!&#123;<span class="comment">//记得强制解包哦</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"hi,你好"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"hi,你好"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"你从哪里来呀？"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"火星"</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"你多大了？"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="number">18</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"身高多少呀？"</span>:</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"2.5m"</span>)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            say()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"我出场了……"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存一个RealSubject引用，使得代理可以访问实体并提供一个与Subject相同的接口来代替实体</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>: <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rs:<span class="type">RealSubject</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(mm:<span class="type">Girl</span>)&#123;</span><br><span class="line">        rs=<span class="type">RealSubject</span>(mm: mm)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">operation</span><span class="params">()</span></span> &#123;</span><br><span class="line">        rs.operation()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>聊天的MM</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> word:<span class="built_in">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理模式客户端应用</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> mm=<span class="function"><span class="title">Girl</span><span class="params">()</span></span></span><br><span class="line">mm.word=<span class="string">"hi,你好"</span></span><br><span class="line"></span><br><span class="line"><span class="tag">var</span> proxy=<span class="function"><span class="title">Proxy</span><span class="params">(mm: mm)</span></span></span><br><span class="line">proxy.<span class="function"><span class="title">operation</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<h1 id="代理模式总结">代理模式总结</h1><p>吼吼，这是不是就是传说中的机器人聊天原理啊！代理模式给某一个对象提供一个代理对象，由代理对象控制对源对象的引用。代理就是一个人或一个结构代表另一个人或者一个机构采取行动。我们身边到处都是代理模式，如远程代理、虚拟代理、安全代理、智能指引等。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/swift/">swift</a><a href="/tags/设计模式/">设计模式</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/21/代理模式-Proxy程序替你聊天/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/21/代理模式-Proxy程序替你聊天/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/14/中介者模式-MM们打麻将我来算账/" title="swift版设计模式之中介者模式-MM们打麻将我来算账" itemprop="url">swift版设计模式之中介者模式-MM们打麻将我来算账</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-06-14T04:05:10.000Z" itemprop="datePublished"> 发表于 2015-06-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="中介者模式比喻">中介者模式比喻</h1><p>四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。</p>
<h1 id="中介者模式意图">中介者模式意图</h1><p>中介者模式(Mediator)用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<h1 id="中介者模式类图">中介者模式类图</h1><p><img src="http://www.zhuli8.com/photos/designpattern/mediator.gif" alt=""></p>
<h1 id="中介者模式实现">中介者模式实现</h1><p>抽象中介者，定义了MM需要什么样的中介者</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(money:Double,girl:Girl)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体中介者对象，实现抽象类的方法，他需要知道所有具体的MM，并给MM核算服务</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span>: <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl1:<span class="type">FirstGirl</span>?</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl2:<span class="type">SecondGirl</span>?</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl3:<span class="type">ThirdGirl</span>?</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> girl4:<span class="type">FourthGirl</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">calculate</span><span class="params">(<span class="keyword">var</span> money: Double, girl: Girl)</span></span> &#123;</span><br><span class="line">        money=money*<span class="number">10</span><span class="comment">////中介者的处理，此处业务比较简单假设一个筹码代表10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> girl===girl1&#123;</span><br><span class="line">            girl1?.getResult(money)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> girl===girl2&#123;</span><br><span class="line">            girl2?.getResult(money)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> girl===girl3&#123;</span><br><span class="line">            girl3?.getResult(money)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> girl===girl4&#123;</span><br><span class="line">            girl4?.getResult(money)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象女孩类</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mediator:<span class="type">Mediator</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(mediator:<span class="type">Mediator</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.mediator=mediator<span class="comment">////得到中介者对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    告诉中介者筹码数，让其帮我核算</span><br><span class="line">    */</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        mediator.calculate(money, girl: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩1，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识且依靠中介者对象核算</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The FirstGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩2，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识依靠中介者对象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The SecondGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩3，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识依靠中介者对象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The ThirdGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>女孩4，每个女孩只知道自己的行为，而不了解其他MM的情况，但它们都认识依靠中介者对象</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FourthGirl</span>: <span class="title">Girl</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getResult</span><span class="params">(money:Double)</span></span>&#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"The FourthGirl have:<span class="subst">\(money)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中介者模式客户端应用</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> boy=<span class="function"><span class="title">Boy</span><span class="params">()</span></span><span class="comment">//核算中介</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//四个打麻将的MM</span></span><br><span class="line"><span class="tag">var</span> girl1=<span class="function"><span class="title">FirstGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"><span class="tag">var</span> girl2=<span class="function"><span class="title">SecondGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"><span class="tag">var</span> girl3=<span class="function"><span class="title">ThirdGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"><span class="tag">var</span> girl4=<span class="function"><span class="title">FourthGirl</span><span class="params">(mediator: boy)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//四个MM让我调节</span></span><br><span class="line">boy.girl1=girl1</span><br><span class="line">boy.girl2=girl2</span><br><span class="line">boy.girl3=girl3</span><br><span class="line">boy.girl4=girl4</span><br><span class="line">girl1.<span class="function"><span class="title">notify</span><span class="params">(<span class="number">10</span>)</span></span></span><br><span class="line">girl2.<span class="function"><span class="title">notify</span><span class="params">(<span class="number">20</span>)</span></span></span><br><span class="line">girl3.<span class="function"><span class="title">notify</span><span class="params">(-<span class="number">20</span>)</span></span></span><br><span class="line">girl4.<span class="function"><span class="title">notify</span><span class="params">(-<span class="number">10</span>)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="中介者模式总结">中介者模式总结</h1><p>中介者的出现减少了MM们的耦合，使得可以独立地改变和复用各个Mediator和Girl，具体女孩类的改变不会影响到其他女孩类，而只是Boy发生变化。Boy把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，关注的对象就从对象各自本身的行为转移到她们之间的交互上来。即中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而是它们可以松散耦合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象，保证这些作用可以彼此独立的变化。中介者模式将多对多的相互作用转化为一对多的相互作用。中介者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/swift/">swift</a><a href="/tags/设计模式/">设计模式</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/14/中介者模式-MM们打麻将我来算账/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/14/中介者模式-MM们打麻将我来算账/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/07/OBJC和DYNAMIC/" title="@OBJC和DYNAMIC" itemprop="url">@OBJC和DYNAMIC</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-06-07T02:44:45.000Z" itemprop="datePublished"> 发表于 2015-06-07</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p><div class="post-content clearfix"><br>        <p>虽然说 Swift 语言的初衷是希望能摆脱 Objective-C 的沉重的历史包袱和约束，但是不可否认的是经过了二十多年的洗礼，Cocoa 框架早就烙上了不可磨灭的 Objective-C 的印记。无数的第三方库是用 Objective-C 写成的，这些积累无论是谁都不能小觑。因此，在最初的版本中，Swift 不得不考虑与 Objective-C 的兼容。</p></div></p>
<p>Apple 采取的做法是允许我们在同一个项目中同时使用 Swift 和 Objective-C 来进行开发。其实一个项目中的 Objective-C 文件和 Swift 文件是处于两个不同世界中的，为了让它们能相互联通，我们需要添加一些桥梁。</p><br><p>首先通过添加 <code>{product-module-name}-Bridging-Header.h</code> 文件，并在其中填写想要使用的头文件名称，我们就可以很容易地在 Swift 中使用 Objective-C 代码了。Xcode 为了简化这个设定，甚至在 Swift 项目中第一次导入 Objective-C 文件时会主动弹框进行询问是否要自动创建这个文件，可以说是非常方便。</p><br><p>但是如果想要在 Objective-C 中使用 Swift 的类型的时候，事情就复杂一些。如果是来自外部的框架，那么这个框架与 Objective-C 项目肯定不是处在同一个 target 中的，我们需要对外部的 Swift module 进行导入。这个其实和使用 Objective-C 的原来的 Framework 是一样的，对于一个项目来说，外界框架是由 Swift 写的还是 Objective-C 写的，两者并没有太大区别。我们通过使用 2013 年新引入的 <code>@import</code> 来引入 module：</p><br><pre><code>@import MySwiftKit;<br></code></pre><br><p>之后就可以正常使用这个 Swift 写的框架了。</p><br><p>如果想要在 Objective-C 里使用的是同一个项目中的 Swift 的源文件的话，可以直接导入自动生成的头文件 <code>{product-module-name}-Swift.h</code> 来完成。比如项目的 target 叫做 <code>MyApp</code> 的话，我们就需要在 Objective-C 文件中写</p><br><pre><code>#import “MyApp-Swift.h”<br></code></pre><br><p>但这只是故事的开始。Objective-C 和 Swift 在底层使用的是两套完全不同的机制，Cocoa 中的 Objective-C 对象是基于运行时的，它从骨子里遵循了 KVC (Key-Value Coding，通过类似字典的方式存储对象信息) 以及动态派发 (Dynamic Dispatch，在运行调用时再决定实际调用的具体实现)。而 Swift 为了追求性能，如果没有特殊需要的话，是不会在运行时再来决定这些的。也就是说，Swift 类型的成员或者方法在编译时就已经决定，而运行时便不再需要经过一次查找，而可以直接使用。</p><br><p>显而易见，这带来的问题是如果我们要使用 Objective-C 的代码或者特性来调用纯 Swift 的类型时候，我们会因为找不到所需要的这些运行时信息，而导致失败。解决起来也很简单，在 Swift 类型文件中，我们可以将需要暴露给 Objective-C 使用的任何地方 (包括类，属性和方法等) 的声明前面加上 <code>@objc</code> 修饰符。注意这个步骤只需要对那些不是继承自 <code>NSObject</code> 的类型进行，如果你用 Swift 写的 class 是继承自 <code>NSObject</code> 的话，Swift 会默认自动为所有的非 private 的类和成员加上 <code>@objc</code>。这就是说，对一个 <code>NSObject</code> 的子类，你只需要导入相应的头文件就可以在 Objective-C 里使用这个类了。</p><br><p><code>@objc</code> 修饰符的另一个作用是为 Objective-C 侧重新声明方法或者变量的名字。虽然绝大部分时候自动转换的方法名已经足够好用 (比如会将 Swift 中类似 <code>init(name: String)</code> 的方法转换成 <code>-initWithName:(NSString *)name</code> 这样)，但是有时候我们还是期望 Objective-C 里使用和 Swift 中不一样的方法名或者类的名字，比如 Swift 里这样的一个类：</p><br><pre><code>class 我的类 {<br>    func 打招呼(名字: String) {<br>        println(“哈喽，(名字)”)<br>    }<br>}<br>我的类().打招呼(“小明”)<br></code></pre><br><p>Objective-C 的话是无法使用中文来进行调用的，因此我们<strong>必须</strong>使用 <code>@objc</code> 将其转为 ASCII 才能在 Objective-C 里访问：</p>

<p><pre><code>@objc(MyClass)<br>class 我的类 {<br>    @objc(greeting:)<br>    func 打招呼(名字: String) {<br>        println(“哈喽，(名字)”)<br>    }<br>}<br></code></pre></p>
<p></p><p>这样，我们在 Objective-C 里就能调用 <code>[[MyClass new] greeting:@”XiaoMing”]</code> 这样的代码了 (虽然比起原来一点都不好玩了)。另外，正如上面所说的以及在 <a href="http://swifter.tips/selector/" target="_blank" rel="external">Selector</a> 一节中所提到的，即使是 <code>NSObject</code> 的子类，Swift 也不会在被标记为 <code>private</code> 的方法或成员上自动加 <code>@objc</code>。如果我们需要使用这些内容的动态特性的话，我们需要手动给它们加上 <code>@objc</code> 修饰。</p><p></p>
<p></p><p>添加 <code>@objc</code> 修饰符并不意味着这个方法或者属性会变成动态派发，Swift 依然可能会将其优化为静态调用。如果你需要和 Objective-C 里动态调用时相同的运行时特性的话，你需要使用的修饰符是 <code>dynamic</code>。一般情况下在做 app 开发时应该用不上，但是在施展一些像动态替换方法或者运行时再决定实现这样的 “黑魔法” 的时候，我们就需要用到 <code>dynamic</code> 修饰符了。在之后的 KVO 一节中，我们还会提到一个关于使用 <code>dynamic</code> 的实例。</p><br>    <br>作者王巍 <a href="http://swifter.tips/" target="_blank" rel="external">(@onevcat)</a> 原文地址 <a href="http://swifter.tips/objc-dynamic/" target="_blank" rel="external">http://swifter.tips/objc-dynamic/</a><p></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/swift/">swift</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/swift/">swift</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/06/07/OBJC和DYNAMIC/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/06/07/OBJC和DYNAMIC/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/IM/" title="IM">IM<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/swift/" title="swift">swift<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开发利器/" title="开发利器">开发利器<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS/" title="iOS">iOS<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/IM/" title="IM">IM<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/swift/" title="swift">swift<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/开发利器/" title="开发利器">开发利器<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/设计模式/" title="设计模式">设计模式<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/调试/" title="调试">调试<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webRTC/" title="webRTC">webRTC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/数据存储/" title="数据存储">数据存储<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/代码管理/" title="代码管理">代码管理<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ice/" title="ice">ice<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GCD/" title="GCD">GCD<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/图像处理/" title="图像处理">图像处理<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://casatwy.com" target="_blank" title="App架构相关文章">田伟宇</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="hexo相关学习">Jark&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://tool.lu/favicon" target="_blank" title="icon制作在线工具">Icon制作</a>
            
          </li>
        
          <li>
            
            	<a href="http://yulingtianxia.com" target="_blank" title="杨萧玉目前在支付宝实习，负责移动开发">玉令天下的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.callmewhy.com" target="_blank" title="汪海，全名汪海洋">Why’s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> “Hello ,I&#39;m ZhuLi in Chinasofti.” <br/>
			“This is my blog,believe it or not.”</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/zhuli8" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/zhuli8com" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="https://www.zhihu.com/people/zhu-li-68-76" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:zhuli1228@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="朱利">朱利</a>
		
		
		</p>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','TqhyGfTT5KJKMHcgZnBF','2.0.0');
</script>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"zhuli8"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_3725936'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D3725936' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
