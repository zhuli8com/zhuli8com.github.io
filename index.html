
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>zhuli8’blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="朱利">
    

    
    <meta name="description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">
<meta property="og:type" content="website">
<meta property="og:title" content="zhuli8’blog">
<meta property="og:url" content="http://www.zhuli8.com/index.html">
<meta property="og:site_name" content="zhuli8’blog">
<meta property="og:description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhuli8’blog">
<meta name="twitter:description" content="朱利,iOS,架构设计,zhuli,zhuli8,zhuli8com">

    
    <link rel="alternative" href="/atom.xml" title="zhuli8’blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="zhuli8’blog" title="zhuli8’blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="zhuli8’blog">zhuli8’blog</a></h1>
				<h2 class="blog-motto">Talk is cheap, show me the code.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
    <input type="text" id="st-search-input" maxlength="20" placeholder="搜索" />
    </form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/25/项目中用到的工具和技术/" title="项目中用到的工具和技术" itemprop="url">项目中用到的工具和技术</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-10-25T07:58:16.000Z" itemprop="datePublished"> 发表于 2015-10-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>总结一下项目中用到的工具和技术，以便以后的查看。</p>
<h1 id="图标">图标</h1><p><a href="http://devhelpers.com/app/icon/resizer/" target="_blank" rel="external">在线通过1024 * 1024图片生成iPhone 1倍、2倍、3倍图片</a></p>
<h1 id="CocoaPods">CocoaPods</h1><p><a href="http://blog.csdn.net/wzzvictory/article/details/18737437" target="_blank" rel="external">CocoaPods详解之——使用篇</a></p>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/19178709" target="_blank" rel="external">CocoaPods详解之——进阶篇</a></p>
<p><a href="http://blog.csdn.net/wzzvictory/article/details/20067595" target="_blank" rel="external">CocoaPods详解之——制作篇</a></p>
<p><a href="http://www.cocoachina.com/swift/20150630/12305.html" target="_blank" rel="external">怎样在Swift中使用CocoaPods</a></p>
<p><a href="http://www.cocoachina.com/swift/20150806/12831.html" target="_blank" rel="external">怎样在swift中创建一个CocoaPods</a></p>
<p><a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/" target="_blank" rel="external">使用Cocoapods创建私有podspec</a></p>
<h1 id="线程方案">线程方案</h1><p>在iOS开发中其实有4套多线程方案，他们分别是：</p>
<p><strong> pthreads </strong></p>
<blockquote>
<p>POSIX线程（POSIX threads），简称pthreads，是线程的POSIX标准。该标准定义了创建和操作线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中都使用pthreads作为操作系统的线程。</p>
</blockquote>
<p><strong> NSThread </strong></p>
<p><strong> GCD</strong></p>
<p><strong> NSOperation&amp;NSOperationQueue </strong></p>
<p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<p><a href="http://blog.xcodev.com/archives/operation-queue-intro/" target="_blank" rel="external">并发编程之Operation Queue</a></p>
<p><a href="http://www.jianshu.com/p/0b0d9b1f1f19#" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></p>
<h1 id="RunLoop">RunLoop</h1><p><a href="http://www.jianshu.com/p/b35793b3749d" target="_blank" rel="external">RunLoop的简单介绍</a></p>
<h1 id="iOS8适配">iOS8适配</h1><p><a href="http://www.jianshu.com/p/86f933850df8" target="_blank" rel="external">在iOS 8中使用UIAlertController</a></p>
<p><a href="http://www.cocoachina.com/industry/20140729/9269.html" target="_blank" rel="external">WWDC 2014 Session笔记 - iOS界面开发的大一统</a></p>
<p><a href="http://www.jianshu.com/p/f1208b5e42d9" target="_blank" rel="external">Alamofire网络库基础教程</a></p>
<h1 id="iOS9适配">iOS9适配</h1><p><a href="http://www.liuchungui.com/blog/2015/10/11/ios9zhi-gua-pei-ats/" target="_blank" rel="external">iOS9之适配ATS</a></p>
<p><a href="http://www.cocoachina.com/ios/20150821/13140.html" target="_blank" rel="external">如何使用ATS提高应用的安全性</a></p>
<p><a href="http://www.cocoachina.com/ios/20150717/12650.html" target="_blank" rel="external">苹果新『应用通信安全』的理解和使用</a></p>
<p><a href="http://www.cocoachina.com/ios/20150820/13118.html" target="_blank" rel="external">UIStackView如何让你的开发更简单</a></p>
<p><a href="http://www.cnblogs.com/dsxniubility/p/4821184.html" target="_blank" rel="external">整理iOS9适配中出现的坑（图文）</a></p>
<h1 id="iOS性能调优">iOS性能调优</h1><h2 id="Analyze静态分析">Analyze静态分析</h2><p>逻辑错误、声明错误、api调用错误基本在编译时都会有警告，Analyze的主要的优势在于静态分析内存泄露及代码逻辑错误。</p>
<ol>
<li>逻辑错误：访问空指针或未初始化的变量等。</li>
<li>内存管理错误：如内存泄露等。</li>
<li>声明错误：从未使用过的变量。</li>
<li>api调用错误：未包含使用的库和框架。</li>
</ol>
<h2 id="Leaks内存泄露">Leaks内存泄露</h2><p>把Snapshot Interval 间隔时间设置为10秒，勾选Automatic Snapshotting，Leaks会自动进行内存捕捉分析。在你怀疑有内存泄露的操作前和操作后点击Snapshot Now进行手动捕捉。</p>
<p>Leaked Object的表格中显示了内存泄露的类型、数量及内存空间。</p>
<p>点击具体的某个内存泄露对象，在右侧Detail窗口中会出现导致泄露可能的位置，其中黑色部分代表了最可能的位置。双击即可进入代码。</p>
<p><strong>开启了ARC并不是就不会存在内存问题，苹果有句名言：ARC is only for NSObject。</strong></p>
<h2 id="Allocation内存使用">Allocation内存使用</h2><ol>
<li>在进入一个视图前或操作前，我们在Allocation面板左侧点击Mark Generation，这时候会产生Generation A节点，显示内存当前的情况。</li>
<li>在进入视图后再点一次Mark Generation。</li>
<li>在视图退出后再点一次Mark</li>
</ol>
<p>这样三次产生的 Generation分别记录了进入前、进入后、关闭后，在最后一个Generation应该内存被合理释放，否则就代表了在这个视图或操作中有泄漏或不合理的地方。</p>
<h2 id="Zombies僵尸对象（EXC_BAD_ACCESS）">Zombies僵尸对象（EXC_BAD_ACCESS）</h2><p>用于查找那些被过度释放的僵尸对象（overreleased objects）。</p>
<ol>
<li>启动Instruments，选择Zombies。</li>
<li>对之前产生EXC_BAD_ACCESS的测试用例重新运行，直到程序崩溃，如果发生EXC_BAD_ACCESS错误，会出现对应界面。</li>
<li>通过滑动箭头来查看错误细节，例如可以看到该对象的内存操作过程，如malloc、autorelease、retain、release等操作。</li>
<li>查看底部的详细历史，选择相应的行可以定位到相应的代码，找出产生错误的代码</li>
</ol>
<h2 id="参考文章">参考文章</h2><p><a href="http://yyny.me/ios/一次TableView性能优化经历/" target="_blank" rel="external">一次TableView性能优化经历</a></p>
<p><a href="http://www.cnblogs.com/ym123/category/668845.html" target="_blank" rel="external">iOS性能调优系列</a></p>
<h1 id="自动化部署">自动化部署</h1><p>deliver用于上传应用的二进制代码、应用截屏和原数据到应用商店</p>
<p>snapshot可以自动化iOS应用在每个设备上的本地化截屏过程</p>
<p>frameit用于在应用截屏外添加设备框架</p>
<p>PEM可以自动化地生成和更新应用推送通知描述文件</p>
<p>sigh可以生成并下载开发者的应用商店配置文件</p>
<p><a href="http://www.infoq.com/cn/news/2015/01/fastlane-ios-continuous-deploy" target="_blank" rel="external">Fastlane为iOS带来持续部署</a></p>
<p><a href="http://www.jianshu.com/users/384f80cdc57b/latest_articles" target="_blank" rel="external">马建成系列</a></p>
<h1 id="stackoverflow">stackoverflow</h1><p>stackoverflow在中国被墙了，不能登陆进行答题和收藏，所以在此记录工作中有所帮助的问题！根据链家基本上就能看出大概的问题了，以此来纪念那些被解决的问题！</p>
<p><a href="http://stackoverflow.com/questions/26865132/strings-in-switch-statements-string-does-not-conform-to-protocol-intervaltyp#" target="_blank" rel="external">http://stackoverflow.com/questions/26865132/strings-in-switch-statements-string-does-not-conform-to-protocol-intervaltyp#</a></p>
<p><a href="http://stackoverflow.com/questions/25951195/swift-print-vs-println-vs-nslog#" target="_blank" rel="external">http://stackoverflow.com/questions/25951195/swift-print-vs-println-vs-nslog#</a></p>
<p><a href="http://stackoverflow.com/questions/28427458/ios-webrtc-library-supporting-both-armv7-arm64" target="_blank" rel="external">http://stackoverflow.com/questions/28427458/ios-webrtc-library-supporting-both-armv7-arm64</a></p>
<h1 id="其他">其他</h1><p><a href="http://www.jianshu.com/p/802f52c5f13a" target="_blank" rel="external">如何利用搜索框</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_4caf02490102vr4s.html" target="_blank" rel="external">Xcode各版本官方下载及百度云盘下载, Mac和IOS及Xcode版本历史.</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/10/25/项目中用到的工具和技术/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/10/25/项目中用到的工具和技术/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/30/设计模式总结/" title="设计模式总结" itemprop="url">设计模式总结</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-08-30T06:08:47.000Z" itemprop="datePublished"> 发表于 2015-08-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>开始前请先看<a href="https://github.com/zhuli8com/DesignPattern.git" target="_blank" rel="external">源码Demo</a>。</p>
<h1 id="概述">概述</h1><p>在软件设计领域，设计模式是对通用问题的可复用的解决方案。设计模式是一系列帮你写出更可理解和复用代码的模板，设计模式帮你创建松耦合的代码以便你不需要费多大力就可以改变或者替换代码中的组件。</p>
<p>创建型：单利（单态）和 抽象工厂</p>
<p>结构型：模型-视图-控制器、装饰器、适配器、外观（门面)和组合模式</p>
<p>行为型：观察者、备忘录、责任链和命令模式</p>
<h1 id="MVC（模型-视图-控制器）">MVC（模型-视图-控制器）</h1><p>模型-视图-控制器（MVC) 是Cocoa的构建块之一，毫无疑问它是使用最频繁的设计模式。它根据通用的角色去划分类，这样就使得类的职责可以根据角色清晰的划分开来。</p>
<blockquote>
<p>Model:模型保存应用程序的数据，定义了怎么去操作它。例如在本应用中模型就是Album类。</p>
<p>View:  视图是模型的可视化表示以及用户交互的控件；基本上来说，所有的UIView对象以及它的子类都属于视图。在本应用中AlbumView代表了视图。</p>
<p>Controller:控制器是一个协调所有工作的中介者（Mediator）。它访问模型中的数据并在视图中展示它们，同时它们还监听事件和根据需要操作数据。例如在本应用中ViewController。</p>
</blockquote>
<p>模型会把任何数据的变更通知控制器，然后控制器更新视图数据。视图对象通知控制器用户的操作，控制器要么根据需要来更新模型，要么检索任何被请求的数据。</p>
<p>你可能在想为什么不能仅仅使用控制器，在一个类中实现视图和模型，这样貌似更加容易? </p>
<p>所有的这些都归结于代码关注点分离以及复用。在理想的状态下，视图应该和模型完全的分离。如果视图不依赖某个实际的模型，那么视图就可以被复用来展示不同模型的数据。</p>
<p>举个例子来说，如果将来你打算加入电影或者书籍到你的资料库中，你仍然可以使用同样的AlbumView去显示电影和书籍数据。更进一步来说，如果你想创建一个新的与专辑有关联的工程，你可以很简单的复用Album类，因为它不依赖任何视图。这就是MVC的强大之处。</p>
<h1 id="单例模式">单例模式</h1><p>单例设计模式确保对于一个给定的类只有一个实例存在，这个实例有一个全局唯一的访问点。它通常采用懒加载的方式在第一次用到实例的时候再去创建它。</p>
<p>苹果大量使用了此模式。例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[NSUserDefaults standardUserDefaults]</span><br><span class="line">[UIApplication sharedApplication]</span><br><span class="line">[UIScreen mainScreen]</span><br><span class="line">[NSFileManager defaultManager]</span><br></pre></td></tr></table></figure>
<p>有一些情况下，只有一个实例显得非常合理。举例来说，你不需要有多个Logger的实例，除非你想去写多个日志文件。或者一个全局的配置处理类：实现线程安全的方式访问共享实例是容易的，比如一个配置文件，有好多个类同时修改这个文件。</p>
<h1 id="外观模式">外观模式</h1><p>外观模式针对复杂的子系统提供了单一的接口，不需要暴漏一系列的类和API给用户，你仅仅暴漏一个简单统一的API。这个API的使用者完全不需要关心背后的复杂性。这个模式非常适合有一大堆很难使用或者理解的类的情况。外观模式解耦了使用系统的代码和需要隐藏的接口和实现类。它也降低了外部代码对内部子系统的依赖性。当隐藏在外观之后的类很容易发生变化的时候，此模式就很有用了，因为当背后的类发生变化的时候，外观类始终保持了同样的API。</p>
<p>本应用中用PersistencyManager本地保存专辑数据，使用HTTPClient处理远程连接，工程中的其它类暂时与本次实现的逻辑无关。</p>
<p>为了实现这个模式，只有LibraryAPI应该保存PersistencyManager和HTTPClient的实例，然后LibraryAPI将暴漏一个简单的API去访问这些服务。LibraryAPI将暴漏给其它代码，但是它隐藏了HTTPClient和PersistencyManager的复杂性。</p>
<h1 id="装饰器（Decorator）模式">装饰器（Decorator）模式</h1><p>装饰器模式在不修改原来代码的情况下动态的给对象增加新的行为和职责，它通过一个对象包装被装饰对象的方法来修改类的行为，这种方法可以做为子类化的一种替代方法。<br>在Objective-C中，存在两种非常常见的实现:Category(类别）和Delegation（委托）。</p>
<h2 id="Category(类别)">Category(类别)</h2><p>Category(类别)是一种不需要子类化就可以让你能动态的给已经存在的类增加方法的强有力的机制。新增的方法是在编译期增加的，这些方法执行的时候和被扩展的类的其它方法是一样的。它可能与装饰器设计模式的定义稍微有点不同，因为Category(类别)不会保存被扩展类的引用。</p>
<p>除了可以扩展你自己的类以外，还可以给Cocoa自己的类增加方法。</p>
<p>本应用中需要让Album(专辑)对象显示在一个表格视图（TableView）中：专辑的标题从何而来？因为专辑是模型对象，它本身不需要关心你如何显示它的数据。你需要增加一些代码去扩展专辑类的行为，但是不需要直接修改专辑类。创建一个专辑类扩展的类别，定义一个新的方法，这个方法会返回能很容易和UITableViews使用的数据结构。 </p>
<h2 id="Delegation(委托)">Delegation(委托)</h2><p>当你使用UITableView的时候，你必须要实现tableView:numberOfRowsInSection:方法。<br>你不可能让UITableView知道它需要在每个区域显示多少行，因为这些是应用特定的数据。因此计算每个区域需要显示多少行的职责就给了UITableView的委托。这就让UITableView类独立于它要显示的数据。</p>
<p>UITableView的职责就是显示一个表格视图。然而最终它需要一些它自身没有的信息。那么它就求助于它的委托，通过发送消息给委托来获取信息。在Objective-C实现委托模式的时候，一个类可以通过协议（Protocol）来声明可选以及必要的方法。</p>
<p>这个是一个重要的模式。苹果在UIKit类中大量使用了它：UITableView, UITextView, UITextField, UIWebView, UIAlert, UIActionSheet, UICollectionView, UIPickerView,UIGestureRecognizer, UIScrollView等等等。</p>
<h1 id="适配器（Adapter）模式">适配器（Adapter）模式</h1><p>适配器可以让一些接口不兼容的类一起工作。它包装一个对象然后暴漏一个标准的交互接口。</p>
<p>苹果通过一个稍微不同的方式来实现它-苹果使用了协议的方式来实现。你可能已经熟悉UITableViewDelegate, UIScrollViewDelegate, NSCoding 和 NSCopying协议。举个例子，使用NSCopying协议，任何类都可以提供一个标准的copy方法。</p>
<h1 id="观察者（Observer）模式">观察者（Observer）模式</h1><p>在观察者模式中，一个对象任何状态的变更都会通知另外的对改变感兴趣的对象。这些对象之间不需要知道彼此的存在，这其实是一种松耦合的设计。当某个属性变化的时候，我们通常使用这个模式去通知其它对象。</p>
<p>此模式的通用实现中，观察者注册自己感兴趣的其它对象的状态变更事件。当状态发生变化的时候，所有的观察者都会得到通知。苹果的推送通知（Push Notification）就是一个此模式的例子。</p>
<p>如果你要遵从MVC模式的概念，你需要让模型对象和视图对象在不相互直接引用的情况下通信。这正是观察者模式的用武之地。</p>
<p>Cocoa通过通知（Notifications）和Key-Value Observing(KVO)来实现观察者模式。</p>
<h2 id="通知（Notifications）">通知（Notifications）</h2><p>不要和远程推送以及本地通知所混淆，通知是一种基于订阅-发布模式的模型，它让发布者可以给订阅者发送消息，并且发布者不需要对订阅者有任何的了解。</p>
<p>通知在苹果官方被大量的使用。举例来说，当键盘弹出或者隐藏的时候，系统会独立发送UIKeyboardWillShowNotification/UIKeyboardWillHideNotification通知。当你的应用进入后台运行的时候，系统会发送一个UIApplicationDidEnterBackgroundNotification通知。</p>
<h2 id="Key-Value_Observing(KVO)模式">Key-Value Observing(KVO)模式</h2><p>在KVO中，一个对象可以要求在它自身或者其它对象的属性发送变化的时候得到通知。</p>
<p>KVO机制让对象可以感知到属性的变化。在本例中，你可以使用KVO去观察UIImageView的image属性的变化。</p>
<h1 id="备忘录（Memento）模式">备忘录（Memento）模式</h1><p>备忘录模式快照对象的内部状态并将其保存到外部。换句话说，它将状态保存到某处，过会你可以不破坏封装的情况下恢复对象的状态，也就是说原来对象中的私有数据仍然是私有的。</p>
<h2 id="归档（Archiving）">归档（Archiving）</h2><p>归档是苹果对于备忘录模式的特定实现之一。这种机制可以转换一个对象到一个可保存的数据流中，过会可以在不暴漏私有属性给外部的情况下重建它们。</p>
<h1 id="命令模式">命令模式</h1><p>命令模式将一个请求封装为一个对象。封装以后的请求会比原生的请求更加灵活，因为这些封装后的请求可以在多个对象之间传递，存储以便以后使用，还可以动态的修改，或者放进一个队列中。苹果通过Target-Action机制和Invocation实现命令模式。</p>
<p>你可以通过苹果的官方在线文档阅读更多关于Target-Action的内容，至于Invocation，它采用了NSInvocation类，这个类包含了一个目标对象，方法选择器，以及一些参数。这个对象可以动态的修改并且可以按需执行。实践中它是一个命令模式很好的例子。它解耦了发送对象和接受对象，并且可以保存一个或者多个请求。</p>
<h1 id="参考文章">参考文章</h1><p><a href="http://xmuzyq.iteye.com/blog/1942376" target="_blank" rel="external">IOS设计模式之一（MVC模式，单例模式）</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/设计模式/">设计模式</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/30/设计模式总结/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/30/设计模式总结/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/23/Shell编程实践/" title="Shell编程实践" itemprop="url">Shell编程实践</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-08-23T08:15:35.000Z" itemprop="datePublished"> 发表于 2015-08-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="概述">概述</h1><p>简单的说Shell就是一个包含若干行Shell或者Linux命令的文件。对于一次编写，多次使用的大量命令，就可以使用单独的文件保存下来，以便日后使用。</p>
<p>通常Shell脚本以.sh为后缀。如果要执行该脚本，必须先使其可执行</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chmod</span> +<span class="keyword">x</span> filename</span><br></pre></td></tr></table></figure>
<p>此后在该脚本所在目录下，输入./filename即可执行该脚本。</p>
<p>还有一种更简单的方法就是直接在终端用 <strong>sh</strong> 指令来执行。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sh</span> filename</span><br></pre></td></tr></table></figure>
<p>最近打包webRTC库时重复的工作和容易出错的机会让我想到了Shell脚本。基本需求就是把C++工程师那边的arm64、armv7、i386三个架构的zip包（webRTC静态库包的压缩文件）打成一个.a静态库。</p>
<p>下面就是这个过程中解决的两个版本。</p>
<h1 id="第一个版本">第一个版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/usr/sh</span></span><br><span class="line"><span class="comment"># arm64包的名称</span></span><br><span class="line">arm64=Release-iphoneos</span><br><span class="line"><span class="comment"># armv7包的名称</span></span><br><span class="line">armv7=Release-iphoneos</span><br><span class="line"><span class="comment"># i386包的名称</span></span><br><span class="line">i386=Debug-iphonesimulator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩该目录下的$arm64.zip文件到该目录下的$arm64文件夹下,不提示的情况下覆盖文件</span></span><br><span class="line">unzip -o <span class="operator">-d</span> arm64/<span class="variable">$arm64</span>  arm64/<span class="variable">$arm64</span></span><br><span class="line"><span class="comment"># 解压缩该目录下的$armv7.zip文件到该目录下的$armv7文件夹下,不提示的情况下覆盖文件</span></span><br><span class="line">unzip -o <span class="operator">-d</span> armv7/<span class="variable">$armv7</span>  armv7/<span class="variable">$armv7</span></span><br><span class="line"><span class="comment"># 解压缩该目录下的$i386.zip文件到该目录下的$i386文件夹下,不提示的情况下覆盖文件</span></span><br><span class="line">unzip -o <span class="operator">-d</span> i386/<span class="variable">$i386</span>  i386/<span class="variable">$i386</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"解压缩成功"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上面的两个静态库移到其上一个目录</span></span><br><span class="line">mv arm64/<span class="variable">$arm64</span>/<span class="variable">$arm64</span>/<span class="variable">$capture</span> arm64/<span class="variable">$arm64</span>/<span class="variable">$arm64</span>/<span class="variable">$render</span> arm64/<span class="variable">$arm64</span>/</span><br><span class="line">mv armv7/<span class="variable">$armv7</span>/<span class="variable">$armv7</span>/<span class="variable">$capture</span> armv7/<span class="variable">$armv7</span>/<span class="variable">$armv7</span>/<span class="variable">$render</span> armv7/<span class="variable">$armv7</span>/</span><br><span class="line">mv i386/<span class="variable">$i386</span>/<span class="variable">$i386</span>/<span class="variable">$capture</span> i386/<span class="variable">$i386</span>/<span class="variable">$i386</span>/<span class="variable">$render</span> i386/<span class="variable">$i386</span>/</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"成功移动两个特殊的静态库"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并arm64/$arm64/$arm64/下所有*.a构建arm64为libWebRTC-arm64.a</span></span><br><span class="line">libtool -static -o arm64/<span class="variable">$arm64</span>/libWebRTC-arm64.a arm64/<span class="variable">$arm64</span>/<span class="variable">$arm64</span>/*.a</span><br><span class="line"><span class="comment"># 合并armv7/$armv7/$armv7/下所有*.a构建armv7为libWebRTC-armv7.a</span></span><br><span class="line">libtool -static -o armv7/<span class="variable">$armv7</span>/libWebRTC-armv7.a armv7/<span class="variable">$armv7</span>/<span class="variable">$armv7</span>/*.a</span><br><span class="line"><span class="comment"># 合并i386/$i386/$i386/下所有*.a构建i386为libWebRTC-i386.a</span></span><br><span class="line">libtool -static -o i386/<span class="variable">$i386</span>/libWebRTC-i386.a i386/<span class="variable">$i386</span>/<span class="variable">$i386</span>/*.a</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"成功构建libWebRTC-arm64.a、libWebRTC-armv7.a、libWebRTC-i386.a"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"正在执行最后的合成操作，请稍后..."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建支持arm64、armv7、i386的libWebRTC</span></span><br><span class="line">lipo -create arm64/<span class="variable">$arm64</span>/<span class="variable">$capture</span> armv7/<span class="variable">$armv7</span>/<span class="variable">$capture</span> i386/<span class="variable">$i386</span>/<span class="variable">$capture</span> -output libVideoCapture.a</span><br><span class="line">lipo -create arm64/<span class="variable">$arm64</span>/<span class="variable">$render</span> armv7/<span class="variable">$armv7</span>/<span class="variable">$render</span> i386/<span class="variable">$i386</span>/<span class="variable">$render</span> -output libVideoRender.a</span><br><span class="line">lipo -create arm64/<span class="variable">$arm64</span>/libWebRTC-arm64.a armv7/<span class="variable">$armv7</span>/libWebRTC-armv7.a i386/<span class="variable">$i386</span>/libWebRTC-i386.a -output libWebRTC.a</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"成功创建支持arm64、armv7、i386的libWebRTC"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理中间垃圾文件(把子目录及子目录中所有档案删除,并且不用一一确认)</span></span><br><span class="line">rm -rf arm64/<span class="variable">$arm64</span></span><br><span class="line">rm -rf armv7/<span class="variable">$armv7</span></span><br><span class="line">rm -rf i386/<span class="variable">$i386</span></span><br></pre></td></tr></table></figure>
<h1 id="第二个版本">第二个版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arm64包的名称</span></span><br><span class="line">arm64=Release-iphoneos</span><br><span class="line"><span class="comment"># armv7包的名称</span></span><br><span class="line">armv7=Release-iphoneos</span><br><span class="line"><span class="comment"># i386包的名称</span></span><br><span class="line">i386=Debug-iphonesimulator</span><br><span class="line"></span><br><span class="line">tempArm64Path=arm64/<span class="variable">$arm64</span></span><br><span class="line">tempArmv7Path=armv7/<span class="variable">$armv7</span></span><br><span class="line">tempI386Path=i386/<span class="variable">$i386</span></span><br><span class="line"><span class="comment"># 定义需要移动的两个静态库的别名</span></span><br><span class="line">capture=libvideo_capture_module_internal_impl.a</span><br><span class="line">render=libvideo_render_module_internal_impl.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩第一个参数下的zip文件到该目录下，不提示的情况覆盖文件</span></span><br><span class="line"><span class="function"><span class="title">funUnzip</span></span>()&#123;</span><br><span class="line">    unzip -o <span class="operator">-d</span> <span class="variable">$&#123;1&#125;</span> <span class="variable">$&#123;1&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"解压缩<span class="variable">$&#123;1&#125;</span>成功"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上面的两个静态库移到其上一个目录</span></span><br><span class="line"><span class="function"><span class="title">funMoveStatic</span></span>()&#123;</span><br><span class="line">    funUnzip <span class="variable">$&#123;1&#125;</span></span><br><span class="line"></span><br><span class="line">    mv <span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>/<span class="variable">$capture</span> <span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>/<span class="variable">$render</span> <span class="variable">$&#123;1&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"成功移动<span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>中两个特殊的静态库"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并arm64/$arm64/$arm64/下所有*.a构建arm64为libWebRTC-arm64.a这种情况</span></span><br><span class="line"><span class="function"><span class="title">funMergeStatic</span></span>()&#123;</span><br><span class="line">    funMoveStatic <span class="variable">$&#123;1&#125;</span> <span class="variable">$&#123;2&#125;</span></span><br><span class="line"></span><br><span class="line">    libtool -static -o <span class="variable">$&#123;1&#125;</span>/libWebRTC-<span class="variable">$&#123;3&#125;</span>.a <span class="variable">$&#123;1&#125;</span>/<span class="variable">$&#123;2&#125;</span>/*.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"成功构建libWebRTC-<span class="variable">$&#123;3&#125;</span>.a"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">funBuildWebRTC</span></span>()&#123;</span><br><span class="line">    funMergeStatic <span class="variable">$&#123;tempArm64Path&#125;</span> <span class="variable">$&#123;arm64&#125;</span> <span class="string">"arm64"</span></span><br><span class="line">    funMergeStatic <span class="variable">$&#123;tempArmv7Path&#125;</span> <span class="variable">$&#123;armv7&#125;</span> <span class="string">"armv7"</span></span><br><span class="line">    funMergeStatic <span class="variable">$&#123;tempI386Path&#125;</span> <span class="variable">$&#123;i386&#125;</span> <span class="string">"i386"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"正在执行最后的合成操作，请稍后..."</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建支持arm64、armv7、i386的libWebRTC</span></span><br><span class="line">    lipo -create <span class="variable">$&#123;tempArm64Path&#125;</span>/<span class="variable">$capture</span> <span class="variable">$&#123;tempArmv7Path&#125;</span>/<span class="variable">$capture</span> <span class="variable">$&#123;tempI386Path&#125;</span>/<span class="variable">$capture</span> -output libVideoCapture.a</span><br><span class="line">    lipo -create <span class="variable">$&#123;tempArm64Path&#125;</span>/<span class="variable">$render</span> <span class="variable">$&#123;tempArmv7Path&#125;</span>/<span class="variable">$render</span> <span class="variable">$&#123;tempI386Path&#125;</span>/<span class="variable">$render</span> -output libVideoRender.a</span><br><span class="line">    lipo -create <span class="variable">$&#123;tempArm64Path&#125;</span>/libWebRTC-arm64.a <span class="variable">$&#123;tempArmv7Path&#125;</span>/libWebRTC-armv7.a <span class="variable">$&#123;tempI386Path&#125;</span>/libWebRTC-i386.a -output libWebRTC.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"成功创建支持arm64、armv7、i386的libWebRTC"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清理中间垃圾文件(把子目录及子目录中所有档案删除,并且不用一一确认)</span></span><br><span class="line">    rm -rf <span class="variable">$&#123;tempArm64Path&#125;</span></span><br><span class="line">    rm -rf <span class="variable">$&#123;tempArmv7Path&#125;</span></span><br><span class="line">    rm -rf <span class="variable">$&#123;tempI386Path&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">funBuildWebRTC</span><br></pre></td></tr></table></figure>
<h1 id="参考文章">参考文章</h1><p><a href="http://www.lampweb.org/linux/1/" target="_blank" rel="external">shell 命令</a></p>
<p><a href="http://c.biancheng.net/cpp/shell/" target="_blank" rel="external">Linux Shell脚本教程：30分钟玩转Shell脚本编程</a></p>
<p><a href="http://segmentfault.com/a/1190000002924882#articleHeader16" target="_blank" rel="external">Shell常用招式大全之入门篇</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/开发利器/">开发利器</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/23/Shell编程实践/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/23/Shell编程实践/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/16/Runtime/" title="Runtime" itemprop="url">Runtime</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T03:12:52.000Z" itemprop="datePublished"> 发表于 2015-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Objective-C是基于C语言加入了 <strong>面向对象特性</strong> 和 <strong>消息转发机制</strong> 的动态语言，这意味着它不仅需要一个编译器，还需要 <strong>Runtime系统</strong> 来动态创建类和对象，进行消息发送和转发。</p>
<p>Runtime即运行时，是系统在运行的时候的一些机制，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据 <strong>函数的名称</strong> 找到对应的函数来调用。</p>
<blockquote>
<p>事实证明，在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。而C语言在这种情况下，编译阶段就会报错。对于C语言，函数的调用在编译的时候就会决定调用哪个函数，编译完成之后直接顺序执行，无任何二议性。</p>
</blockquote>
<p><a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">RunTime源码</a>，它是一套比较底层的纯C语言API，属于一个C语言库，包含了很多底层的C语言API。平时编写的OC代码，在程序运行过程中，其实最终都是转成了Runtime的C语言代码，Runtime算是OC的幕后工作者。</p>
<h1 id="数据结构">数据结构</h1><h2 id="SEL">SEL</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>SEL其主要作用是快速的通过方法名字查找到对应方法的函数指针，然后调用其函数。SEL其本身是一个Int类型的一个地址，地址中存放着方法的名字。对于一个类中每一个方法对应着一个SEL,所以iOS类中不能存在2个名称相同的方法，即使参数类型不同，因为SEL是根据方法名字生成的，相同的方法名称只能对应一个SEL。</p>
<p>可以通过Objc编译器命令@selector()或者Runtime系统的sel_registerName函数来获取一个SEL类型的方法选择器。如果你知道selector对应的方法名是什么，可以通过NSString* NSStringFromSelector(SEL aSelector)方法将SEL转化为字符串，再用NSLog打印。</p>
<h2 id="id">id</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>id是通用类型指针，能够表示任何对象。id其实就是一个指向objc_object结构体指针，它包含一个Class isa成员，根据isa指针就可以顺藤摸瓜找到对象所属的类。</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> </span>&#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="external">详见官方文档</a>。</p>
</blockquote>
<h2 id="Class">Class</h2><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">  Class isa; <span class="comment">// 指向metaclass</span></span><br><span class="line">   </span><br><span class="line">  Class super_class ; <span class="comment">// 指向其父类</span></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">char</span> *name ; <span class="comment">// 类名</span></span><br><span class="line">  <span class="built_in">long</span> <span class="keyword">version</span> ; <span class="comment">// 类的版本信息，初始化默认为0，可以通过runtime函数class_setVersion和class_getVersion进行修改、读取</span></span><br><span class="line">  <span class="built_in">long</span> info; <span class="comment">// 一些标识信息,如CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含对象方法和成员变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;</span></span><br><span class="line">  <span class="built_in">long</span> instance_size ; <span class="comment">// 该类的实例变量大小(包括从父类继承下来的实例变量);</span></span><br><span class="line">  <span class="keyword">struct</span> objc_ivar_list *ivars; <span class="comment">// 用于存储每个成员变量的地址</span></span><br><span class="line">  <span class="keyword">struct</span> objc_method_list **methodLists ; <span class="comment">// 与 info 的一些标志位有关,如CLS_CLASS (0x1L),则存储对象方法，如CLS_META (0x2L)，则存储类方法;</span></span><br><span class="line">  <span class="keyword">struct</span> objc_cache *cache; <span class="comment">// 指向最近使用的方法的指针，用于提升效率；</span></span><br><span class="line">  <span class="keyword">struct</span> objc_protocol_list *protocols; <span class="comment">// 存储该类遵守的协议</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。</p>
<p>在objc_class结构体中：ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。也就是说可以动态修改*methodLists的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。关于二级指针，可以参考<a href="http://www.fenesky.com/blog/2014/07/03/pointers-to-pointers.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="Method">Method</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br><span class="line">struct objc_method <span class="comment">&#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span>                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>Method表示类中的某个方法，是一个指向objc_method结构体指针，它存储了方法名(method_name)、方法类型(method_types)和方法实现(method_imp)等信息。</p>
<h2 id="IMP">IMP</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef id <span class="list">(<span class="keyword">*IMP</span>)</span><span class="list">(<span class="keyword">id</span>, SEL, ...)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>IMP指向的方法与objc_msgSend函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的SEL对应的方法实现肯定是唯一的，通过一组id和SEL参数就能确定唯一的方法实现地址；反之亦然。它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。</p>
<h2 id="Ivar">Ivar</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// An opaque type that represents an instance variable.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_ivar *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="keyword">char</span> *ivar_name                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset                                          OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#ifdef __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                                                OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ivar表示类中的实例变量，是一个指向objc_ivar结构体指针，它包含了变量名(ivar_name)、变量类型(ivar_type)等信息。</p>
<h2 id="Property">Property</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *Property;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *<span class="keyword">objc_property_t</span>;<span class="comment">//这个更常用</span></span><br></pre></td></tr></table></figure>
<p>Property代表类中的属性，它是一个指向objc_property结构体的指针。可以通过class_copyPropertyList 和 protocol_copyPropertyList方法来获取类和协议中的属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">objc_property_t</span> *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br><span class="line"><span class="keyword">objc_property_t</span> *protocol_copyPropertyList(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span><br></pre></td></tr></table></figure>
<p>返回类型为指向指针的指针，因为属性列表是个数组，每个元素内容都是一个objc_property_t指针，而这两个函数返回的值是指向这个数组的指针。</p>
<h2 id="Cache">Cache</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_cache *Cache</span><br></pre></td></tr></table></figure>
<p>Cache为方法调用的性能进行优化，通俗地讲，每当实例对象接收到一个消息时，它不会直接在isa指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在Cache中查找。Runtime 系统会把被调用的方法存到Cache中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。这根计算机组成原理中学过的 CPU 绕过主存先访问Cache的道理挺像。</p>
<h1 id="消息">消息</h1><p>Objc 中发送消息是用中括号（[]）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。下面详细叙述下消息发送步骤：</p>
<ol>
<li>检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。</li>
<li>检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>
<li>如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。</li>
<li>如果 cache 找不到就找Class中的方法列表。</li>
<li>如果Class中的方法列表找不到就到超类的Class中的方法列表去找，一直找，直到找到NSObject类为止。</li>
<li>如果还找不到就要开始进入动态方法解析了。</li>
</ol>
<h1 id="应用">应用</h1><p>Runtime是属于OC的底层，可以进行一下非常底层的操作：</p>
<ol>
<li>在程序运行过程中动态地创建一个类（比如KVO底层的实现）。</li>
<li>在程序运行过程中动态地为某个类添加属性、方法，修改属性值和方法。</li>
<li>遍历一个类的所有成员变量、属性、方法。如：字典转模型利用Runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值设置到模型的属性上。</li>
</ol>
<p>相关的头文件：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;objc/runtime.h&gt;</span></span><br><span class="line"><span class="tag">&lt;objc/message.h&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1><p><a href="http://chun.tips" target="_blank" rel="external">刨根问底Objective－C Runtime</a></p>
<p><a href="http://www.jianshu.com/p/25a319aee33d#" target="_blank" rel="external">Objective-C特性：Runtime</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/开发利器/">开发利器</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/16/Runtime/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/16/Runtime/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/09/大话-property/" title="大话@property" itemprop="url">大话@property</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-08-09T06:29:16.000Z" itemprop="datePublished"> 发表于 2015-08-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="@property">@property</h1><p>在普通的OC对象中，@property就是编译器自动帮我们生成一个私有的成员变量和getter、setter方法的声明及实现。为了研究编译器是如何实现@property的，我们需要使用clang。clang提供一个命令，可以将OC的源码改写成c++的，借此可以研究@property具体的源码实现方式。该命令是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">clang</span> <span class="tag">-rewrite-objc</span> <span class="tag">xxx</span><span class="class">.m</span></span><br></pre></td></tr></table></figure>
<p>除此之外我们还可以通过苹果开源的runtime进行研究，源码地址。<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">源码</a></p>
<h2 id="线程安全">线程安全</h2><h3 id="atomic、nonatomic">atomic、nonatomic</h3><p>atomic为原子性，会对set方法的实现进行加锁，多线程下可以一个线程写多个线程读，主要用在mac开发；nonatomic为非原子性，set方法的实现不加锁（比atomic性能高）。因为mac开发早于iOS开发，所以默认值为atomic。（A joke!）在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备nonatomic特质，则不使用同步锁。</p>
<p>一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。因此，在iOS开发中，你会发现，几乎所有属性都声明为nonatomic；但是在开发Mac OS X程序时，使用 atomic属性通常都不会有性能瓶颈。</p>
<p>问题来了：</p>
<blockquote>
<p>@property (strong) NSMutableArray *array; 有什么问题？</p>
</blockquote>
<p>线程安全特性默认为atomic，该属性使用了同步锁，会在创建属性时生成一些额外的代码用于帮助写多线程程序，这会带来性能问题，通过显示声明nonatomic可以节省这些虽然很小但是不必要的额外开销。</p>
<h2 id="访问权限">访问权限</h2><h3 id="readonly、readwrite">readonly、readwrite</h3><p>readonly只生成get方法的声明和实现； readwrite同时生成get方法和set方法的声明和实现。</p>
<h2 id="内存管理">内存管理</h2><p>每个对象都有一个引用计数器，每个新对象的计数器默认是1，当对象的计数器减为0时就会被销毁；通过retain可以让对象的计数器加1、release可以让对象的计数器减1，还可以通过 <strong>autorelease pool</strong> 管理内存；只要调用了alloc、copy、new、retain方法产生的新对象，都必须在最后调用一次release或者autorelease；如果使用ARC，编译器会自动生成管理内存的代码。</p>
<h3 id="assign">assign</h3><p>set方法的实现是直接赋值，用于基本数据类型的简单赋值操作，用于非OC对象。</p>
<h3 id="weak(ARC)">weak(ARC)</h3><p>weak表明该属性定义了一种“非拥有关系（nonowning relationship）”，set方法的实现既不release旧也不retain新值，同assign类似，然而当对象销毁的时候，指针会被自动设置为nil，weak必须用于OC对象。</p>
<p>使用场合：</p>
<blockquote>
<p>*在ARC中，出现循环引用的时候，必须要有一端使用weak，比如：delegate。</p>
<p>*自身已经对它进行一次强引用，没有必要在强引用一次，此时也会使用weak，比如@IBOutlet。</p>
</blockquote>
<h3 id="copy">copy</h3><p>set方法的实现是release旧值，copy新值，用于NSString、block等类型。<br>栗子来了：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(nonatomic, <span class="keyword">copy</span>) NSString *<span class="property">name</span>;</span><br><span class="line">- (void)setName:(NSString *)<span class="property">name</span>&#123;	<span class="keyword">if</span> (_name != <span class="property">name</span>) &#123;		[_name release];		_name = [<span class="property">name</span> <span class="keyword">copy</span>];	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>字符串使用copy是为了外部把字符串内容改了不影响该属性；block使用copy是在MRC遗留下来的，在MRC中方法内部的block是在栈区的，使用copy可以把它放到堆区。在ARC中对于block使用copy还是strong效果是一样的。</p>
<h3 id="Copy扩展">Copy扩展</h3><h4 id="前提">前提</h4><p>实现NSCopying或NSMutableCoping。</p>
<h4 id="作用">作用</h4><ol>
<li>改变原对象不影响拷贝对象。</li>
<li>改变拷贝对象不影响源对象。</li>
</ol>
<h4 id="浅复制和深复制">浅复制和深复制</h4><p>Copy产生的是不可变副本，MutableCopy产生的是可变副本。</p>
<p>只要源对象是不可变类型且产生的对象也是不可变类型的时的情况是浅复制，其他情况都是深复制。浅复制是源对象和拷贝对象指向同一对象，深复制是产生了不同的对象。</p>
<h4 id="@property和copy">@property和copy</h4><p>在set方法中release旧值copy新值，用于NSString和block，可以保证属性不会被外部变量（例如NSMutableString类型变量）的改变所影响。</p>
<p>问题来了：</p>
<blockquote>
<p>@property (nonatomic，copy) NSMutableArray *array;这个写法会出什么问题？</p>
</blockquote>
<p>copy产生的是不可变副本，在set方法中release旧值copy新值，所以运行时类型为NSArray，编译时类型为NSMutableArray，所以对array执行添加、删除、修改数组内的元素的时候程序会因为找不到对应的方法而崩溃。</p>
<p>栗子来了：</p>
<blockquote>
<p>当一个使用 <strong> initWithArray:</strong> 初始化方法创建的NSMutable对象赋值给array属性，那么之后array执行可变数组的方法，比如：<strong>removeObjectAtIndex:</strong> 时会出现”-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x100206cd0”的崩溃。原因在于array属性在被赋值（setter）的时候默认执行了copy方法后变为了不可变NSArray对象。</p>
</blockquote>
<h4 id="自定义对象">自定义对象</h4><ol>
<li>遵守NSCopying或NSMutableCopying协议。其实也可以在代码中不写协议类的遵守，只实现里面的方法，协议只是用来方便生成快捷方法的。</li>
<li>实现copyWithZone或mutableCopyWithZone。即用self实例化对象（[[[self class] allocWithZone: zone]init];）、属性赋值、返回对象。</li>
</ol>
<h4 id="特别注意">特别注意</h4><p>编译时类型和运行时类型，应以运行时类型为准。</p>
<h3 id="strong(ARC)、retain(MRC)">strong(ARC)、retain(MRC)</h3><p>set方法的实现是release旧值，retain新值，用于OC对象类型。</p>
<p>栗子来了：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">property</span>(nonatomic, <span class="keyword">copy</span>) NSString *<span class="property">name</span>;</span><br><span class="line">- (void)setName:(NSString *)<span class="property">name</span>&#123;	<span class="keyword">if</span> (_name != <span class="property">name</span>) &#123;		[_name release];		_name = [<span class="property">name</span> retain];	&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指定方法名称">指定方法名称</h2><p>setter=</p>
<p>getter=</p>
<h2 id="@synthesize和@dynamic">@synthesize和@dynamic</h2><p>@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">synthesize</span> var=_var</span>;</span><br></pre></td></tr></table></figure>
<h3 id="@synthesize">@synthesize</h3><p>@synthesize的语义就是，如果没有指定成员变量的名称会自动生成一个属性同名的成员变量，如果这个成员变量已经存在了就不再生成。</p>
<p>如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</p>
<p>在@property被增强之后其实已经很少使用@synthesize</p>
<h3 id="@dynamic">@dynamic</h3><p>@dynamic告诉编译器，属性的setter方法和getter方法由我自己实现不用自动生成（对于readonly的属性只需提供getter方法即可），如果你木有提供setter方法和getter方法，编译时是没问题，但是当程序运行时调用会由于缺少setter方法或gettr方法导致程序崩溃。</p>
<p>编译时是靠Xcode把关，运行时靠runtiime机制来执行相应的方法，这就是所谓的动态绑定。</p>
<h1 id="参考链接">参考链接</h1><p><a href="http://www.jianshu.com/p/4fea8fa60d75" target="_blank" rel="external">iOS面试题</a></p>
<p><a href="http://www.90159.com/2015/07/26/71/" target="_blank" rel="external">iOS面试题集锦</a></p>
<p><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01《招聘一个靠谱的iOS》面试题参考答案/《招聘一个靠谱的iOS》面试题参考答案（上）.md" target="_blank" rel="external">《招聘一个靠谱的iOS》面试题参考答案（上）</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/09/大话-property/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/09/大话-property/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/01/iOS开发、Mac使用中这些你造吗/" title="iOS开发、Mac使用中这些你造吗" itemprop="url">iOS开发、Mac使用中这些你造吗</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-08-01T02:02:14.000Z" itemprop="datePublished"> 发表于 2015-08-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>子曰：工欲善其事，必先利其器。居是邦也。事其大夫之贤者，友其士之仁者。</p>
<p>有志者事竟成，破釜沉舟，百二秦关终属楚； 苦心人天不负，卧薪尝胆，三千越甲可吞吴。 </p>
<p>由此产生此文！</p>
<h1 id="Mac常用快捷键">Mac常用快捷键</h1><h2 id="窗口操作">窗口操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+Q：退出程序</span><br></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dock右键App+Alt：退出程序<span class="comment">--&gt;强制退出</span></span><br></pre></td></tr></table></figure>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">W</span>：关闭程序的窗口，并没有真正退出程序</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command（长按）+<span class="keyword">Tab</span>：切换程序窗口</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command（长按）+空格：切换输入法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+⬆️：管理多个桌面</span><br></pre></td></tr></table></figure>
<h2 id="文件操作">文件操作</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击一下文件、文件夹+空格：快速预览内容，无需双击打开。</span><br></pre></td></tr></table></figure>
<h1 id="Xcode常用快捷键">Xcode常用快捷键</h1><h2 id="Xcode导航快捷键">Xcode导航快捷键</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="number">1</span>：工程导航器</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="number">0</span>：显示、隐藏导航器面板</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">Option</span>+<span class="number">0</span>：显示、隐藏实用工具面板</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在项目导航器中选中文件，执行<span class="keyword">Option</span>+左键点击操作：在辅助编辑器中打开文件</span><br></pre></td></tr></table></figure>
<h2 id="Xcode搜索快捷键">Xcode搜索快捷键</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">Shift</span>+F：搜索导航器(<span class="built_in">Find</span> Navigator，也就是搜索)</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Control</span>+<span class="number">6</span>（键入方法/变量名+<span class="keyword">Enter</span>跳转）：文件跳转栏</span><br></pre></td></tr></table></figure>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + O：快速打开</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Control</span> + Command + ⬆️：程序中(Objective-<span class="keyword">C</span>或<span class="keyword">C</span>++编写).h and .m文件间的快速切换</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">L</span>：输入行号进行快速查找</span><br></pre></td></tr></table></figure>
<h2 id="应用程序编译和清理">应用程序编译和清理</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + R：运行app</span><br></pre></td></tr></table></figure>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + K：清除工程</span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + B：构建应用程序</span><br></pre></td></tr></table></figure>
<h2 id="调试相关">调试相关</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Command</span> + . ：方便地暂停运行iOS模拟器</span><br></pre></td></tr></table></figure>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command+<span class="keyword">K</span>：删除调试面板里的信息，相当于<span class="keyword">Debug</span> Workflow-&gt;<span class="keyword">Clear</span> Console</span><br></pre></td></tr></table></figure>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+Command+<span class="keyword">Y</span>：继续执行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F6：跳过方法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F7：跳入方法</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F8：跳出方法</span><br></pre></td></tr></table></figure>
<h2 id="文档和帮助">文档和帮助</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + Shift + <span class="number">0</span> (Zero)：文档和参考</span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在类或者方法名上执行<span class="keyword">Option</span> + 左键点击操作：快速帮助</span><br></pre></td></tr></table></figure>
<h2 id="其他快捷键">其他快捷键</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Shift</span> + J：可展示当前你在工程导航器中打开的文件</span><br></pre></td></tr></table></figure>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + <span class="number">1</span>：可打开<span class="string">"Show Related Items’弹出菜单</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + <span class="keyword">Option</span> + Shift + 左键点击操作：该组合键可展示一个小尺寸的弹出视图，你可以查看你想要打开它的地方，比如辅助编辑器、标签或者窗口等。</span><br></pre></td></tr></table></figure>
<h1 id="VIM编辑器相关">VIM编辑器相关</h1><h2 id="VIM的运行模式">VIM的运行模式</h2><pre><code>编辑模式：等待编辑命令输入

插入模式：编辑模式下，输入 “<span class="built_in">i</span>” 进行插入模式，插入文本信息

命令模式：在编辑模式下按Esc键，输入 “:” 进行命令模式
</code></pre><h2 id="VIM使用的命令">VIM使用的命令</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:q</span>：直接退出</span><br></pre></td></tr></table></figure>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:wq</span>：保存后退出</span><br></pre></td></tr></table></figure>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:q!</span>：强制退出</span><br></pre></td></tr></table></figure>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Shift</span>+v：选中光标行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y：复制选中行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p：粘贴选中行</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x：删除光标前的一个字符</span><br></pre></td></tr></table></figure>
<h1 id="常见Unix指令">常见Unix指令</h1><p>因为Mac系统是基于UNIX系统的，因此可以在“终端”中输入一些UNIX指令来操作Mac系统。比如：新建文件（夹）、打开文件（夹）等。</p>
<h2 id="文件目录操作指令">文件目录操作指令</h2><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span>：列出当前目录下的所有内容（文件、文件夹）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-l：列出文件的详细信息</p>
<p>-a：列出当前目录所有文件，包括隐藏文件</p>
</blockquote>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span>：新建一个目录</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p：父目录不存在的情况下先生成父目录</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>：改变当前操作的目录</span><br></pre></td></tr></table></figure>
<figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">touch</span>：新建一个文件（文件不存在才会新建）</span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span>（tac）：显示文本文件内容</span><br></pre></td></tr></table></figure>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cp</span>：复制文件或目录</span><br></pre></td></tr></table></figure>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rm</span>：删除文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-r：同时（递归）删除该目录下的所有文件</p>
<p>-f：强制删除文件或目录</p>
</blockquote>
<pre><code>mv：移动文件或目录
</code></pre><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>：在文件系统中查找指定的文件</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>：显示当前目录的名称</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span>：打开一个文件（夹）</span><br></pre></td></tr></table></figure>
<p><strong>注：按一下Tab键可以自动补齐指令名称、文件名、文件夹名等。</strong></p>
<h2 id="Unix指令中的特殊路径">Unix指令中的特殊路径</h2><p>Mac系统采用的是UNIX文件系统，所有的文件都放在根目录下（即“\”）,因此没有Windows中的C盘、D盘的概念，文件路径就不再有盘符。例如：</p>
<pre><code>Windows中：<span class="string">c:</span><span class="comment">//Users/你的用户名/Desktop</span>

Mac中：<span class="regexp">/Users/</span>你的用户名/Desktop
</code></pre><p>在使用Unix指令过程中，经常会涉及到目录（路径）操作，下面列出几个有特殊含义的路径：</p>
<pre><code>/：根路径
./：当前路径
../：上一级路径
/：根目录，以斜杠表示，其他所有文件和目录在根目录下展开。
/bin：“binary”的缩写，存放提供用户级基础功能的二进制文件，如ls、ps等。
/boot：存放能使系统成功启动的所有文件，这些文件一般在内核用户程序开始执行前得到调用。在iOS中此目录为空。
/dev：“device”的简写，存放BSD设备文件。每个文件代表系统的一个块设备或字符设备，一般来说，“块设备”以块为单位传输数据，如硬盘；而“字符设备”以字符为单位传输数据，如调整解调器。
/sbin：“system binaries”的简写，存放提供系统级基础功能的二进制文件，如netstat、reboot等。
<span class="regexp">/etc：“et cetera”的简写，存放系统脚本及配置文件，如passwd、hosts等。在iOS中，/</span>etc是一个符号链接，实际指向<span class="regexp">/private/</span>etc。
/lib：存放系统库文件、内核模块及设备驱动等。iOS中此目录为空。
/mnt：“mount”的简写，存放临时的文件系统挂载点。iOS中此目录为空。
<span class="regexp">/private：存放两个目录，分别是/</span><span class="keyword">private</span><span class="regexp">/etc和/</span><span class="keyword">private</span>/var。
<span class="regexp">/tmp：临时目录。在iOS中，/</span>tmp是一个符号链接，实际指向<span class="regexp">/private/</span>tmp。
<span class="regexp">/usr：包含了大多数用户工具和程序。/</span>usr<span class="regexp">/bin包含那些/</span>bin和<span class="regexp">/sbin中未出现的基础功能，如nm、killall等；/</span>usr<span class="regexp">/include包含所有的标准C头文件；/</span>usr/lib存放库文件。
<span class="regexp">/var：“variable”的简写，存放一些经常更改的文件，如日志、用户数据、临时文件等。其中/</span>var<span class="regexp">/mobile/</span>Applications下存放了所有App Store App，是要重点关注的目录之一。
</code></pre><h2 id="系统管理命令">系统管理命令</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who（w）：显示在线登陆用户</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami：显示用户自己的身份</span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hostname</span>：显示主机名称</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname：显示系统信息</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">top</span>：显示当前系统中耗费资源最多的进程</span><br></pre></td></tr></table></figure>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span>：显示瞬间的进程状态</span><br></pre></td></tr></table></figure>
<pre><code><span class="title">ifconfig</span> en0：显示网络接口信息
</code></pre><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clear</span>：清屏</span><br></pre></td></tr></table></figure>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">man</span>：命令帮助信息查询</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export</span><br><span class="line"></span><br><span class="line">设置或显示环境变量，但是只在本次登陆中有效。在shell中执行程序时，shell会提供一组环境变量，export可新增、修改或删除环境变量，供后续执行的程序使用，效力仅及于此登陆操作。export设置环境变量是暂时的，只在本次登陆中有效。=前的<span class="constant">PATH</span>变量不加<span class="variable">$符</span>号，再增加的路径用<span class="symbol">:</span>追加。</span><br><span class="line"></span><br><span class="line">export <span class="constant">PATH</span>=<span class="variable">$PATH</span><span class="symbol">:/Library/Developer/IceTouch-</span><span class="number">1.3</span>/<span class="constant">SDKs</span>/<span class="constant">Objc</span>/bin</span><br></pre></td></tr></table></figure>
<h1 id="iphone的一些操作">iphone的一些操作</h1><p>双击Shift开启大写</p>
<p>摇一摇撤销</p>
<p>计算器输入的时候手指右划可以删除输入的数字</p>
<p>按住键盘上的小地球切换输入法</p>
<p>拍照可以按声音键</p>
<p>点击状态栏回到顶部</p>
<p>导航侧滑</p>
<h1 id="写在最后">写在最后</h1><p>iOS开发和Mac使用中你还有哪些能提高开发效率的小技巧和快捷键以及黑科技，在评论中一起分享吧。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/开发利器/">开发利器</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/开发利器/">开发利器</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/08/01/iOS开发、Mac使用中这些你造吗/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/08/01/iOS开发、Mac使用中这些你造吗/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/26/信令、stun、turn/" title="信令、stun、turn、ice" itemprop="url">信令、stun、turn、ice</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-07-26T09:48:27.000Z" itemprop="datePublished"> 发表于 2015-07-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>webRTC支持点对点通讯，但是webRTC仍然需要服务端：</p>
<ul>
<li>协调通讯过程中客户端之间需要交换元数据，如一个客户端找到另一个客户端以及通知另一个客户端开始通讯。</li>
<li>需要处理NAT（网络地址转换）或防火墙，这是公网上通讯首要处理的问题。</li>
</ul>
<p>所以我们需要了解服务端相关的知识：信令、Stun、trun、ice。</p>
<h1 id="什么是信令">什么是信令</h1><p>信令就是协调通讯的过程，为了建立一个webRTC的通讯过程，客户端需要交换如下信息：</p>
<ul>
<li>会话控制信息，用来开始和结束通话，即开始视频、结束视频这些操作指令。</li>
<li>处理错误的消息。</li>
<li>元数据，如各自的音视频解码方式、带宽。</li>
<li>网络数据，对方的公网IP、端口、内网IP及端口。</li>
</ul>
<p>信令处理过程需要客户端能够来回传递消息，这个过程在webRTC里面是没有实现的，需要自己创建。一旦信令服务建立好了,两个客户端之间建立了连接,理论上他们就可以进行点对点通讯了,这样可以减轻信令服务的压力和消息传递的延迟。</p>
<p>因为信令是我们自己定义的,所以安全性问题跟webrtc无关,需要自己处理。一旦黑客掌握了你的信令,那他就是控制会话的开始、结束、重定向等等。最重要的因素在信令安全中还是要靠使用安全协议,如HTTPS,WSS(如TLS),他们能确保未加密的消息不能被截取。为确保信令安全,强烈推荐使用TLS。</p>
<h1 id="TURN和STUN">TURN和STUN</h1><p>元数据是通过信令服务器中转发给另一个客户端,但是对于流媒体数据,一旦会话建立,首先尝试使用点对点连接。简单一点说就是:每个客户端都有一个唯一的地址,他能用来和其他客户端进行通讯和数据交换。现实生活中客户端都位于一个或多个NAT之后,或者一些杀毒软件还阻止了某些端口和协议,或者在公司还有防火墙或代理等等,防火墙和NAT或许是同一个设备,如我们家里用的路由器。</p>
<p>webrtc就是通过 ICE 这套框架来处理复杂的网络环境的,如果想启用这个功能,你必须让你的应用程序传 ICE 服务器的URL：ICE试着找最好的路径来让客户端建立连接,他会尝试所有可能的选项,然后选择最合适的方案,ICE首先尝试P2P连接,如果失败就会通过Turn服务器进行转接。换一个说法就是:</p>
<p><strong> STUN服务器是用来取外网地址的。</strong></p>
<p><strong> TURN服务器是在P2P失败时进行转发的 </strong></p>
<p>stun和turn服务的作用主要处理打洞与转发，配合完成ICE协议。首先尝试使用P2P，如果失败将求助于TCP，使用turn转发两个端点的音视频数据，turn转发的是两个端点之间的音视频数据不是信令数据。因为turn服务器是在公网上，所以他能被各个客户端找到，另外turn服务器转发的是数据流，很占用带宽和资源。</p>
<h1 id="ICE技术">ICE技术</h1><p>基于IP的语音、数据、视频等业务在NGN（Next Generation Network）网络中所面临的一个实际困难就是如何有效地穿透各种NAT（Network Address Translator）/FW(Fire Wall)的问题。对此，SIP（会话初始化协议）以往的解决方法由ALGs（(Application Layer Gateway Service)）、STUN、TURN等方式。现在有一种新的媒体会话信令穿透NAT/FW的解决方案-交互式连通建立方式ICE。它通过综合利用现有协议，以一种更有效的方式来组织会话建立过程，使之在不增加任何延迟同时比STUN等单一协议更具有健壮性、灵活性。</p>
<p>多媒体会话信令协议是在准备建立媒体流传输的代理之间交互信息的协议，例如SIP、RTSP（real time streaming protocol）等。媒体流与信令流截然不同，它们所采用的网络通道也不一致。由于协议自身设计上的原因，使得媒体流无法直接穿透网络地址转换/防火墙(NAT/FW)。因为它们生存期的目标只是为了建立一个在信息中携带IP地址的分组流，这在遇到NAT/FW 时会带来许多问题。而且这些协议的目标是通过建立P2P(Peer to Peer)媒体流以减小时延，而协议本身很多方面却与NAT存在兼容性问题，这也是穿透 NAT/FW的困难所在。</p>
<h2 id="ICE简介">ICE简介</h2><p>交互式连通建立方式ICE(Interactive Connectivity Establishment)并非一种新的协议，它不需要对STUN、TURN或RSIP进行扩展就可适用于各种NAT。ICE是通过综合运用上面某几种协议，使之在最适合的情况下工作，以弥补单独使用其中任何一种所带来的固有缺陷。对于SIP来说，ICE只需要定义一些SDP(Session Description Protocol)附加属性即可，对于别的多媒体信令协议也需要制定一些相应的机制来实现。</p>
<h2 id="多媒体信令">多媒体信令</h2><p>媒体流穿透NAT的过程是独立于某种具体的信令协议的。通信发生在两个客户端－会话发起者和会话响应者。初始化信息(Initiate Message)包含了描述会话发起者媒体流的配置与特征，并经过信令调停者(也叫信令中继)，最后到达会话响应者。假设会话响应者同意通信，接受信息(Accept Message)将产生并反馈至会话初始者，媒体流建立成功。此外，信令协议还对媒体流参数修改以及会话终止消息等提供支持。对于SIP，会话发起者即UAC(User Agent Client)，会话响应者即UAS(User Agent Server)，初始化消息对应SDP请求里面的INVITE，接受消息对应于SDP应答里面的200 OK，终止消息对应于BYE。</p>
<h2 id="流程">流程</h2><h3 id="收集传输地址">收集传输地址</h3><p>会话发起者需要收集的对象包括本地传输地址(Local Transport Address)和来源传输地址(Derived Transport Address)。本地传输地址通常由主机上一个物理(或虚拟)接口绑定一个端口而获得。会话发起者还将访问提供UNSAF(Unilateral self-address fixing)的服务器，例如STUN、TURN或TEREDO。对于每一个本地传输地址，会话者都可以从服务器上获得一组来源传输地址。显然，实现物理或虚拟连通方式越多，ICE将工作得越好。但为了建立对等通信，ICE通常要求至少有一个来源地址由位于公网上的中继服务器(如TURN)所提供的，而且需要知道具体是哪一个来源传输地址。</p>
<h3 id="启动STUN">启动STUN</h3><p>会话发起者获得一组传输地址后，将在本地传输地址启动STUN服务器，这意味着发送到来源地址的STUN服务将是可达的。与传统的STUN不同，客户端不需要在任何其它IP或端口上提供STUN服务，也不必支持TLS， ICE用户名和密码已经通过信令协议进行交换。客户端将在每个本地传输地址上同时接受STUN请求包和媒体包，所以发起者需要消除STUN消息与媒体流协议之间的歧义。在RTP和RTCP中实现这个并不难，因为RTP与RTCP包总是以0b10(v=2)打头，而STUN是0b00。对于每个运行STUN服务器的本地传输地址，客户端都必须选择相应的用户名和密码。用户名要求必须是全局唯一的，用户名和密码将被包含在初始化消息里传至响应者，由响应者对STUN请求进行鉴别。</p>
<h3 id="确定传输地址的优先级">确定传输地址的优先级</h3><p>STUN服务器启动后，下一步就是确定传输地址的优先级。优先级反映了UA在该地址上接收媒体流的优先级别，取值范围在0到1之间，通常优先级按照被传输媒体流量来确定。流量小者优先，而且对于相同流量者的Ipv6地址比Ipv4地址具有更高优先级。因此物理接口产生的本地Ipv6传输地址具有最高的优先级，然后是本地Ipv4传输地址，然后是STUN、RSIP、TEREDO来源地址，最后是通过VPN接口获得的本地传输地址。</p>
<h3 id="构建初始化信息(Initiate_Message)">构建初始化信息(Initiate Message)</h3><p>初始化消息由一系列媒体流组成，每个媒体流都有一个缺省地址和候选地址列表。缺省地址通常被Initiate消息映射到SIP信令消息传递地址上，而候选地址列表用于提供一些额外的地址。对于每个媒体流来说，任意Peer之间实现最大连通可能性的传输地址是由公网上转发服务器(如TURN)提供的地址，通常这也是优先级最低的传输地址。客户端将可用的传输地址编成一个候选地址列表(包括一个缺省地址)，并且为每个候选元素分配一个会话中唯一的标识符。该标识符以及上述的优先级都被编码在候选元素的id属性中。一旦初始化信息生成后即可被发送。</p>
<h3 id="响应处理：连通性检查和地址收集">响应处理：连通性检查和地址收集</h3><p>会话应答方接收到初始化信息Initiate Message后，会同时做几个事情：首先，执行 <em>收集传输地址</em> 中描述的地址收集过程。这些地址可以在呼叫到达前预收集，这样可以避免增加呼叫建立的时间。当获得来源地址以后，应答方会发送STUN Bind请求，该请求要求必须包含Username属性和Password属性，属性值为从 “alt”中得到的用户名和密码。STUN Bind请求还应包括一个Message-Integrity属性，它是由Initiate Message中候选元素的用户名和密码计算得来的。此外，STUN Bind请求不应有Change-Request或Response-Address属性。当一个客户端收到Initiate Message时，它将通过其中缺省地址和端口发送媒体流。如果STUN Bind请求消息引起错误应答，则需要检查错误代码。如果是401，430，432或500，说明客户端应该重新发送请求。如果错误代码是400，431和600，那么客户端不必重试，直接按超时处理即可。</p>
<h3 id="生成接受信息(Accept_Message)">生成接受信息(Accept Message)</h3><p>应答者可以决定是接受或拒绝该通信，若拒绝则ICE过程终止，若接受则发送Accept消息。Accept消息的构造过程与Initiate Message类似。</p>
<h3 id="接受信息处理">接受信息处理</h3><p>接受过程有两种可能。如果Initiate Message的接受者不支持ICE，则Accept Message将只包含缺省的地址信息，这样发起方就知道它不用执行连通性检查了。然而如果本地配置信息要求发起者通过TURN服务器发包来进行连通性检查，这将意味着那些直接发给响应者的包会被对方防火墙丢弃。为解决这个问题，发起者需要重新分配一个TURN来源地址，然后使用Send命令。一旦Send命令被接受，发起者将发送所有的媒体包到TURN服务器，由服务器转发至响应者。如果Accept Message包含候选项，则发起方处理Accept Message的过程就与响应方处理Initiate Message很相似了。</p>
<h3 id="附加ICE过程">附加ICE过程</h3><p>Initiate或Accept消息交换过程结束后，双方可能仍将继续收集传输地址，这通常是由于某些STUN事务过长而未结束引起，另一种可能是由于Initiate/Accept消息交换时提供了新的地址。</p>
<h3 id="ICE到SIP的映射">ICE到SIP的映射</h3><p>使用ICE方式穿透NAT，必须映射ICE定义的参数到SIP消息格式中，同时对其SDP属性进行简单扩展—在SDP的Media块中定义一个新的属性“alt”来支持ICE。它包含一个候选IP地址和端口，SDP的接受端可以用该地址来替换m和c中的地址。Media块中可能会有多个alt属性，这时每个alt应该包括不重复的IP地址和端口。</p>
<h1 id="写在最后">写在最后</h1><p>ICE方式的优势是显而易见的，它消除了现有的UNSAF机制的许多脆弱性。例如传统的STUN有几个脆弱点，其中一个就是发现过程需要客户端自己去判断所在NAT类型，这实际上不是一个可取的做法。而应用ICE之后，这个发现过程已经不需要了。另一点脆弱性在于STUN、TURN等机制都完全依赖于一个附加的服务器，而ICE利用服务器分配单边地址的同时，还允许客户端直接相连，因此即使STUN或TRUN服务器中有任何一个失败了，ICE方式仍可让呼叫过程继续下去。此外，传统的STUN最大的缺陷在于它不能保证在所有网络拓扑结构中都正常工作，最典型的问题就是Symmetric NAT。对于TURN或类似转发方式工作的协议来说，由于服务器的负担过重，很容易出现丢包或者延迟情况。而ICE方式正好提供了一种负载均衡的解决方案，它将转发服务作为优先级最低的服务，从而在最大程度上保证了服务的可靠性和灵活性。此外，ICE的优势还在于对Ipv6的支持，目前Cisco等公司正在设计基于ICE方式的NAT/FW解决方案。由于广泛的适应能力以及对未来网络的支持，ICE作为一种综合的解决方案将有着非常广阔的应用前景。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/IM/">IM</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/IM/">IM</a><a href="/tags/webRTC/">webRTC</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/07/26/信令、stun、turn/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/07/26/信令、stun、turn/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/19/构建支持armv7和arm64的webRTC静态库/" title="构建支持armv7和arm64的webRTC静态库" itemprop="url">构建支持armv7和arm64的webRTC静态库</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-07-19T04:13:57.000Z" itemprop="datePublished"> 发表于 2015-07-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="概述">概述</h1><p>arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。需要注意的是iOS模拟器没有运行arm指令集，编译运行的是x86指令集，所以，只有在iOS设备上，才会执行设备对应的arm指令集。</p>
<p><strong>目前为止Apple移动设备默认指令集</strong></p>
<hr>
<p>armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch</p>
<p>armv7 设备：iPhone3GS, iPhone4, iPhone4S, iPad, iPad2, iPad3(The New iPad), iPad mini,<br>iPod Touch 3G, iPod Touch4</p>
<p>armv7s设备： iPhone5, iPhone5C, iPad4(iPad with Retina Display)</p>
<p>arm64 设备： iPhone5S, iPad Air, iPad mini2(iPad mini with Retina Display)</p>
<hr>
<p>现在苹果默认要求支持armv7&amp;arm64，知道了这些信息我们进入下一话题！</p>
<h1 id="构建支持armv7和arm64的webRTC静态库">构建支持armv7和arm64的webRTC静态库</h1><p>总体思路就是将webRTC中的armv7静态库合并优化成一个单一的静态库，arm64中的所有静态库合并优化成一个单一的静态库，最后利用lipo指令合并这两个静态库为一个最终的静态库。</p>
<h2 id="armv7">armv7</h2><p>合并所有的*.a构建armv7为libWebRTC-armv7.a并优化静态库</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libtool -<span class="keyword">static</span> -o src<span class="regexp">/armv7/</span>Release-iphoneos<span class="regexp">/libWebRTC-temp.a src/</span>armv7<span class="regexp">/Release-iphoneos/</span>*.a</span><br><span class="line"></span><br><span class="line">strip -S -x -o src<span class="regexp">/armv7/</span>Release-iphoneos<span class="regexp">/libWebRTC-armv7.a -r src/</span>armv7<span class="regexp">/Release-iphoneos/</span>libWebRTC-temp.a</span><br></pre></td></tr></table></figure>
<h2 id="arm64">arm64</h2><p>合并所有的*.a构建arm64为libWebRTC-arm64.a</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libtool -<span class="keyword">static</span> -o src<span class="regexp">/arm64/</span>Release-iphoneos<span class="regexp">/libWebRTC-temp.a src/</span>arm64<span class="regexp">/Release-iphoneos/</span>*.a</span><br><span class="line"></span><br><span class="line">strip -S -x -o src<span class="regexp">/arm64/</span>Release-iphoneos<span class="regexp">/libWebRTC-arm64.a -r src/</span>arm64<span class="regexp">/Release-iphoneos/</span>libWebRTC-temp.a</span><br></pre></td></tr></table></figure>
<p><strong>2015年7月27日更新</strong></p>
<p><strong>之前的指令用在音频没有问题，但是用在视频只有声音没有图像。最后检查发现没有使用strip优化之前的包可以使用，而且不能包括iOS生成的静态库。
</strong></p>
<h2 id="创建支持armv7&amp;arm64的libWebRTC">创建支持armv7&amp;arm64的libWebRTC</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -<span class="built_in">create</span> src/armv7/Release-iphoneos/libWebRTC-armv7.<span class="operator">a</span> src/arm64/Release-iphoneos/libWebRTC-arm64.<span class="operator">a</span> -output libWebRTC.<span class="operator">a</span></span><br></pre></td></tr></table></figure>
<p><strong>lipo -info libWebRTC.a，可以查看支持的架构信息</strong></p>
<p><strong>2015年8月19日更新</strong><br><strong>当测试armv7指令集通过后，在原来的工程中删掉armv7添加arm64对应的库时编译通不过，因为同一个文件下包含了两种架构信息所导致。解决方案：</strong></p>
<ol>
<li>选择工程, 编译的 (targets)</li>
<li>选择 Build Settings 菜单</li>
<li>查找 Library Search Paths 和 Framework Search Paths， 删掉编译报warning的路径即OK</li>
</ol>
<p><strong>关于Category位于静态库时,引用该静态库的工程使用Category,出现”unrecognized selector sent to class”提示。</strong></p>
<blockquote>
<p>标准UNIX静态库与Objective-C之间Linker的差异：在标准的UNIX静态库内,linker symbol是依照每一个类别而产生的,但由于Category并没有真正产生一个类别,所以出错。</p>
</blockquote>
<ol>
<li>在该静态库的Taraget-&gt;Build Settings-&gt;Other Linker Flags-&gt;加上 -ObjC</li>
<li>在使用该静态库的工程Taraget-&gt;Build Settings-&gt;Other Linker Flags-&gt;加上-all_load或-force_load</li>
</ol>
<p><strong>如果你的项目使用的非ARC模式，则为ARC模式的代码文件加入-fobjc-arc标签。如果你的项目使用的ARC模式，则为非ARC模式的代码文件加入 -fno-objc-arc标签。添加标签的方法:</strong></p>
<ol>
<li>打开target - Bulid Phases -Compile Sources</li>
<li>双击对应的*.m文件</li>
<li>在弹出的窗口中输入上面提到的标签 -fobjc-arc / -fno-objc-arc4</li>
<li>按Enter键保存</li>
</ol>
<h1 id="其他">其他</h1><p>libtool和lipo的相关指令选项参数可用通过man帮助进行查看，里面写的还是比较详细的。</p>
<h2 id="XCode中与指令集相关的选项（Build_Settings_面板下_Architectures）：">XCode中与指令集相关的选项（Build Settings 面板下 Architectures）：</h2><p>1.Architectures：      </p>
<p>指明选定Target要求被编译生成的二进制包所支持的指令集是通过编译生成对应的二进制数据包实现的，如果支持的指令集数目有多个，就会编译出包含多个指令集代码的数据包，从而会造成最终编译生成的包很大。</p>
<p>2.Valid Architectures：</p>
<p>指明可能支持的指令集并非Architectures列表中指明的指令集都会被支持，Valid Architectures限制可能被支持的指令集的范围，即Valid Architectures和Architectures列表的交集，才是XCode最终生成二进制包所支持的指令集。比如，将Architectures支持arm指令集设置为：armv7,armv7s，对应的Valid Architectures的支持的指令集设置为：armv7s,arm64，那么此时，XCode生成二进制包所支持的指令集只有armv7s 。</p>
<p>3.Build Active Architecture Only:</p>
<p>指明是否只编译当前连接设备所支持的指令集,该选项起作用的条件有两个，必须同时满足才会起作用：</p>
<ul>
<li>其值设置为YES</li>
<li>XCode成功连接调试设备</li>
</ul>
<p>当Build Active Architecture Only起作用时,连接的手机指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。<br>建议：通常Debug模式设置值为Yes，Release模式设置为No。</p>
<h2 id="WebRTC-framework的依赖"><a href="http://www.it165.net/pro/html/201503/35541.html" target="_blank" rel="external">WebRTC.framework的依赖</a></h2><p>如果项目使用了该框架,那么编译的时候需要在项目的Build Phases中添加如下库和框架:</p>
<blockquote>
<ul>
<li>libstdc++.6.dylib</li>
<li>libsqlite3.dylib</li>
<li>libc++.dylib</li>
<li>libicucore.dylib</li>
<li>Security.framework</li>
<li>CFNetwork.framework</li>
<li>GLKit.framework</li>
<li>AudioToolbox.framework</li>
<li>AVFoundation.framework</li>
<li>CoreAudio.framework</li>
<li>CoreMedia.framework</li>
<li>CoreVideo.framework</li>
<li>CoreGraphics.framework</li>
<li>OpenGLES.framework</li>
<li>QuartzCore.framework</li>
</ul>
</blockquote>
<p><strong>由于公司c++人员打包webRTC时模拟器的包有点问题，还有之前和linphone的libvpx.a的冲突最后删掉了linphone的而公用webRTC的，以至于模拟器缺少i386的libvpx.a库，解决办法：</strong></p>
<ol>
<li>将lib库拆分出armv7、armv7s、i386类型的.a，较麻烦<br>lipo -extract_family armv7 -output libDomobOfferWallSDK_arm.a libDomobOfferWallSDK.a<br>lipo -info libDomobOfferWallSDK_arm.a</li>
<li>对于i386则不用上述那么麻烦，直接用第一句-extract_family指令就能分离出只含i386版本的库<br>lipo -extract_family i386 -output libDomobOfferWallSDK_i386.a libDomobOfferWallSDK.a</li>
<li><a href="http://www.cnblogs.com/wengzilin/p/3800856.html" target="_blank" rel="external">http://www.cnblogs.com/wengzilin/p/3800856.html</a></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/IM/">IM</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/IM/">IM</a><a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/07/19/构建支持armv7和arm64的webRTC静态库/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/07/19/构建支持armv7和arm64的webRTC静态库/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/12/The-Internet-Communications-Ice-简介/" title="The Internet Communications (ice)" itemprop="url">The Internet Communications (ice)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-07-12T09:26:50.000Z" itemprop="datePublished"> 发表于 2015-07-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="简介">简介</h1><p>The Internet Communications Engine (ice) is a modern object-oriented toolkit that enables you to build distributed applications with minimal effort. Ice allows you to focus your efforts on your application logic, and it takes care of all interactions with low-level network programming interfaces. With Ice, there is no need to worry about details such as opening network connections, serializing and deserializing data for network transmission, or retrying failed connection attempts (to name but a few of dozens of such low-level details).</p>
<h1 id="开发环境搭建">开发环境搭建</h1><p>ICE安装文件：<a href="https://zeroc.com/icetouch/download.html" target="_blank" rel="external">https://zeroc.com/icetouch/download.html</a><br>ICE编译插件：<a href="https://github.com/zeroc-ice/ice-builder-xcode" target="_blank" rel="external">https://github.com/zeroc-ice/ice-builder-xcode</a></p>
<h1 id="相关文档">相关文档</h1><p>ICE官网：<a href="http://www.zeroc.com/ice.html" target="_blank" rel="external">http://www.zeroc.com/ice.html</a><br>官网文档：<a href="http://doc.zeroc.com/display/Doc/Home" target="_blank" rel="external">http://doc.zeroc.com/display/Doc/Home</a><br>性能评测：<a href="http://zeroc.com/articles/IcePerformanceWhitePaper.pdf" target="_blank" rel="external">http://zeroc.com/articles/IcePerformanceWhitePaper.pdf</a></p>
<h1 id="ICE通讯框架基本原理">ICE通讯框架基本原理</h1><p>ICE的思路是，用一个中间语言，建立数据结构规范和接口规范，然后再用一个IDE编译插件，将中间语言数据结构规范和接口规范编译为当前的语言，譬如OC的.h/.m文件，接下来，你在客户端和服务端实现中间语言定义号的接口，再做一些其它处理，就可以实现一个分布式程序了。这个思路确实很Nice，值得我们借鉴。</p>
<h1 id="通讯方式选择">通讯方式选择</h1><p>P2P（设备直连）</p>
<p>通过服务器中转</p>
<h1 id="网络连接方式">网络连接方式</h1><p>基于TCP的长连接</p>
<p>基于HTTP短连接PULL的方式</p>
<h1 id="协议选择">协议选择</h1><p>XMPP</p>
<p>SIP</p>
<p>MQTT</p>
<p>私有协议（二进制协议）</p>
<h1 id="其他">其他</h1><p>p2p视频聊天的过程：音视频数据采集—&gt;编码—&gt;发送—&gt;接收—&gt;解码—&gt;播放</p>
<p><a href="http://www.cnblogs.com/HouZhiHouJueBlogs/p/3864677.html" target="_blank" rel="external">The Internet Communications Engine (Ice) 跨平台异构通讯方案 第一弹-ICE简介</a></p>
<p><a href="http://www.cnblogs.com/HouZhiHouJueBlogs/p/3864737.html" target="_blank" rel="external">The Internet Communications Engine (Ice) 跨平台异构通讯方案 第二弹-Hello world！</a></p>
<p><a href="http://www.cnblogs.com/lingyunhu/category/626157.html" target="_blank" rel="external">webrtc</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/IM/">IM</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/IM/">IM</a><a href="/tags/ice/">ice</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/07/12/The-Internet-Communications-Ice-简介/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/07/12/The-Internet-Communications-Ice-简介/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






  

 
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/05/Grand-Central-Dispatch-gcd/" title="Grand Central Dispatch (gcd)" itemprop="url">Grand Central Dispatch (gcd)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="朱利" target="_blank" itemprop="author">朱利</a>
		
  <p class="article-time">
    <time datetime="2015-07-05T06:50:07.000Z" itemprop="datePublished"> 发表于 2015-07-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="简介">简介</h1><h2 id="什么是GCD">什么是GCD</h2><ul>
<li>全程是Grand Central Dispatch，可译为“大中央调度”</li>
<li>纯C语言，提供了非常多强大的函数库</li>
</ul>
<h2 id="GCD的优势">GCD的优势</h2><ul>
<li>GCD是苹果公司为<strong>多核</strong>的<strong>并行</strong>运算提出的解决方案</li>
<li>GCD会自动利用更多的CPU内核（比如双核、四核）</li>
<li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li>
<li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码<h1 id="任务和队列">任务和队列</h1></li>
<li>GCD中有两个核心概念</li>
</ul>
<ol>
<li><strong>任务</strong>：执行什么操作</li>
<li><strong>队列</strong>：用来存放任务</li>
</ol>
<ul>
<li>GCD的使用步骤</li>
</ul>
<ol>
<li><strong>定制任务</strong>：确定想做的事情</li>
<li><strong>将任务添加到队列中</strong>：GCD会自动将<em>队列</em>中的<em>任务</em>取出，放到对应的<em>线程</em>中执行；<em>任务</em>的取出遵循<em>队列</em>的FIFO原则：先进先出，后进后出<h2 id="执行任务">执行任务</h2>GCD中有2个用来执行任务的函数</li>
</ol>
<ul>
<li>用<strong>同步</strong>的方式执行任务<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>queue：队列<br>  block：任务</p>
</blockquote>
<ul>
<li><p>用<strong>异步</strong>的方式执行任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="keyword">dispatch_block_t</span> block); </span><br></pre></td></tr></table></figure>
</li>
<li><p>同步和异步的区别</p>
<blockquote>
<p>同步：只能在<strong>当前</strong>线程中执行任务，<strong>不具备</strong>开启新线程的能力<br>异步：可以在<strong>新的</strong>线程中执行任务，<strong>具备</strong>开启新线程的能力</p>
</blockquote>
</li>
</ul>
<h2 id="队列的类型">队列的类型</h2><p>GCD的队列可以分为2大类型</p>
<ul>
<li><p><strong>并发</strong>队列（Concurrent Dispatch Queue）</p>
<blockquote>
<p>可以让多个任务<strong>并发（同时）</strong>执行（自动开启多个线程同时执行任务）<br><strong>并发</strong>功能只有在<strong>异步（dispatch_async）</strong>函数下才有效</p>
</blockquote>
</li>
<li><p><strong>串行</strong>队列（Serial Dispatch Queue）</p>
<blockquote>
<p>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</p>
</blockquote>
</li>
<li>容易混淆的术语 <blockquote>
<p>有4个术语比较容易混淆：同步、异步、并发、串行<br><strong>同步和异步主要影响：能不能开启新的线程</strong><br>同步：在当前线程中执行任务，不具备开启新线程的能力<br>异步：在新的线程中执行任务，具备开启新线程的能力<br><strong>并发和串行主要影响：任务的执行方式</strong><br>并发：多个任务并发（同时）执行<br>串行：一个任务执行完毕后，再执行下一个任务</p>
</blockquote>
</li>
</ul>
<h3 id="并发队列">并发队列</h3><ul>
<li>GCD默认已经提供了全局的并发队列，供整个应用使用，不需要手动创建<br><strong>使用dispatch_get_global_queue函数获得全局的并发队列</strong><blockquote>
<p>dispatch_queue_t dispatch_get_global_queue(<br>dispatch_queue_priority_t priority, // 队列的优先级<br>unsigned long flags); // 此参数暂时无用，用0即可</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>); <span class="comment">// 获得全局并发队列</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>全局并发队列的优先级<br><code>#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高</code><br><code>#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中</code>）<br><code>#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低</code><br><code>#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台</code></p>
</blockquote>
<h3 id="串行队列 ">串行队列 </h3><ul>
<li>GCD中获得串行有2种途径</li>
</ul>
<p><strong>使用dispatch_queue_create函数创建串行队列</strong></p>
<blockquote>
<p>dispatch_queue_t<br>dispatch_queue_create(const char *label, // 队列名称<br>dispatch_queue_attr_t attr); // 队列属性，一般用NULL即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"cn.itcast.queue"</span>, <span class="literal">NULL</span>); <span class="comment">// 创建</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>使用主队列（跟主线程相关联的队列）</strong><br>主队列是GCD自带的一种特殊的串行队列<br>放在主队列中的任务，都会放到主线程中执行<br>使用dispatch_get_main_queue()获得主队列<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure></p>
<pre><code>凡是函数名种带有<span class="operator"><span class="keyword">create</span>\copy\new\retain等字眼, 都应该在不需要使用这个数据的时候进行<span class="keyword">release</span>
GCD的数据类型在ARC环境下不需要再做<span class="keyword">release</span>
CF(Core Foundation)的数据类型在ARC环境下还是需要再做<span class="keyword">release</span></span>
</code></pre><h3 id="各种队列的执行效果">各种队列的执行效果</h3><p><img src="http://www.zhuli8.com/photos/gcd.png" alt=""></p>
<blockquote>
<p><strong>注意</strong><br>使用sync函数往当前串行队列中添加任务，会卡住当前的串行队列</p>
</blockquote>
<h1 id="线程间通信示例 ">线程间通信示例 </h1><h2 id="从子线程回到主线程">从子线程回到主线程</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async<span class="list">(<span class="keyword">dispatch_get_global_queue</span><span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行耗时的异步操作...</span><br><span class="line">      dispatch_async<span class="list">(<span class="keyword">dispatch_get_main_queue</span><span class="list">()</span>, ^&#123;</span><br><span class="line">        // 回到主线程，执行UI刷新操作</span><br><span class="line">        &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="延时执行">延时执行</h2><p>iOS常见的延时执行有2种方式</p>
<h3 id="调用NSObject的方法">调用NSObject的方法</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> <span class="symbol">performSelector:</span><span class="variable">@selector</span>(run) <span class="symbol">withObject:</span><span class="literal">nil</span> <span class="symbol">afterDelay:</span><span class="number">2.0</span>];<span class="regexp">//</span> <span class="number">2</span>秒后再调用<span class="keyword">self</span>的run方法</span><br></pre></td></tr></table></figure>
<h3 id="使用GCD函数">使用GCD函数</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">dispatch_after</span>(<span class="function">dispatch_time</span>(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * NSEC_PER_SEC)), <span class="tag">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">    <span class="comment">// 2秒后异步执行这里的代码...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="一次性代码">一次性代码</h2><p>使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="队列组">队列组</h2><p>有这么1种需求<br>首先：分别异步执行2个耗时的操作<br>其次：等2个异步操作都执行完毕后，再回到主线程执行操作<br>如果想要快速高效地实现上述需求，可以考虑用队列组<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group =  dispatch_group_create<span class="list">()</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行<span class="number">1</span>个耗时的异步操作</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_async<span class="list">(<span class="keyword">group</span>, dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span>, ^&#123;</span><br><span class="line">    // 执行<span class="number">1</span>个耗时的异步操作</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br><span class="line">dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^&#123;</span><br><span class="line">    // 等前面的异步操作都执行完毕后，回到主线程...</span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="单例模式">单例模式</h2><h3 id="单例模式的作用">单例模式的作用</h3><p>可以保证在程序运行过程，一个类只有一个实例，而且该实例易于供外界访问，从而方便地控制了实例个数，并节约系统资源</p>
<h3 id="单例模式的使用场合">单例模式的使用场合</h3><ul>
<li>在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次）</li>
<li>单例模式在ARC\MRC环境下的写法有所不同，需要编写2套不同的代码<br>可以用宏判断是否为ARC环境<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">if</span> __has_feature(objc_arc)</span></span><br><span class="line"><span class="comment">// ARC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// MRC</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ARC单例模式的实现">ARC单例模式的实现</h4><ul>
<li><p>在.m中保留一个全局的static的实例</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> _instance;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写allocWithZone:方法，在这里创建唯一的实例（注意线程安全）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_instance) &#123;</span><br><span class="line">            _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供1个类方法让外界访问唯一的实例</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedSoundTool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_instance) &#123;</span><br><span class="line">            _instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现copyWithZone:方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="keyword">struct</span> _<span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="MRC">MRC</h4><p>非ARC中（MRC），单例模式的实现（比ARC多了几个步骤）<br><em>实现内存管理方法</em></p>
<pre><code>-<span class="ruby"> (id)retain { <span class="keyword">return</span> <span class="keyword">self</span>; }
</span>-<span class="ruby"> (<span class="constant">NSUInteger</span>)retainCount { <span class="keyword">return</span> <span class="number">1</span>; }
</span>-<span class="ruby"> (oneway void)release {}
</span>-<span class="ruby"> (id)autorelease { <span class="keyword">return</span> <span class="keyword">self</span>; }</span>
</code></pre><h1 id="推荐阅读">推荐阅读</h1><p><a href="http://www.jianshu.com/p/50c060bab0ff" target="_blank" rel="external">Ethan Joe：Grand Central Dispatch 基础教程：Part 1/2</a><br><a href="[Ethan Joe：Grand Central Dispatch 基础教程：Part 1/2](http://www.jianshu.com/p/50c060bab0ff">cocoachina：Grand Central Dispatch 基础教程：Part 2/2</a>)<br><a href="http://www.devtang.com/blog/2012/02/22/use-gcd/" target="_blank" rel="external">唐巧：使用GCD</a><br><a href="http://www.cocoachina.com/ios/20140428/8248.html" target="_blank" rel="external">GCD 深入理解（一）</a><br><a href="http://www.cocoachina.com/ios/20140515/8433.html" target="_blank" rel="external">GCD 深入理解（二）</a></p>
<h1 id="NSOperation&amp;NSOperationQueue">NSOperation&amp;NSOperationQueue</h1><p><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></p>
<p><a href="http://blog.xcodev.com/archives/operation-queue-intro/" target="_blank" rel="external">并发编程之Operation Queue</a></p>
<p><a href="http://www.jianshu.com/p/0b0d9b1f1f19#" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></p>
<p><a href="http://limboy.me/ios/2015/08/08/advanced-nsoperations.html" target="_blank" rel="external">Advanced NSOperations</a></p>
<p><a href="http://oncenote.com/2015/03/22/Threading-Run-Loop/" target="_blank" rel="external">iOS并发编程（Concurrency Programming）系列</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/iOS/">iOS</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/GCD/">GCD</a><a href="/tags/iOS/">iOS</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2015/07/05/Grand-Central-Dispatch-gcd/#comments" class="ds-thread-count comments-count-link" data-thread-key="2015/07/05/Grand-Central-Dispatch-gcd/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/IM/" title="IM">IM<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/iOS/" title="iOS">iOS<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/swift/" title="swift">swift<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/开发利器/" title="开发利器">开发利器<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/设计模式/" title="设计模式">设计模式<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS/" title="iOS">iOS<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/开发利器/" title="开发利器">开发利器<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/IM/" title="IM">IM<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/swift/" title="swift">swift<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/设计模式/" title="设计模式">设计模式<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/webRTC/" title="webRTC">webRTC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/调试/" title="调试">调试<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/数据存储/" title="数据存储">数据存储<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/代码管理/" title="代码管理">代码管理<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ice/" title="ice">ice<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GCD/" title="GCD">GCD<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/图像处理/" title="图像处理">图像处理<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://casatwy.com" target="_blank" title="App架构相关文章">田伟宇</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="hexo相关学习">Jark&#39;s Blog</a>
            
          </li>
        
          <li>
            
            	<a href="http://tool.lu/favicon" target="_blank" title="icon制作在线工具">Icon制作</a>
            
          </li>
        
          <li>
            
            	<a href="http://yulingtianxia.com" target="_blank" title="杨萧玉目前在支付宝实习，负责移动开发">玉令天下的博客</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.callmewhy.com" target="_blank" title="汪海，全名汪海洋">Why’s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> “Hello ,I&#39;m ZhuLi in Chinasofti.” <br/>
			“This is my blog,believe it or not.”</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/zhuli8" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/zhuli8com" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="https://www.zhihu.com/people/zhu-li-68-76" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:zhuli1228@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="朱利">朱利</a>
		
		
		</p>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','TqhyGfTT5KJKMHcgZnBF','2.0.0');
</script>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"zhuli8"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_3725936'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3D3725936' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
